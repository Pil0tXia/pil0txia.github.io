<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统学习笔记 | Pil0tXia</title><meta name="author" content="Pil0tXia"><meta name="copyright" content="Pil0tXia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 操作系统引论单道批处理 多道批处理多道批处理系统宏观上并行微观上串行的含义   并发与并行的区别一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。 分时操作系统 实时操作系统  操作系统的四个基础特性并发性，共享性，虚拟性，异步性 异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习笔记">
<meta property="og:url" content="https://pil0txia.com/post/2022-09-08_os-notes/index.html">
<meta property="og:site_name" content="Pil0tXia">
<meta property="og:description" content="第一章 操作系统引论单道批处理 多道批处理多道批处理系统宏观上并行微观上串行的含义   并发与并行的区别一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。 分时操作系统 实时操作系统  操作系统的四个基础特性并发性，共享性，虚拟性，异步性 异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg">
<meta property="article:published_time" content="2022-09-08T03:11:56.000Z">
<meta property="article:modified_time" content="2022-12-06T13:31:23.720Z">
<meta property="article:author" content="Pil0tXia">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="本科CS课程笔记">
<meta property="article:tag" content="大三上">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg"><link rel="shortcut icon" href="https://static.pil0txia.com/assets/favicon.ico"><link rel="canonical" href="https://pil0txia.com/post/2022-09-08_os-notes/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="rTQaiWh7-ABfHgHfDRir5VZEmaT71cHgcV-IPp_hjjk"/><meta name="baidu-site-verification" content="NJqTNAqxF4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-06 21:31:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/assets/03_3_tinypng.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Pil0tXia</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-08T03:11:56.000Z" title="发表于 2022-09-08 11:11:56">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-06T13:31:23.720Z" title="更新于 2022-12-06 21:31:23">2022-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>113分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><h2 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/Pasted%20image%2020220908221259.png"></p>
<h2 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/PriceCheap/article/details/125256919">多道批处理系统宏观上并行微观上串行的含义</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220908223051244.png" alt="image-20220908223051244"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220908224939144.png" alt="image-20220908224939144"></p>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p><strong>一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。</strong></p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220908225751025.png" alt="image-20220908225751025"></p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220908230010886.png" alt="image-20220908230010886"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220908230154923.png" alt="image-20220908230154923"></p>
<h2 id="操作系统的四个基础特性"><a href="#操作系统的四个基础特性" class="headerlink" title="操作系统的四个基础特性"></a>操作系统的四个基础特性</h2><p><strong>并发性，共享性，虚拟性，异步性</strong></p>
<p>异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。</p>
<h2 id="现代OS的基本单位"><a href="#现代OS的基本单位" class="headerlink" title="现代OS的基本单位"></a>现代OS的基本单位</h2><p>内核、进程、线程、类程、管程</p>
<h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220919150833779.png" alt="image-20220919150833779"></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://chorer.github.io/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">Focus on FE learning 操作系统学习笔记-2：体系结构设计和运行机制</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://quemingfei.com/archives/wang-dao-kao-yan-cao-zuo-xi-tong-xue-xi-bi-ji-hui-zong">《王道考研 操作系统》学习笔记汇总</a></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220922101548539.png" alt="image-20220922101548539"></p>
<p>微内核中，应用程序与OS内核的通信：系统调用；非内核功能（用户空间的OS）和OS内核的通信：消息传递；非内核功能之间的通信：直接调用。</p>
<p>用户态切换到内核态的3种方式：系统调用、异常、外围设备的中断</p>
<p>内核态切换到用户态的方式：特权指令，设置程序状态字为PSW</p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断的类型：内中断（也称为“异常”、例外）；外中断（也称为“中断”）</p>
<p>内中断的案例：非法指令；应用程序请求操作系统时发出“陷入指令”，该指令会引发一个内部中断指令，意味着应用程序主动将CPU控制权还给OS。“系统调用”就是通过陷入指令完成。</p>
<p>中断处理程序一定是内核程序，需要运行在“内核态”。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是应用程序获得OS服务的唯一途径。内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。</p>
<h3 id="系统调用的方式"><a href="#系统调用的方式" class="headerlink" title="系统调用的方式"></a>系统调用的方式</h3><p>用户-&gt;应用程序-&gt;系统调用（系统调用组成了程序接口API，每一个系统调用都是一个完成特定功能的子程序）-&gt;OS内核（裸机）</p>
<p>用户-&gt;图形窗口-&gt;OS内核（裸机）</p>
<p>用户-&gt;操作命令-&gt;系统程序（操作接口由一组控制命令和作业控制语句组成）-&gt;OS内核（裸机）</p>
<h3 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h3><p>应用程序不可以直接调用系统调用，是通过库函数调用系统调用的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220922111334895.png" alt="image-20220922111334895"></p>
<h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220922111557735.png" alt="image-20220922111557735"></p>
<p><strong>冷启动</strong></p>
<p>（1）开机执行BIOS引导程序，标识和配置所有的即插即用设备，并配置DMA通道</p>
<p>（2）完成加电自检，测试内存，端口，键盘，视频适配器，磁盘驱动器等基本设备，及CD-ROM驱动器。</p>
<p>（3）对引导驱动器引导分区定位：在CMOS中，可以自行设置引导顺序，一般顺序是软盘，磁盘，光驱；</p>
<p>（4）加载主引导记录以及引导驱动器的分区表，执行主引导记录MBR。</p>
<p>（5）装入操作系统</p>
<p><strong>热启动</strong></p>
<p>（1）BOOT被自动执行，指引CPU把操作系统从大容量存储器中传送到主存储器的易失区；</p>
<p>（2）BOOT要求CPU执行一条转移指令，转到这个存储区域；此时，操作系统接管并且开始控制整个机器的活动。</p>
<h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><p>为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？</p>
<p>采用多道程序设计减少了CPU时间的浪费，增加了系统吞吐量，提高了系统的效率。.多道程序并发执行是指有的程序正在CPU上执行，而另一些程序正在I&#x2F;O设备上进行传输，即通过CPU操作与外设传输在时间上的重叠减少CPU时间的浪费，并提高了系统的效率。实现CPU操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：</p>
<p>（1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立与CPU运行，因而做到了输入输出操作与CPU并行工作。但早期CPU与通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到CPU与I&#x2F;O设备并行工作的。</p>
<p>（2）在硬件上引入了中断技术。所谓中断，就是在输入输出结束时，或硬件发生某种故障时，由相应硬件（即中断机构）向CPU发出信号。这时CPU立即停下手头的工作而转向处理中断请求，道处理完中断后再继续原来手头的工作。因此，通道技术和中断技术结合起来就可实现CPU与I&#x2F;O设备并行工作，即CPU启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作。这样，就真正做到了CPU与I&#x2F;O设备并行工作。此时，多道程序的概念才变为现实。</p>
<h2 id="作业2（书面版进行了概括）"><a href="#作业2（书面版进行了概括）" class="headerlink" title="作业2（书面版进行了概括）"></a>作业2（书面版进行了概括）</h2><ol>
<li><p>设计现代OS的主要目标是什么？</p>
<p>方便性，有效性，可扩充性，开放性</p>
</li>
<li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。</p>
<p>（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微秒。</p>
<p>（2）交互性：实时信息处理系统具有交互性，但实时终端设备只是作为执行装置或咨询装置，人与系统的交互仅限于访问系统中某些特定的专用服务程序。分时系统的用户可以与系统进行人机交互，包括在终端上可以直接调试自己的程序，系统能向终端用户提供数据和资源共享等服务。</p>
<p>（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。</p>
</li>
<li><p>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？</p>
<p>（1）OS 环境下与一般情况下的资源共享间的不同点</p>
<p>①一般情况下的共享</p>
<p>一般情况下的共享只是说明某种资源能被大家使用，对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。</p>
<p>②OS 环境下的共享</p>
<p>OS 环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。</p>
<p>（2）独占资源应采取的共享方式</p>
<p>对独占资源应采用互斥共享方式，该共享方式仅当占有该资源的进程访问并释放资源后，才允许另一进程对该资源进行访问。</p>
</li>
<li><p>什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。</p>
<p>（1）时分复用技术的定义<br>时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。<br>（2）时分复用技术能提高资源利用率的根本原因<br>时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务使设备得到最充分的利用。</p>
</li>
<li><p>何谓微内核技术？在基于微内核结构的OS中，应用了哪些新技术？在微内核中通常提供了哪些功能？</p>
<p>（1）把操作系统中更多的成分和功能放到更高的层次(即用户模式)中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。 </p>
<p>（2）面向对象的程序设计技术。</p>
<p>（3）在微内核中通常提供了进程(线程)管理、低级存储器管理、中断和陷入处理等功能。</p>
</li>
</ol>
<h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>最近我的操作系统老师和软件工程老师都在上课时讲鸿蒙OS有多么多么划时代，可事实上并非如此。我一问才知道，是华为有人找他们合作，让他们上课时多放入一点鸿蒙的知识。我理解鸿蒙是一个较为优秀的国产定制系统，但是把它等同于目前所有系统、实时操作系统的下一代系统，实在太误人子弟。</p>
<p>19年鸿蒙说是要完全自主开发内核，22年现在却在用AOSP<code>Andriod Open Source Project</code>；“分布式”有两个，真正意义上的分布式可以同步两台设备上同一版本软件的操作，目前还停留在SDK阶段，大肆宣传的那个分布式不过是投屏罢了。</p>
<p>要说怪谁，只能怪一开始饼画太大，缺口已经补不上了。其实按照开源协议使用开源代码不丢人，丢人的是欲盖弥彰啊。</p>
<h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="程序的基本概念"><a href="#程序的基本概念" class="headerlink" title="程序的基本概念"></a>程序的基本概念</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926155011586.png" alt="image-20220926155011586"></p>
<p>可再现性</p>
<h3 id="为什么程序不能调度？"><a href="#为什么程序不能调度？" class="headerlink" title="为什么程序不能调度？"></a>为什么程序不能调度？</h3><p>程序具有独立性，结果再现。如果程序执行过程中，出现结果无法再现的情况，则程序肯定有问题。如果要让程序被调度，必须满足Berstein条件（任意两条读写的交集不能为空，很难实现）。</p>
<h3 id="判断程序是否可以并发"><a href="#判断程序是否可以并发" class="headerlink" title="判断程序是否可以并发"></a>判断程序是否可以并发</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926154724920.png" alt="image-20220926154724920"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926154807286.png" alt="image-20220926154807286"></p>
<p>（1）程序顺序执行，因为某一时段独占全机，所以结果可再现。</p>
<p>（2）程序并发执行，若不满足Bernstein条件，则结果不再现。</p>
<p>总之，程序不可以并发执行。</p>
<h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926164342078.png" alt="image-20220926164342078"></p>
<p>正是因为有了PCB，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但PCB可以记录此时进程的状态。所以进程是“动态”的。</p>
<blockquote>
<p>简答题“程序为什么不能被调度+进程为什么可以并发执行”是捆绑在一起的。</p>
</blockquote>
<p>父&#x2F;子标识指向父&#x2F;子进程的PID</p>
<ul>
<li>进程调度信息</li>
</ul>
<p>进程的状态：三态、五态、七态</p>
<p>进程的优先级：一个整数</p>
<p>进程调度需要的信息：如等待CPU的时间、执行CPU的时间等等，是调度的一个参考。</p>
<p>阻塞原因：执行-&gt;阻塞状态转换发生的事件</p>
<ul>
<li>进程的控制信息</li>
</ul>
<p>程序和数据在内存、外存的地址</p>
<p>进程同步和通信机制</p>
<p>资源清单：列出除了CPU以外进程所需资源和已经拿到的资源。</p>
<p>链接指针：指出本进程的pcb在pcb队列中下一个进程的pcb首地址</p>
<h3 id="进程控制块PCB的组织方式"><a href="#进程控制块PCB的组织方式" class="headerlink" title="进程控制块PCB的组织方式"></a>进程控制块PCB的组织方式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926165848247.png" alt="image-20220926165848247"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220926170442110.png" alt="image-20220926170442110"></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote>
<p>为什么程序不能被调度？为什么要引入进程？</p>
</blockquote>
<p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E8%B0%83%E5%BA%A6%EF%BC%9F">为什么程序不能调度？</a></p>
<p><a href="#%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%8F%91">为什么程序不能并发？</a></p>
<p><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB">为什么要引入进程？</a></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制由“<strong>原语</strong>”实现。原语具有“原子性”，要么不被执行，一旦被执行，不可以被中断。</p>
<p>在<strong>关中断指令</strong>下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在<strong>开中断指令</strong>下，才会去处理中断。</p>
<p>原语的基本操作包括：</p>
<ul>
<li>更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）</li>
<li>将 PCB 插入到合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ul>
<p>创建原语和撤销原语配对，阻塞原语和唤醒原语配对。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_104925.jpg" alt="IMG_20221006_104925"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_111051.jpg" alt="IMG_20221006_111051"></p>
<p>进程的执行是“异步”的，进程的控制是“原子性”的。</p>
<h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_111447.jpg" alt="IMG_20221006_111447"></p>
<p>阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在CPU中。</p>
<h4 id="五态"><a href="#五态" class="headerlink" title="五态"></a>五态</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_153725.jpg" alt="IMG_20221006_153725"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221006134335445.png" alt="image-20221006134335445"></p>
<p>创建进程的过程在内存里完成。</p>
<h4 id="七态（重要，在后面的章节会有所拓展）"><a href="#七态（重要，在后面的章节会有所拓展）" class="headerlink" title="七态（重要，在后面的章节会有所拓展）"></a>七态（重要，在后面的章节会有所拓展）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg" alt="IMG_20221006_153249"></p>
<h5 id="静止阻塞-x2F-就绪队列的理解"><a href="#静止阻塞-x2F-就绪队列的理解" class="headerlink" title="静止阻塞&#x2F;就绪队列的理解"></a>静止阻塞&#x2F;就绪队列的理解</h5><p>当我们把作业从外存拿到内存时，这个过程叫做高级调度。</p>
<p>进程PCB被创建后，PCB存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。</p>
<p>如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。</p>
<p>如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。</p>
<h5 id="挂起的原因"><a href="#挂起的原因" class="headerlink" title="挂起的原因"></a>挂起的原因</h5><p>负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要</p>
<h5 id="挂起的特征"><a href="#挂起的特征" class="headerlink" title="挂起的特征"></a>挂起的特征</h5><ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li>
<li>进程进入挂起状态是由于操作系统父进程或进程本身阻止它的运行</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出</li>
</ul>
<h5 id="状态转换的汇总"><a href="#状态转换的汇总" class="headerlink" title="状态转换的汇总"></a>状态转换的汇总</h5><table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">活动就绪态 → 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。<strong>处于静止就绪态的进程不再被调度执行</strong>；</td>
</tr>
<tr>
<td align="center">静止就绪态 → 活动就绪态</td>
<td align="center">内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行</td>
</tr>
<tr>
<td align="center">活动阻塞态→ 静止阻塞态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 静止就绪态</td>
<td align="center">常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 活动阻塞态</td>
<td align="center">但有时候，如果<strong>静止阻塞态进程</strong>的优先级高于<strong>静止就绪队列中的任何进程</strong>、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态</td>
</tr>
<tr>
<td align="center">运行态→ 静止就绪态</td>
<td align="center">优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态</td>
</tr>
<tr>
<td align="center">创建态→ 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存</td>
</tr>
</tbody></table>
<p>进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。</p>
<h3 id="进程的创建（创建原语）"><a href="#进程的创建（创建原语）" class="headerlink" title="进程的创建（创建原语）"></a>进程的创建（创建原语）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221010_143627.jpg" alt="IMG_20221010_143627"></p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配其运行所需的资源</li>
<li>初始化PCB</li>
<li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。</li>
</ol>
<h3 id="进程的终止（撤销原语）"><a href="#进程的终止（撤销原语）" class="headerlink" title="进程的终止（撤销原语）"></a>进程的终止（撤销原语）</h3><p>引起进程终止的事件包括正常结束、异常结束和外界干预。</p>
<p>终止进程的过程包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221006_114004.jpg" alt="IMG_20221006_114004"></p>
<ol>
<li>进入终止态的进程不能再执行</li>
<li>OS中保留其记录（状态码+计时统计数据），供其他进程收集</li>
<li>一旦其他进程完成了对终止状态进程的信息提取，OS将删除该进程</li>
</ol>
<h3 id="进程的阻塞（阻塞原语block）"><a href="#进程的阻塞（阻塞原语block）" class="headerlink" title="进程的阻塞（阻塞原语block）"></a>进程的阻塞（阻塞原语block）</h3><p>阻塞进程的过程包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的阻塞队列（即改变它的链接地址）。</p>
<p>引起进程阻塞的事件一般是：</p>
<ul>
<li>请求系统分配共享资源失败（系统已无足够的资源）</li>
<li>等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 I&#x2F;O 操作）</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ul>
<blockquote>
<p>进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程<strong>自己调用了</strong>阻塞原语。</p>
</blockquote>
<h3 id="进程的唤醒（唤醒原语wake-up）"><a href="#进程的唤醒（唤醒原语wake-up）" class="headerlink" title="进程的唤醒（唤醒原语wake up）"></a>进程的唤醒（唤醒原语wake up）</h3><p>唤醒进程的过程包括：在事件阻塞队列中找到 PCB 并将进程移出队列，修改 PCB 的状态信息，再将 PCB 插入到就绪队列。</p>
<p>一般在等待的事件发生时，进程就会被唤醒。</p>
<blockquote>
<p>阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程<strong>自己调用了</strong>唤醒原语，而是“合作”或相关进程进行了调用。</p>
</blockquote>
<h3 id="进程的切换（切换原语）"><a href="#进程的切换（切换原语）" class="headerlink" title="进程的切换（切换原语）"></a>进程的切换（切换原语）</h3><p>前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。</p>
<p>切换原语负责让当前运行的进程从 A 切换为 B，具体包括：</p>
<ul>
<li>一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）</li>
<li>另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）</li>
</ul>
<p>引起进程切换的事件一般有四种：</p>
<ul>
<li>当前进程的时间片被消耗完</li>
<li>有更高优先级的进程到达，抢占了当前进程正在使用的 CPU</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h3 id="进程的挂起（挂起原语suspend和激活原语active）"><a href="#进程的挂起（挂起原语suspend和激活原语active）" class="headerlink" title="进程的挂起（挂起原语suspend和激活原语active）"></a>进程的挂起（挂起原语suspend和激活原语active）</h3><p><strong>挂起原语：</strong></p>
<p>将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（活动就绪态 -&gt; 静止就绪态，活动阻塞态 -&gt; 静止阻塞态），之后将该 PCB 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。</p>
<p>引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。</p>
<p><strong>激活原语：</strong></p>
<p>将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态-&gt;活动就绪态，静止阻塞 -&gt; 活动阻塞态）。</p>
<p>引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。</p>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>结构性：程序块、数据块、进程控制块PCB</p>
<p>动态性：进程是程序在数据集合上的一次执行过程，有生命周期（由创建而产生、由调度而执行、由事件而等待、由撤销而消亡）</p>
<p>并发性：多个进程实体同时存在在内存中，能在一段时间内同时运行，是进程的重要特征</p>
<p>独立性：进程是独立运行、独立获取资源、独立接受调度的基本单位 -&gt; 线程就不独立，它没有资源，依赖于fork的进程的资源</p>
<p>异步性：进程按各自独立的、不可预知的速度向前推进。OS要根据“进程同步机制”来解决异步问题。</p>
<p>操作系统的“虚拟性”是进程所没有的。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。然而，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为<strong>临界资源</strong>——也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。我们通过<strong>进程互斥</strong>来解决此类问题。</p>
</blockquote>
<p>进程同步：指多个相关进程在执行次序上的协调</p>
<p>进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问</p>
<p>临界资源：一次仅供一个进程使用的资源</p>
<p>临界区：在进程中涉及到临界资源的程序段叫临界区</p>
<p>相关临界区：多个进程的临界区称为相关临界区</p>
<h4 id="进程互斥的基本实现逻辑"><a href="#进程互斥的基本实现逻辑" class="headerlink" title="进程互斥的基本实现逻辑"></a>进程互斥的基本实现逻辑</h4><p>为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    extry section;       <span class="comment">// 进入区</span></span><br><span class="line">    critical section;    <span class="comment">// 临界区</span></span><br><span class="line">    exit section;        <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;   <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；</li>
<li>临界区：实际访问临界资源的那段代码</li>
<li>退出区：负责解除之前的 Flag</li>
<li>剩余区：其它处理</li>
</ul>
<p>对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。</p>
<h4 id="同步机制应遵循的原则"><a href="#同步机制应遵循的原则" class="headerlink" title="同步机制应遵循的原则"></a>同步机制应遵循的原则</h4><p>空闲让进：临界区空闲时，应该让想要进入临界区的进程立刻进来</p>
<p>忙则等待：同一时刻只允许一个进程进入临界区</p>
<p>有限等待：要求访问临界资源的进程，应该保证在有限时间内进入临界区</p>
<p>让权等待：当 A 进程进入临界区而导致 B 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入“忙等”状态。</p>
<h3 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h3><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制可以让用户通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而方便地实现进程互斥和进程同步。信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语（或者说是 P 操作和 V 操作，即通过和释放），可以看作是两个函数。</p>
<h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int S = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">wait</span>(<span class="params">int S</span>)               </span><br><span class="line">&#123;                       </span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)			</span><br><span class="line">    S = S-<span class="number">1</span>              </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">int S</span>)</span><br><span class="line">&#123;</span><br><span class="line">    S = S+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样以进程 P0，P1 为例进行说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">P0</span>：                   <span class="attr">P1</span>:</span><br><span class="line"><span class="title function_">wait</span>(S)                <span class="title function_">wait</span>(S)            <span class="comment">// 进入区</span></span><br><span class="line">critical section       critical section   <span class="comment">// 临界区</span></span><br><span class="line"><span class="title function_">signal</span>(S)              <span class="title function_">signal</span>(S)          <span class="comment">// 退出区 </span></span><br></pre></td></tr></table></figure>

<p>假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行“检查”和“上锁”，由于 S 一开始是1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S &#x3D; 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。</p>
<p>整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查”和“上锁”两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是<strong>仍然违背了“让权等待”的原则</strong>。</p>
<p>于是在此基础上，又出现了记录型信号量</p>
<h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 <code>value</code>，而且还提供了一个等待队列 <code>L</code>。</p>
<p>记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，<strong>直接让它自己去阻塞队列</strong>，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。</p>
<p>记录型信号量的结构如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value</span><br><span class="line">    sturct process *L</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure>

<p>同时，记录型信号量的 P、V 操作也有所不同，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait (semaphore S)&#123;</span><br><span class="line">    S.<span class="property">value</span>--</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">block</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">semaphore S</span>)&#123;</span><br><span class="line">    S.<span class="property">value</span>++</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">wakeup</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里要注意的第一个地方是，<code>value</code> 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。</li>
<li>第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿</li>
<li>执行++或–前，<code>S.value</code>为正值时代表可利用的物理资源数；<code>S.value</code>为负值时，其绝对值代表阻塞队列中等待的进程数。</li>
</ul>
<p>下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PO</span>:            <span class="variable constant_">P1</span>              <span class="variable constant_">P2</span>           <span class="variable constant_">P3</span></span><br><span class="line"><span class="title function_">wait</span>(S)        <span class="title function_">wait</span>(S)         <span class="title function_">wait</span>(S)      <span class="title function_">wait</span>(S)</span><br><span class="line">临界区          临界区           临界区        临界区</span><br><span class="line"><span class="title function_">signal</span>(S)      <span class="title function_">signal</span>(S)       <span class="title function_">signal</span>(S)    <span class="title function_">signal</span>(S)</span><br></pre></td></tr></table></figure>

<p>假设计算机中有两台可用的打印机 A 和 B（也就是说，value &#x3D; 2），有四个进程需要用到打印机资源。</p>
<p>一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始“干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区“干活”。自此，两个打印机都被占用了。</p>
<p>在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 &lt; 0，前面我们说过，value &lt; 0 说明无可用资源，所以此时 P2 将自己<strong>主动</strong>送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。</p>
<p>处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。</p>
<p>当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。</p>
<p>显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常“老实”地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法“既方便了别人，也方便了自己”。这就正好与我们多次强调的“让权等待”非常契合了。</p>
<blockquote>
<p>记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。</p>
</blockquote>
<p>我们通过几道题加深一下印象：</p>
<ul>
<li>n 个并发进程，信号量初始值为 1，当 n 个进程都执行 P 操作后，信号量的值为多少？</li>
<li>信号量初值为 4，多次 PV 操作后变为 -2，那么获得资源的进程数目是多少？</li>
<li>5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？</li>
</ul>
<p>（1）每执行一次 P 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 P 操作，所以此后信号量的值是 1-n</p>
<p>（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源</p>
<p>（3）信号量初始值为3，所以最大值为3，如果 5 个进程都执行 P 操作，那么信号量会变成 3-5 &#x3D; -2，即最小值为 -2，所以取值范围 -2 ~ 3。</p>
<h4 id="信号量机制实现"><a href="#信号量机制实现" class="headerlink" title="信号量机制实现"></a>信号量机制实现</h4><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>其实上面讲的例子就已经很好地实现了进程互斥，但是我们可以简化一下写法，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">P0</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex) <span class="comment">//使用临界资源前需要加锁</span></span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex) <span class="comment">//使用临界资源前需要解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex)</span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们默认已经定义了 semaphore 的结构体，并用<strong>互斥信号量 mutex</strong> 记录可用资源的个数（进入临界区的名额），初始值为1。要实现互斥，关键就是要<strong>在临界区之前使用 P 操作进行上锁，在临界区之后使用 V 操作进行解锁</strong>。</p>
<p>PV操作要成对出现，但不一定要在同一个进程中。不同的临界资源设置不同的互斥信号量。记录型信号量有时需要自己定义。</p>
<h5 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h5><p>多个进程（如P1、P2）一起完成某项任务的时候，如何确保它们按照一定的先后顺序（先P1后P2）有秩序地执行呢？信号量机制也可以很好地实现进程同步。它有三个关键步骤：</p>
<ul>
<li>设置<strong>同步信号量</strong>初始值为 0</li>
<li>在“前操作”之后执行 V(S)</li>
<li>在“后操作”之前执行 P(S)</li>
</ul>
<p>首先，<strong>0 是一个非常关键的“分水岭”</strong>，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。</p>
<p>我们要确保“前操作”在前面，“后操作”在后面，实际上只要做到三件事：V 在“前操作”后面、P 在“后操作”前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而<strong>要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0</strong>，因为一旦初始值为 0，则每当 P 想要“违规”抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：</p>
<p><strong>P 先于 V 执行 &#x3D;&gt; P 所在进程会被阻塞 &#x3D;&gt; ”后操作“始终无法执行</strong></p>
<p>所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在“前操作”后面，所以一定是“前操作”执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— <strong>虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞</strong>，所以 P 执行完后就顺序执行“后操作”。由此，我们确保了两个操作一定是严格按照先后顺序执行的。</p>
<p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序应该是：code1,code2,code4</span></span><br><span class="line"><span class="variable constant_">P0</span>：                 <span class="attr">P1</span>:</span><br><span class="line">code <span class="number">1</span>               <span class="title function_">P</span>(S)</span><br><span class="line">code <span class="number">2</span>               code <span class="number">4</span></span><br><span class="line"><span class="title function_">V</span>(S)                 code <span class="number">5</span></span><br><span class="line">code <span class="number">3</span>               code <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>我们设想比较差的情况 —— P1 想要抢先执行 code 4，看看会发生什么。假设是 P1 首先占用处理机，那么就会执行 P 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 P1 进程阻塞；这之后，处理机来到 P0，执行 code1，code2，V 操作，使得信号量由 -1 变成 0，同时唤醒 P1 进程；P1 进程被唤醒后从 P 操作之后的断点继续执行（P1 被唤醒后不会重新再执行一遍P操作，否则会再次进入阻塞。与七态中进程所需资源得到满足后会从阻塞队列转入就绪队列相同，P1 会接着之前停下的地方继续），来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。</p>
<h5 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h5><p>前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code 语句仍然是前操作或者后操作，P1 进程有 code1 语句，P2 进程有 code2 语句… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092030.png"></p>
<p>其实这种情况就是把多个同步问题结合起来，我们仍然可以用信号量机制来实现：</p>
<ul>
<li>每一个前驱关系都是一个同步问题，要保证一前一后的操作</li>
<li>为每一个前驱关系各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行V操作</li>
<li>在“后操作”之前对相应的同步信号量执行P操作</li>
</ul>
<p>代码大概如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:          <span class="attr">P3</span>:          <span class="attr">P4</span>:        </span><br><span class="line">code1        <span class="title function_">P</span>(signal1)   <span class="title function_">P</span>(signal2)   <span class="title function_">P</span>(signal3)</span><br><span class="line"><span class="title function_">V</span>(signal1)   code2        code3        code4 </span><br><span class="line"><span class="title function_">V</span>(signal2)   <span class="title function_">V</span>(signal3)   <span class="title function_">V</span>(signal7)   <span class="title function_">V</span>(signal5)</span><br><span class="line">             <span class="title function_">V</span>(signal4)</span><br><span class="line"><span class="attr">P5</span>:          <span class="attr">P6</span>:         </span><br><span class="line"><span class="title function_">P</span>(signal4)   <span class="title function_">P</span>(signal5)   </span><br><span class="line">code5        <span class="title function_">P</span>(signal6) </span><br><span class="line"><span class="title function_">V</span>(signal6)   <span class="title function_">P</span>(signal7)</span><br><span class="line">             code6</span><br></pre></td></tr></table></figure>

<p>可以观察到，除了 P1 进程之外，其它进程首先执行的都是 P 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——</p>
<p>假设一开始是 P2 占有处理机，那么由于 signal1 初始为 0，导致了 P2 进队列，此后处理机来到 P3，P3 同样进队列… 以此类推，阻塞队列就会变成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092052.png"></p>
<p>随后总算来到 P1 进程了，P1 进程作为一切的开始，特殊之处就在于它不是以 P 操作开始的，P1 会首先执行 V(signal1)，这一步把 signal1 加一，同时唤醒 P2 进程，P2 进程进入就绪队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092059.png"></p>
<p>再之后，P1 执行 V(signal2)，这一步把 signal2 加一，同时唤醒 P3 进程，P3 进程也进入就绪队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092212.png"></p>
<p>P1 执行完之后，就绪队列队头的 P2 进入运行态，执行到 V(signal3) 的时候，signal3 加一，同时唤醒 P4 进程，P4 进程进入就绪队列，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092320.png"></p>
<p>再之后，P2 执行 V(signal4)，这一步把 signal4 加一，同时唤醒 P5 进程，P5 进程也进入就绪队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092343.png"></p>
<p>P2 执行完之后，处理机调度就绪队列队头的 P3 开始执行，P3 执行到 V(signal7) 的时候，signal7 加一，<strong>注意这一步没有唤醒任何进程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092414.png"></p>
<p>P3 执行完之后，处理机调度就绪队列队头的 P4 开始执行，P4 执行到 V(signal5) 的时候，signal5 加一，同时唤醒 P6 进程，P6 进程进入就绪队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092431.png"></p>
<p>P4 执行完之后，处理机调度就绪队列队头的 P5 开始执行，P5 执行到 V(signal6) 的时候，signal6 加一，<strong>注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092450.png"></p>
<p>P5 执行完之后，处理机调度就绪队列队头的 P6 开始执行，P6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/20221017092510.png"></p>
<p>这样基本就把整个流程过了一遍，当然，经过排列组合之后，分析过程都是大同小异的。</p>
<h3 id="信号量和PV操作解决进程同步问题"><a href="#信号量和PV操作解决进程同步问题" class="headerlink" title="信号量和PV操作解决进程同步问题"></a>信号量和PV操作解决进程同步问题</h3><h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者-消费者问题是系统中并发进程内在关系的一种抽象，是典型的进程同步问题。生产者进程P1可以是计算进程、发送进程；而消费者进程P2可以是打印进程、接收进程等等。</p>
<blockquote>
<p>有界缓冲：</p>
<ul>
<li>一个生产者一次放入缓冲区一个产品，且无限次循环</li>
<li>一个消费者一次取出缓冲区一个产品，且无限次循环</li>
<li>两个进程独立</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>缓冲池满生产者不能放产品</li>
<li>缓冲池空消费者不能取产品</li>
<li>只能一个生产者或者消费者对缓冲区进行操作</li>
</ul>
</blockquote>
<p>进程个数：2</p>
<p>关系分析：</p>
<ul>
<li>互斥关系 P1、P2互斥访问缓冲区</li>
<li>同步关系 P1生产后P2才能消费</li>
</ul>
<p>信号量设置：</p>
<ul>
<li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li>
<li>同步信号量<code>empty = n</code> ，表示空闲缓冲区的数量</li>
<li>同步信号量<code>full = 0</code> ，表示非空闲缓冲区的数量，也即产品数量</li>
</ul>
<p>产品： <code>P1 V</code> <code>P2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p>
<p>空间：<code>P1 P</code> <code>P2 V</code></p>
<p>先考虑对互斥关系的实现。这里的临界资源是缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。P1、P2都各有一对 PV 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 PV 操作之前，必定要先生产产品；而消费者在进行 PV 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                              <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                             从缓冲区中取走产品 </span><br><span class="line">		把产品放入缓冲区                       <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">V</span>(mutex)                             使用产品 </span><br><span class="line">    &#125;                                   &#125;</span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>接着考虑第一个同步关系，关注空缓冲区。先释放缓冲区，后使用缓冲区，且缓冲区满不再放入产品，所以这里“前操作”是消费者释放缓冲区，“后操作”是生产者占用缓冲区，根据 “前V后P”，我们需要在“前操作”之后针对 empty 这个信号量进行一次 V 操作，需要在“后操作”之前针对 empty 进行一次 P 操作。生产者执行 P 操作检查是否还有空缓冲区时，若缓冲区已满，将进入阻塞。所以，这时候代码变成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                             <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(empty)                            从缓冲区中取走产品 </span><br><span class="line">		<span class="title function_">P</span>(mutex)                            <span class="title function_">V</span>(mutex)</span><br><span class="line">        把产品放入缓冲区                      <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(mutex)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>再考虑第二个同步关系，关注产品。先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再安排一对 PV 操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(full)</span><br><span class="line">        <span class="title function_">P</span>(empty)                           <span class="title function_">P</span>(mutex)</span><br><span class="line">		<span class="title function_">P</span>(mutex)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>这就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty &#x3D; n，表示所有缓冲区都是空闲的，同时 full &#x3D; 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 <code>P(full)</code> 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 <code>P(empty)</code> 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。</p>
<blockquote>
<p>P 操作不可以随意对调位置，V 操作可以。</p>
</blockquote>
<p><strong>这里要注意可能会引起“死锁”现象的一种写法。如下所示：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                           <span class="title function_">P</span>(full)</span><br><span class="line">		<span class="title function_">P</span>(empty)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的“上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接“上锁”了，这导致它在 <code>P(full)</code> 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 <code>P(mutex)</code> 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了“死锁”。</p>
<p>另一种情况，我们也可以设想一开始处理机是在 producer 这里，依然会导致“死锁”。按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 <code>P(empty)</code> 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 <code>P(mutex)</code> 这一步陷入等待。也就是说，这不过是前面那种”死锁“现象的翻版。</p>
<p><strong>总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。</strong></p>
<h4 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h4><p>盘子 缓冲区</p>
<p>2水果 2产品</p>
<p>爸爸 妈妈 2生产者，P1 P2</p>
<p>儿子 女儿 2消费者，C1 C2</p>
<p>进程个数：4</p>
<p>关系分析：</p>
<ul>
<li>互斥关系 P1、P2、C1、C2互斥访问缓冲区</li>
<li>同步关系 P1生产后C1才能消费，P2生产后C2才能消费</li>
</ul>
<p>信号量设置：</p>
<ul>
<li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li>
<li>同步信号量<code>apple = 0</code> ，表示苹果的数量</li>
<li>同步信号量<code>orange = 0</code> ，表示橘子的数量</li>
</ul>
<p>产品： <code>P1 P2 V</code> <code>C1 C2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p>
<p>空间：<code>P1 P2 P</code> <code>C1 C2 V</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把苹果放入盘子</span><br><span class="line">      <span class="title function_">V</span>(apple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把橘子放入盘子</span><br><span class="line">      <span class="title function_">V</span>(orange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">C1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(apple)</span><br><span class="line">       从盘子中取走苹果</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="title function_">C2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(orange)</span><br><span class="line">       从盘子中取走橘子</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="银行问题"><a href="#银行问题" class="headerlink" title="银行问题"></a>银行问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221024_140725.jpg" alt="IMG_20221024_140725"></p>
<p>顾客的 V(full) 与 P(service) 应调换位置，并去除“获取服务”</p>
<p>service 默认值应为1</p>
<h4 id="五个哲学家进餐问题"><a href="#五个哲学家进餐问题" class="headerlink" title="五个哲学家进餐问题"></a>五个哲学家进餐问题</h4><p>一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：<strong>保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118204800390.png" alt="image-20221118204800390"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221024_145433.jpg"></p>
<p>如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么 1 号是会被阻塞的，所以这样相邻的哲学家中有一个可以吃饭。但是，如果 0 号拿起左筷子后进程切换到 1 号，1 号也拿起自己的左筷子，以此类推，所有的哲学家都只有左筷子，这导致了所有的哲学家都被阻塞，没有任何哲学家能够吃饭，也没有人可以释放筷子，使这些哲学家都陷入无限的等待中，造成“死锁”的发生。</p>
<p>解决这个问题有三个方法：</p>
<h5 id="实现原子操作"><a href="#实现原子操作" class="headerlink" title="实现原子操作"></a>实现原子操作</h5><p>很容易想到，拿起左筷子和拿起右筷子并不是一个原子操作。准备一个互斥信号量 <code>mutex = 1</code> ，并把拿筷子的操作封装在一个 PV 操作里。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 0 号哲学家拿起左筷子之后，即使发生进程切换，1 号进程也会被卡在 <code>mutex</code> 的 P 操作，被送往阻塞队列，其它进程也同理。所以最后再次来到 0 号进程时便可以顺利拿起右筷子。这种做法保证了有一个哲学家是可以吃饭的。</p>
<blockquote>
<p>这里涉及到了<strong>一个进程需要一次性两个资源才能完成任务</strong>的问题，也可以使用 AND 信号量集机制。AND 信号量集机制的 P 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到。一开始筷子数量足够，所以 0 号在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title class_">Swait</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title class_">Ssignal</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="只有四个人参与这个过程"><a href="#只有四个人参与这个过程" class="headerlink" title="只有四个人参与这个过程"></a>只有四个人参与这个过程</h5><p>之前的情况是五个哲学家，五支筷子，所以容易出现谁也无法吃饭的情况，但是如果规定整个过程最多只有四个哲学家参与，即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。</p>
<p>如何限定“最多四个人可以参与这个过程”呢？准备一个互斥信号量 <code>count</code>，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 <code>count</code> 减少到 -1 的时候，就不能再让哲学家进来了。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(count)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来演示前面发生“死锁”的过程。假如从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 <code>count</code> 数量充足，所以它不会阻塞，而是同样拿到了左筷子…以此类推，到了 4 号哲学家的时候，由于 <code>count = -1 &lt; 0</code>，所以它此时无法进来。 4 号哲学家左边的筷子在第一轮谁也没拿到，第二轮轮到 3 号哲学家时，就可以拿到这支筷子了。总会存在至少一个进程可以吃到饭。</p>
<h5 id="奇数拿左边，偶数拿右边"><a href="#奇数拿左边，偶数拿右边" class="headerlink" title="奇数拿左边，偶数拿右边"></a>奇数拿左边，偶数拿右边</h5><p>还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118205737280.png" alt="image-20221118205737280"></p>
<p>伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">eat</span>();</span><br><span class="line">			<span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>   <span class="comment">//奇数哲学家，先左后右。</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">eat</span>();</span><br><span class="line">			<span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。</p>
<p>这只是其中一种情况，但无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，因此这个“被淘汰的”进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子“淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote>
<p>信号量机制效率低，且通信对用户不透明</p>
</blockquote>
<h4 id="管程的基本思想"><a href="#管程的基本思想" class="headerlink" title="管程的基本思想"></a>管程的基本思想</h4><p>管程&#x3D;共享资源+同步操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221024_150901.jpg"></p>
<p>进入管程无法直接访问临界资源，而是通过管程的方法来访问临界资源：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221024_151827.jpg"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的概念"><a href="#进程通信的概念" class="headerlink" title="进程通信的概念"></a>进程通信的概念</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_135843.jpg" alt="IMG_20221031_135843"></p>
<p>任何时候都不能直接访问临界资源</p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>共享空间是临界区，P1和P2互斥访问（PV操作）</p>
<p>共享方式上，共享存储分为基于数据结构的共享（较为低级，速度慢限制多，例如开辟一个数组）和基于存储区的共享（高级通信方式，速度快，在内存中划出一块共享存储区，数据结构和存放位置都由进程控制，而不是OS）</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_140352.jpg" alt="IMG_20221031_140352"></p>
<p>从P2传回给P1时，必须再开辟一个管道，以实现全双工。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><a href="#%E5%86%85%E6%A0%B8">回顾第一章消息传递等通信方式</a></p>
<blockquote>
<h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。</p>
<h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="引入线程"><a href="#引入线程" class="headerlink" title="引入线程"></a>引入线程</h3><p>首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程<strong>既是一个携带资源的独立单位，也是独立调度的基本单位</strong>，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。</p>
<p>如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的<strong>线程</strong>了。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p><strong>调度的基本单位</strong></p>
<p>引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。</p>
<p><strong>执行的基本单位</strong></p>
<p>我们可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。但我们不能说“挂起线程”，只能说“挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程”没有意义。</p>
<p><strong>并发性</strong></p>
<p>进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。</p>
<p><strong>资源</strong></p>
<p>资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。虽然线程不携带资源，但它可以使用fork的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。</p>
<p><strong>系统开销</strong></p>
<p>在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。</p>
<blockquote>
<p><strong>独立性</strong></p>
<p>同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。</p>
<p><strong>支持多处理机系统</strong></p>
<p>传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。</p>
</blockquote>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。</p>
<h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_145313.jpg" alt="IMG_20221031_145313"></p>
<h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><p>作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是根据某种算法从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。</p>
<p>这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_150025.jpg" alt="IMG_20221031_150025"></p>
</blockquote>
<h4 id="内存调度"><a href="#内存调度" class="headerlink" title="内存调度"></a>内存调度</h4><p>内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存（虚拟内存）中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。引入中级调度的主要目的是提高内存利用率和系统吞吐量，它实际上就是存储器管理中的对换功能。</p>
<p>这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程（内核级线程），分配处理机给它。进程调度是最基本、次数最频繁的阶段。</p>
<p>这个阶段进程的状态变化是： 就绪态 –&gt; 活动态</p>
<blockquote>
<p>根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：非抢占式和抢占式，为抢占式时，抢占原则有：优先权原则、短作业（进程）优先原则、时间片原则。</p>
<p>抢占式的缺点在于进程切换频繁发生，系统开销大。优点在于对短作业而言能更及时的得到调度。</p>
</blockquote>
<h2 id="队列调度模型"><a href="#队列调度模型" class="headerlink" title="队列调度模型"></a>队列调度模型</h2><h3 id="仅有进程调度的队列模型"><a href="#仅有进程调度的队列模型" class="headerlink" title="仅有进程调度的队列模型"></a>仅有进程调度的队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_151833.jpg" alt="IMG_20221031_151833"></p>
<p>分时操作系统没有后备作业队列，所以没有高级调度；又因为此系统的应用范围大多只是查询，分配的任务比较简单，以时间片轮转的方式执行终端的任务，所以没有中级调度。也即分时操作系统只有低级调度。</p>
<h3 id="具有高级调度和低级调度的调度队列模型"><a href="#具有高级调度和低级调度的调度队列模型" class="headerlink" title="具有高级调度和低级调度的调度队列模型"></a>具有高级调度和低级调度的调度队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_152200.jpg" alt="IMG_20221031_152200"></p>
<p>看到这张图，要想到<a href="#%E4%BA%94%E6%80%81">五态转换</a></p>
<h3 id="具有三级调度的调度队列模型"><a href="#具有三级调度的调度队列模型" class="headerlink" title="具有三级调度的调度队列模型"></a>具有三级调度的调度队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221031_152456.jpg" alt="IMG_20221031_152456"></p>
<p>看到这张图，要想到<a href="#%E4%B8%83%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E4%BC%9A%E6%9C%89%E6%89%80%E6%8B%93%E5%B1%95%EF%BC%89">七态转换</a></p>
<h2 id="选择调度算法的原则"><a href="#选择调度算法的原则" class="headerlink" title="选择调度算法的原则"></a>选择调度算法的原则</h2><h3 id="面向用户的准则"><a href="#面向用户的准则" class="headerlink" title="面向用户的准则"></a>面向用户的准则</h3><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>面向批处理OS</p>
<p><strong>周转时间：</strong><code>作业完成时刻 - 作业提交时刻 = 作业实际运行的时间 + 等待时间</code></p>
<blockquote>
<p><strong>等待时间</strong>包括在后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、等待I&#x2F;O操作完成的时间。<strong>作业实际运行的时间</strong>即进程在CPU上执行的时间。<strong>周转时间</strong>是衡量批处理OS性能的重要指标。</p>
</blockquote>
<p><strong>平均周转时间：</strong><code>各作业周转时间之和 / 作业数</code></p>
<p><strong>带权周转时间：</strong><code>周转时间 / 作业实际运行的时间</code>（&gt;&#x3D;1，比周转时间更能衡量一个调度算法的优劣）</p>
<p><strong>平均带权周转时间：</strong><code>各作业带权周转时间之和 / 作业数</code></p>
<h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>面向分时OS</p>
<p><strong>响应时间：</strong>从用户提交请求到首次产生响应所用的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔。包括从键盘输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间、将所形成的响应时间回送到终端显示器的时间。</p>
<h4 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h4><p>面向实时OS</p>
<p><strong>截止时间：</strong>指某任务必须开始执行的最迟时间，或必须完成的最迟时间</p>
<h4 id="优先权准则"><a href="#优先权准则" class="headerlink" title="优先权准则"></a>优先权准则</h4><h3 id="面向系统的准则"><a href="#面向系统的准则" class="headerlink" title="面向系统的准则"></a>面向系统的准则</h3><p><strong>系统吞吐量：</strong><code>完成作业量 / 总时间</code></p>
<p><strong>CPU 利用率：</strong><code>忙碌的时间 / 总时间</code></p>
<p><strong>公平性：</strong>确保每个用户每个进程获得合理的CPU份额，不会出现饿死情况。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS-调度算法（作业调度-进程调度）"><a href="#先来先服务-FCFS-调度算法（作业调度-进程调度）" class="headerlink" title="先来先服务(FCFS)调度算法（作业调度+进程调度）"></a>先来先服务(FCFS)调度算法（作业调度+进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221107_142009.jpg" alt="IMG_20221107_142009"></p>
<blockquote>
<p>周转时间&#x3D;完成时间-到达时间</p>
<p>带权周转时间&#x3D;周转时间&#x2F;服务时间</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221107_143022.jpg" alt="IMG_20221107_143022"></p>
<p>FCFS算法对长作业（CPU时间长的作业）有利，对短作业不利。</p>
<h3 id="最短作业-SJF-调度算法（作业调度-进程调度）"><a href="#最短作业-SJF-调度算法（作业调度-进程调度）" class="headerlink" title="最短作业(SJF)调度算法（作业调度+进程调度）"></a>最短作业(SJF)调度算法（作业调度+进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221107_144647.jpg" alt="IMG_20221107_144647"></p>
<p>对这个情况而言，SJF比FCFS更好，尤其是C。</p>
<p>SJF调度算法也存在不容忽视的缺点：</p>
<ul>
<li>该算法对长作业不利，更严重的是，如果有一长作业（进程）进入系统的后备队列（就绪队列），由于调度程序总是优先调度那些（即使是后进来的）短作业（进程），将导致长作业（进程）长期不被调度。</li>
<li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理。</li>
<li>由于作业（进程）的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li>
</ul>
<h3 id="高响应比优先-HRRN-调度算法（作业调度-进程调度）"><a href="#高响应比优先-HRRN-调度算法（作业调度-进程调度）" class="headerlink" title="高响应比优先(HRRN)调度算法（作业调度+进程调度）"></a>高响应比优先(HRRN)调度算法（作业调度+进程调度）</h3><blockquote>
<p>HRRN (Highest Response Ratio Next) &#x3D; HRRF (Highest Response Ratio First)</p>
<p>NUIST老师习惯用HRRF，我觉得HRRN更合适</p>
</blockquote>
<p>FCFS与SJF是片面的调度算法。FCFS只考虑作业等候时间而忽视了作业的计算时间问题；SJF只考虑用户估计的作业计算时间而忽视了作业等待时间。</p>
<p>HRRN是介乎这两者之间的非剥夺式算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。</p>
<p><strong>响应比</strong>（带权周转时间） &#x3D; 作业周转时间 &#x2F; 作业处理时间 &#x3D; （作业等待时间+作业处理时间） &#x2F; 作业处理时间 &#x3D; <strong>1 + 作业等待时间 &#x2F; 作业处理时间</strong></p>
<ul>
<li>短作业容易得到较高响应比（分母小）</li>
<li>长作业等待时间足够长后，也将获得足够高的响应比（分子足够大）</li>
<li>饥饿现象不会发生</li>
</ul>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221107_150432.jpg" alt="IMG_20221107_150432"></p>
<p>首先调度J1，然后计算响应比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">J2 1+15/15=2</span><br><span class="line">J3 1+10/5=3</span><br><span class="line">J4 1+5/10=1.5</span><br></pre></td></tr></table></figure>

<p>J3的响应比最大，调度J3。随后计算J3完成后的响应比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=20+5</span><br><span class="line">J2 1+20/15=2.3</span><br><span class="line">J4 1+10/10=2</span><br></pre></td></tr></table></figure>

<p>所以调用J2，最后调用J4。</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221107_152959.jpg" alt="IMG_20221107_152959"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FCFS J1 2 3 4</span><br><span class="line">8 10 2 1</span><br><span class="line">10 10.5 1.5+1/6 (1.5+1/6)/0.5=3.3</span><br><span class="line">10.5 10.6 1.6 1.6/0.1=16</span><br><span class="line">10.6 10.8 0.8+2/3 (0.8+2/3)/0.2=7.3</span><br><span class="line">(2+1.5+1/6+1.6+0.8+2/3)/4=1.68</span><br><span class="line">(1+(1.5+1/6)/0.5+1.6/0.1+(0.8+2/3)/0.2)/4=6.92</span><br><span class="line">SJF J1 3 4 2</span><br><span class="line">8 10 2 1</span><br><span class="line">10.3 10.8 1.8+1/6 (1.8+1/6)/0.5=3.93</span><br><span class="line">10 10.1 1.1 1.1/0.1=11</span><br><span class="line">10.1 10.3 0.3+2/3 (0.3+2/3)/0.2=4.83</span><br><span class="line">(2+1.8+1/6+1.1+0.3+2/3)/4=1.51</span><br><span class="line">(1+(1.8+1/6)/0.5+1.1/0.1+(0.3+2/3)/0.2)/4=5.19</span><br><span class="line">HRRF J1 </span><br><span class="line">8 10 2 1</span><br><span class="line">(10) J2 未完成</span><br></pre></td></tr></table></figure>

<h3 id="高优先权-FPF-调度算法（作业调度-进程调度）"><a href="#高优先权-FPF-调度算法（作业调度-进程调度）" class="headerlink" title="高优先权(FPF)调度算法（作业调度+进程调度）"></a>高优先权(FPF)调度算法（作业调度+进程调度）</h3><h4 id="非抢占式优先权算法"><a href="#非抢占式优先权算法" class="headerlink" title="非抢占式优先权算法"></a>非抢占式优先权算法</h4><p>和 HRRN 算法很像，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。</p>
<h4 id="抢占式优先权算法"><a href="#抢占式优先权算法" class="headerlink" title="抢占式优先权算法"></a>抢占式优先权算法</h4><p>除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。</p>
<h4 id="静态优先权"><a href="#静态优先权" class="headerlink" title="静态优先权"></a>静态优先权</h4><p>静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变。一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；I&#x2F;O 型进程优先级会比较高。</p>
<h4 id="动态优先权"><a href="#动态优先权" class="headerlink" title="动态优先权"></a>动态优先权</h4><p>动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直“霸占”处理机了。另外，之前说过 I&#x2F;O 型进程的优先级会很高，所以如果某个进程频繁进行 I&#x2F;O 操作，也可以考虑提高它的优先级。</p>
<p>优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 HRRN 算法也是很像的。（其实也可以把 HRRN 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）</p>
<h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221114_141012.jpg" alt="IMG_20221114_141012"></p>
<p>可剥夺：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间:进程 0:P1 3:P2 5:P3 10:P4 20:P3 21:P1 23:DONE</span><br><span class="line">进程 周转时间 带权周转时间</span><br><span class="line">P1 23-0=23 23/5=4.6</span><br><span class="line">P2 5-3=2 2/2=1</span><br><span class="line">P3 21-5=16 16/6=2.67</span><br><span class="line">P4 20-10=10 10/10=1</span><br><span class="line">平均周转时间：12.75</span><br><span class="line">带权周转时间：2.32</span><br></pre></td></tr></table></figure>

<h3 id="时间片轮转-RR-调度算法（进程调度）"><a href="#时间片轮转-RR-调度算法（进程调度）" class="headerlink" title="时间片轮转(RR)调度算法（进程调度）"></a>时间片轮转(RR)调度算法（进程调度）</h3><p>RR 算法的特点则在于“公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出“交替”的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。</p>
<blockquote>
<p>答题需表格+执行顺序时间线</p>
</blockquote>
<h4 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221114_151836.jpg" alt="IMG_20221114_151836"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间:进程(剩余时间)：0:P1(33) 20:P2(0) 37:P3(48) 57:P4(4) 77:P1(13) 97:P3(28) 117:P4(0) 121:P1(0)  134:P3(8) 154:P3(0) 162:DONE</span><br><span class="line">P1 134 134/50</span><br><span class="line">P2 17 17/17</span><br><span class="line">P3 162 162/68</span><br><span class="line">P4 121 121/24</span><br><span class="line">平均周转时间：108.5</span><br><span class="line">带权平均周转时间：2.78</span><br></pre></td></tr></table></figure>

<h3 id="多级反馈调度算法（进程调度）"><a href="#多级反馈调度算法（进程调度）" class="headerlink" title="多级反馈调度算法（进程调度）"></a>多级反馈调度算法（进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221114_142817.jpg" alt="IMG_20221114_142817"></p>
<ul>
<li>有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾</li>
<li>当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度</li>
<li>关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>对各类型进程相对公平（FCFS 的优点）：谁先进来，谁就会处于高级队列，优先得到服务</li>
<li>每个新到达的进程都可以很快就得到响应（RR 的优点）：新到达的进程首先在高级队列，可以很快得到响应</li>
<li>短进程只用较少的时间就可完成（SPF 的优点）：不需要经历过多的队列</li>
<li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I&#x2F;O 密集型进程（拓展：可以将因 I&#x2F;O 而阻塞的进程重新放回原队列，这样 I&#x2F;O 型进程就可以保持较高优先级）</li>
<li>对各类型用户友好。对于<strong>终端型用户</strong>来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对<strong>短批处理作业用户</strong>来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对<strong>长批处理作业用户</strong>来说，只要让作业依次在第 1, 2，… n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。</li>
</ul>
<h4 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221114_145035.jpg" alt="IMG_20221114_145035"></p>
<blockquote>
<p>D就绪队列2有误</p>
</blockquote>
<h4 id="例题2（只有3个就绪队列的例题1）"><a href="#例题2（只有3个就绪队列的例题1）" class="headerlink" title="例题2（只有3个就绪队列的例题1）"></a>例题2（只有3个就绪队列的例题1）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221114150810280.png" alt="image-20221114150810280"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A 2-0=2 2/2</span><br><span class="line">B 22-2=20 20/6</span><br><span class="line">C 58-4=54 54/10</span><br><span class="line">D 66-6=60 60/14</span><br><span class="line">E 110-8=102 102/18</span><br><span class="line">F 118-10=108 108/22</span><br><span class="line">G 146-12=134 134/26</span><br><span class="line">H 154-14=140 140/30</span><br><span class="line">I 166-16=150 150/34</span><br><span class="line">平均周转时间：85.56</span><br><span class="line">带权平均周转时间：4.31</span><br></pre></td></tr></table></figure>

<p>平均周转时间&#x3D;结束时间-开始时间 ×，平均周转时间&#x3D;结束时间-到达时间 √。若没有给到达时间，则默认所有任务一开始就同时到达。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="出现死锁的场景"><a href="#出现死锁的场景" class="headerlink" title="出现死锁的场景"></a>出现死锁的场景</h3><h4 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221117_102117.jpg" alt="IMG_20221117_102117"></p>
<h4 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221117_102345.jpg" alt="IMG_20221117_102345"></p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。</p>
<h4 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h4><p>一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。</p>
<h4 id="请求和占有"><a href="#请求和占有" class="headerlink" title="请求和占有"></a>请求和占有</h4><p>申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure>

<p>如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。</p>
<p>换一种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure>

<p>如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是<strong>是在不占有资源的情况下阻塞的</strong>，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。</p>
<h4 id="环路循环等待"><a href="#环路循环等待" class="headerlink" title="环路循环等待"></a>环路循环等待</h4><p>要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。</p>
<p>[P0，P1，P2，…Pn]中的P0正在等待P1占用的资源，P1正在等待P2占用的资源……Pn正在等待P0占用的资源。</p>
<p>发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。</p>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低</p>
<h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。</p>
<h4 id="破坏非抢占条件"><a href="#破坏非抢占条件" class="headerlink" title="破坏非抢占条件"></a>破坏非抢占条件</h4><p>如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：</p>
<ul>
<li>从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请</li>
<li>从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。</li>
</ul>
<p>这种做法的问题在于：</p>
<ul>
<li>实现起来复杂</li>
<li>某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失</li>
<li>反复的申请和释放资源会增加系统开销</li>
<li>可能导致饥饿</li>
</ul>
<h4 id="破坏“请求和占有”条件"><a href="#破坏“请求和占有”条件" class="headerlink" title="破坏“请求和占有”条件"></a>破坏“请求和占有”条件</h4><p>所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。</p>
<p>该方法可能导致饥饿现象。若有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，如果 AB 源源不断进入就绪队列，那么 C 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。</p>
<h4 id="破坏“环路循环等待”条件"><a href="#破坏“环路循环等待”条件" class="headerlink" title="破坏“环路循环等待”条件"></a>破坏“环路循环等待”条件</h4><p>将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。</p>
<p>优点：和前两种相比，资源利用率和吞吐量利用率高</p>
<p>缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。</p>
<p>以之前的例子讲解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure>

<p>这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure>

<p>实际上，这里除了破坏“占有和请求条件”之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。</p>
<p>也可以拿之前的<a href="#%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98">哲学家进餐问题</a>解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。</p>
<p>还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。</p>
<blockquote>
<p>但这种预防死锁的方法，问题在于：</p>
<ul>
<li>如何进行编号，从什么角度考虑？</li>
<li>如果增加资源或设备，怎么重新编号？</li>
<li>虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。</li>
</ul>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全状态：指系统按某种顺序(P1,P2,…,Pn)(称&lt;P1,P2,…,Pn&gt;为安全序列)来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
<p>避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p>
<p>安全状态之例：假定系统中有三个进程P1、P2和P3,共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3分别获得5台、2台和2台，尚有3台未分配，如下表所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221117_111227.jpg" alt="IMG_20221117_111227"></p>
<h4 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h4><p>当各类资源都<strong>只有一个</strong>的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118230915805.png" alt="image-20221118230915805"></p>
<ul>
<li>如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。</li>
<li>如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>银行家拥有一笔周转资金</li>
<li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷</li>
<li>银行家应谨慎的贷款，防止出现坏帐</li>
</ul>
<h5 id="银行家算法案例"><a href="#银行家算法案例" class="headerlink" title="银行家算法案例"></a>银行家算法案例</h5><p>设银行家有10万贷款，P,Q,R分别需要8,3,9万元搞项目（假设任何人满足资金总额后都会归还所有贷款)</p>
<p>如果P已申请到了4万：</p>
<ul>
<li>Q要申请2万，显然，如果满足Q的申请，有安全序列&lt;P,Q,R&gt;&#x2F;&lt;Q,P,R&gt;</li>
<li>R要申请4万，显然，如果满足R的申请，则不存在安全序列。</li>
</ul>
<p><strong>基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。</strong></p>
<h5 id="银行家算法过程"><a href="#银行家算法过程" class="headerlink" title="银行家算法过程"></a>银行家算法过程</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118233726331.png" alt="image-20221118233726331"></p>
<p>假设系统中有 n 个进程，m 种资源，规定：</p>
<ul>
<li>每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 <code>Max</code> 表示各个进程的需求情况，比如 <code>Max[i][j]= K</code> 就表示进程 i 需要 K 个 j 类型资源</li>
<li>用一个 n*m 的分配矩阵 <code>Allocation</code> 表示各个进程的已分配资源情况</li>
<li>用一个 n*m 的需求矩阵 <code>Need</code> 表示各个进程的最多还需要资源情况，<code>Need = Max - Allocation</code></li>
<li>用一个 m 长度的一维数组 <code>Avaliable</code> 表示剩余资源数目</li>
<li>用一个 m 长度的申请矩阵 <code>Request[i][j]</code> 表示某个进程 i 某次申请的 j 类型资源数目</li>
</ul>
<p>按照之前说过的流程图，银行家算法的工作过程是：</p>
<ul>
<li>请求资源数是否超过最大资源数？<code>Request[i][j]&lt;=Need[i][j]</code>，则到下一步；否则出错</li>
<li>请求资源数是否超过剩余资源数？<code>Request[i][j]&lt;=Available[j]</code>，则到下一步；否则说明资源不够，进程等待</li>
<li>尝试进行资源分配。<ul>
<li>剩余资源减少：<code>Available = Available - Request</code></li>
<li>已分配资源增加：<code>Allocation[i][j] = Allocation[i][j] + Request[i][j]</code></li>
<li>需求资源减少：<code>Need[i][j] = Need[i][j] - Request[i][j]</code></li>
</ul>
</li>
<li>对分配后的状态通过安全性算法进行预判：<ul>
<li>安全状态：不会发生死锁，可以分配资源</li>
<li>不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态</li>
</ul>
</li>
</ul>
<h5 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1"></a>例题1</h5><p>假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118232822744.png" alt="image-20221118232822744"></p>
<p>如何检测当前是否处于安全状态呢？尝试寻找安全序列：</p>
<ul>
<li>当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。</li>
<li>P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）&#x3D;（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列。</li>
<li>所以存在安全序列 <code>P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4</code> ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。</li>
</ul>
<p>看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221118232808706.png" alt="image-20221118232808706"></p>
<p>当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。</p>
<h5 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h5><p>t0时刻安全状态检查。如果t0时刻都不安全，则后面的部分都不用做了。但是考试时t0都是安全的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221117_114149.jpg" alt="IMG_20221117_114149"></p>
<p>安全序列之一：&lt;p1,p3,p4,p2,p0&gt;</p>
<h5 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h5><p>在银行家算法中，若出现下述资源分配情况，试问：</p>
<table>
<thead>
<tr>
<th align="center">Process</th>
<th align="center">Allocation</th>
<th align="center">Need</th>
<th align="center">Available</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P0</td>
<td align="center">0032</td>
<td align="center">0012</td>
<td align="center">1622</td>
</tr>
<tr>
<td align="center">P1</td>
<td align="center">1000</td>
<td align="center">1750</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P2</td>
<td align="center">1354</td>
<td align="center">2356</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P3</td>
<td align="center">0332</td>
<td align="center">0652</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P4</td>
<td align="center">0014</td>
<td align="center">0656</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>(1) 该状态是否安全？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P0 1622+0032=1654</span><br><span class="line">P3 1654+0332=1986</span><br><span class="line">P1 1986+1000=2986</span><br><span class="line">P4 2986+0014=299 10</span><br><span class="line">P2 299 10+1354=3 12 14 14</span><br><span class="line">故存在安全序列P0 P3 P1 P4 P2</span><br></pre></td></tr></table></figure>

<p>(2) 若进程P2提出请求 Request(1,2,2,2) 后，系统能否将资源分配给它？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P2的Allocation加上1 2 2 2为2 5 7 6，Need变为1 1 3 4， Available变为0 4 0 0</span><br><span class="line">由(1)可知，此时系统资源无法满足任何一个进程，安全性检查不通过，无法分配资源</span><br></pre></td></tr></table></figure>

<h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><h4 id="简化进程-资源分配图"><a href="#简化进程-资源分配图" class="headerlink" title="简化进程-资源分配图"></a>简化进程-资源分配图</h4><h5 id="各类资源只有一个"><a href="#各类资源只有一个" class="headerlink" title="各类资源只有一个"></a>各类资源只有一个</h5><p>当各类资源只有一个的时候，可以把<a href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE">资源分配图</a>化简为一个等待图（wait-for graph），比如说 A 进程请求 X 资源、X 资源被 B 进程占有，这个过程可以被简化为 A 进程等待 B 进程。比如说下面，左图被转化为对应的右图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221119185911023.png" alt="image-20221119185911023"></p>
<p><strong>死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。</strong></p>
<ul>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li>
<li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。</li>
<li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。</li>
</ul>
<h5 id="各类资源有多个"><a href="#各类资源有多个" class="headerlink" title="各类资源有多个"></a>各类资源有多个</h5><p>各类资源有多个的时候，我们可能需要根据给定表或给定图检测是否有死锁。对于前者，可以沿用<a href="#%E4%BE%8B%E9%A2%981-5">之前的安全性算法</a>进行检测；对于后者，可以尝试简化资源分配图。</p>
<p>给定一个资源分配图为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221119205915983.png" alt="image-20221119205915983"></p>
<p>约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 P1 占有两个 R1 资源，请求一个 R2 资源；P2 占有一个 R2 资源，一个 R1 资源，请求一个 R1 资源。</p>
<ul>
<li>首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是<strong>进程请求的资源数量足够</strong>，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，有多余资源，P1 是非阻塞的。这样就找到了符合条件的进程点 P1</li>
<li>去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点</li>
<li>重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除</li>
<li>由于图中所有的边都能被消除，所以称该图<strong>可以被简化</strong>，因此它不存在死锁（如果不可简化，则存在死锁）</li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221117_105216.jpg" alt="IMG_20221117_105216"></p>
</blockquote>
<p>又比如下面这种情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221119225907074.png" alt="image-20221119225907074"></p>
<p>首先还是找一个非孤立非阻塞的点，很显然只有 P3 符合要求。之后把 P3 的分配边去掉，会发现 P1 和 P2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。</p>
<h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><h4 id="资源剥夺法"><a href="#资源剥夺法" class="headerlink" title="资源剥夺法"></a>资源剥夺法</h4><p>将部分死锁的进程挂起并抢占它的资源，将这些资源分配给其它的死锁进程。但应防止被挂起的进程长时间得不到资源而饥饿。</p>
<blockquote>
<p>注意不是抢占非死锁进程的资源。</p>
</blockquote>
<h4 id="终止进程法"><a href="#终止进程法" class="headerlink" title="终止进程法"></a>终止进程法</h4><p>强制终止部分或全部死锁进程，并剥夺它们的资源。这种方式的优点是实现简单，但可能付出很大的代价。因为有些进程可能已经运行了很长时间，一旦被终止就功亏一篑了。</p>
<h4 id="进程回退法"><a href="#进程回退法" class="headerlink" title="进程回退法"></a>进程回退法</h4><p>让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。</p>
<blockquote>
<p>无论是哪种方法，都可以从以下角度考虑需要做出牺牲的进程：</p>
<ul>
<li>优先级比较低的进程做出牺牲</li>
<li>占用过多资源的进程做出牺牲</li>
<li>执行时间长的进程不做出牺牲</li>
<li>快要完成的进程不做出牺牲</li>
<li>交互式进程不做出牺牲</li>
</ul>
</blockquote>
<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="多级存储器结构"><a href="#多级存储器结构" class="headerlink" title="多级存储器结构"></a>多级存储器结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221121_145003.jpg" alt="IMG_20221121_145003"></p>
<h2 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221121_145937.jpg" alt="IMG_20221121_145937"></p>
<p>用户程序在执行前必须先进入内存，具体来说包括以下步骤：</p>
<ul>
<li>编译：由编译程序将用户源程序编译成多个目标模块</li>
<li>链接：由链接程序将编译后的多个目标模块和所需的库函数链接在一起，形成一个总的装入模块</li>
<li>装入：由装入程序将装入模块装入内存运行</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>根据链接的时间不同进行区分</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>直接将编译后的多个目标模块和所需的库函数链接在一起，形成一个不再拆开的装入模块，该模块整体装入内存。</p>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>不事先进行链接，而是一边装入内存，一边进行链接，即在装入一个目标模块时，若发生一个外部模块调用事件，装入程序就去找出相应的外部目标模块。这种方式便于修改和更新，便于实现对目标模块的共享。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221121_151005.jpg" alt="IMG_20221121_151005"></p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>不事先进行链接，而是一边执行程序，一边进行模块的装入和链接，这种方式可以确保只装入和链接那些在执行时需要用到的模块，而不会引入多余的、实际根本用不到的模块，因此拥有装入时动态链接的优点，还加快了程序的装入过程，有利于节省内存空间。</p>
<h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>装入模块中指令所涉及的地址是逻辑地址（相对地址），往往并不是装入内存后的物理地址，因此在装入模块装入内存后，需要将原先的逻辑地址转换成物理地址（绝对地址）。在下面三种装入方式中，对逻辑地址的处理是不同的。</p>
<h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>程序员如果事先知道程序最终装入内存时的物理地址（如在单道程序运行环境中），那么编译程序产生的目标模块中可以直接使用物理地址，此时的逻辑地址与物理地址一样，模块在装入到内存的时候也无需进行地址转换的工作。</p>
<h4 id="静态重定位装入方式"><a href="#静态重定位装入方式" class="headerlink" title="静态重定位装入方式"></a>静态重定位装入方式</h4><p>在多道程序运行环境中，无法事先知道程序最终装入内存时的物理地址，所以目标模块中只能使用逻辑地址，所有指令中涉及到的逻辑地址都是从 0 开始的。装入模块可以装入到内存的合适位置，并且<strong>在装入的时候</strong>会进行地址转换（重定位）的工作。例如将程序中起始于 0 的逻辑地址都转换为起始于 10000 的物理地址。</p>
<p>“静态”主要体现在程序装入内存后，在运行期间就不能再移动了，因为一旦移动就意味着需要再次更改物理地址，而地址是无法修改的，否则会发生错误。</p>
<h4 id="动态重定位装入方式"><a href="#动态重定位装入方式" class="headerlink" title="动态重定位装入方式"></a>动态重定位装入方式</h4><p>很多时候，程序在内存中的位置会经常发生改变，比如在外存和内存之间对换。位置不会是一成不变的，这时候就要采用动态重定位装入方式。这种方式并不急于在装入的时候就进行地址转换，而是在程序真正执行的时候才去进行地址转换的工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221121_152806.jpg" alt="IMG_20221121_152806"></p>
<p>这意味着程序在装入内存后，在运行期间是可以移动的。因为不管移动到哪个内存位置，始终会有一个重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地址。</p>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="外部碎片和内部碎片"><a href="#外部碎片和内部碎片" class="headerlink" title="外部碎片和内部碎片"></a>外部碎片和内部碎片</h3><ul>
<li>外部碎片指的是尚未分配出去、由于太小而无法分配出去的内存空间（化整为零）</li>
<li>内部碎片指的是已经分配出去、但没有完全得到利用的内存空间</li>
</ul>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>单一连续分配只适用于单用户、单任务的操作系统中，它会把整个内存区划分为系统区和用户区，一道用户程序就会独占整个用户区，因此存储器的利用率非常低、内部碎片很大（分配了整个用户区，但实际用到的空间并不多）。</p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区分配是最简单的多道程序的存储管理方式，依然是将整个内存区划分为系统区和用户区，但是用户区进一步细分：划分为<strong>多个固定大小</strong>的分区，系统启动后就已经分好了分区，一个分区放一个进程。</p>
<p>每个分区的大小可以相等也可以不等：</p>
<ul>
<li><p>如果每个分区大小相等，缺乏灵活性：对于小进程，无法利用全部空间而产生内部碎片；对于大进程，找不到大小足够的分区。</p>
</li>
<li><p>如果每个分区的大小不等，提高了灵活度，可以将用户区划分为大量的小分区、适量的中分区、少量的大分区，并维护一张记录了分区号、分区大小、分区起始地址、分区分配状态的分区使用表。每次需要为进程分配内存空间的时候，先在这张表上进行检索，找到一个合适的分区分配给它。</p>
<p>这种划分方式可以认为不存在过小的、分配不出去的内存空间，不会产生外部碎片；但是，由于提前划分了分区，不能保证一个进程完全利用完某个分区，分区会产生内部碎片：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221128_140141.jpg" alt="IMG_20221128_140141"></p>
<blockquote>
<p>浪费了7+23+87+211K&#x3D;328K的空间</p>
</blockquote>
</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><p>动态分区分配方式比前面的分配方式要灵活很多，类似于按需分配，不是预先划分好，而是进程需要多少内存空间，就给它多少内存空间。</p>
<p>但这种分配方式需要考虑的问题是，当一个进程有多个空闲的内存分区可供选择的时候，它应该使用哪个空间呢？比如进程 2 运行完释放了 20K 的内存空间，此时进程 4 进来，也需要用到 20K 的内存空间，它既可以选择占用进程 2 释放的空间，也可以选择占用后面没被用到的一大片空间。</p>
<p>因此，我们需要一种算法来决定进程 4 的选择，而且为了更好地描述内存使用情况，我们同样要像固定分区分配一样维护一张空闲分区表或者一个空闲分区链。</p>
<h4 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h4><p>假设进程 X 需要用到 x 大小的内存空间，在某种算法下，系统会检索空闲分区表或者空闲分区链，决定将某个空闲分区分配给这个进程。假设这个空闲分区大小为 y（y&gt;x），若 <code>y-x</code> 的值小于预先设定的一个阈值，说明进程可以充分利用这个空闲分区，可以将整个分区直接分配给进程；若 <code>y-x</code> 的值大于这个阈值，说明空闲分区无法得到完全的利用，可以将整个分区能够被充分利用的那部分（也即 x）划分给进程，而剩下的 <code>y-x</code> 则继续留在空闲分区表（因为只记录空闲分区，所以没有“状态”项）或者空闲分区链（不讲不考察）中。</p>
<h4 id="基于顺序搜索的算法"><a href="#基于顺序搜索的算法" class="headerlink" title="基于顺序搜索的算法"></a>基于顺序搜索的算法</h4><h5 id="首次适应（FF）"><a href="#首次适应（FF）" class="headerlink" title="首次适应（FF）"></a>首次适应（FF）</h5><p>将多个空闲分区按照地址递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p>
<ul>
<li>由于地址一开始就是确定下来的，能够保证顺序始终是递增的，因此这种算法无需频繁地变更空闲分区的顺序，而且每次优先利用低地址空间，保证了高地址空间有足够大的空闲区域可供大进程使用。</li>
<li>但是，因为每次优先利用低地址空间，所以低地址空间被不断分割，产生了大量的外部碎片；而且，每次都是从头开始寻找空闲空间，效率并不高。</li>
</ul>
<h5 id="邻近适应（NF）"><a href="#邻近适应（NF）" class="headerlink" title="邻近适应（NF）"></a>邻近适应（NF）</h5><p>邻近适应算法（循环首次适应算法）克服了首次适应算法的缺点，它同样是将多个空闲分区按照地址递增的顺序排列，不同的是，每次查找都是从上次查找结束的位置开始查找的</p>
<ul>
<li><p>不会从头开始一个个找，一定程度上提高了效率；而且，它会更趋向于往后推进，避免了对低地址空间重复地进行分割，进而避免了大量外部碎片的产生。</p>
</li>
<li><p>优点同时也是缺点，由于邻近适应算法更趋向于往后推进，所以更可能分割高地址空间，这就破坏了首次适应算法的初衷，导致大进程可能没有足够的空闲空间可利用。</p>
</li>
</ul>
<h5 id="最佳适应（BF）"><a href="#最佳适应（BF）" class="headerlink" title="最佳适应（BF）"></a>最佳适应（BF）</h5><p>连续分配的方式规定，为各个进程分配的必须是一块连续的空间，因此对于一块内存空间来说，若它不断被分割，则意味着它能容纳下大进程的可能性越低。为了保证有足够的内存空间可以容纳大进程，基本思想应该是优先利用小的空闲分区，而保留大的空闲分区。</p>
<p>最佳适应算法将空闲分区按照容量递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p>
<ul>
<li>分配操作主要集中在小的空闲分区那里进行，保证了有大的空闲分区可以用来容纳大进程。</li>
<li>因为要按照容量递增的顺序排列，而每次内存的分配和回收都会改变某一块空间的大小，每次在进行分配和回收的时候，基本都要重新进行排序，算法开销大。而且，由于分配操作集中在小的空闲分区进行，导致它们不断被分割，容易产生大量外部碎片。</li>
</ul>
<h5 id="最坏适应-（WF）"><a href="#最坏适应-（WF）" class="headerlink" title="最坏适应 （WF）"></a>最坏适应 （WF）</h5><p>为了克服最佳适应算法的缺点，最坏适应算法规定，将空闲分区按照容量递减的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p>
<ul>
<li>最坏适应算法优先使用大的空闲分区，而大的空闲分区由于容量充足，即使被不断分割，也可以保证剩余空间不至于太小，依然能够被新的进程利用，大幅度减少了外部碎片的产生。</li>
<li>但是，这又破坏了最佳适应算法的初衷，因为优先使用大的空闲分区，很容易导致后续的大进程没有足够大小的空闲分区可以利用。并且，这种算法也无法避免分配和回收之后的重新排序。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128135433747.png" alt="image-20221128135433747"></p>
<p>由于动态分区分配不是事先划分好区域，而是“按需分配”，所以不会出现区域划分出去后无法完全得到利用的情况，也即不会产生内部碎片；但是可能出现内存空间太小而无法被分配出去的情况，也即可能产生外部碎片。</p>
<h4 id="基于索引搜索的算法"><a href="#基于索引搜索的算法" class="headerlink" title="基于索引搜索的算法"></a>基于索引搜索的算法</h4><p>当系统很大的时候，内存分区会很多，这时候还采取基于顺序搜索的动态分区分配算法的话，效率并不高。因此出现了基于索引搜索的动态分区分配算法。</p>
<h5 id="快速适应"><a href="#快速适应" class="headerlink" title="快速适应"></a>快速适应</h5><p>快速适应算法（分类搜索算法）将空闲分区按照进程常用的空间大小进行分类，比如 2KB 为一类，4KB 为一类，6KB 为一类等，对于每一类空闲分区，会有一个单独的空闲分区链表。此外，还会有一张总的管理索引表，索引表的每一个表项对应了一类空闲分区。</p>
<p>在为进程分配分区的时候，首先会根据进程长度，从索引表中找到能容纳它的最小空闲区链表，接着将该链表的第一块分配给进程。</p>
<ul>
<li>因为前面已经进行了合理的分类，因此这种方法不会对任何分区产生分割，也不会产生外部或者内部碎片，并且查找效率很高</li>
<li>但是，回收、合并分区时的算法复杂，系统开销比较大</li>
</ul>
<h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><blockquote>
<p>接下来的伙伴关系和哈希算法为自学内容</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128144121955.png" alt="image-20221128144121955"></p>
<p>举个例子</p>
<p>假设系统总的内存为 512KB，现有进程活动如下：</p>
<ul>
<li>进程 A 请求 100KB，进程 B 请求 50KB，进程 C 请求 100KB</li>
<li>进程 A 释放 100KB</li>
<li>进程 D 请求 20KB</li>
<li>进程 D 释放 20KB</li>
<li>进程 B 释放 50KB</li>
</ul>
<p>按照伙伴系统的算法，内存的分配和回收是怎么进行的呢？</p>
<p>首先，一开始肯定是整片空的内存空间，进程 A 请求 100KB，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^&#x3D;128 的空闲分区，当然是没有的（目前只有 512KB)，所以寻找是否有 2^8^&#x3D;256 的空闲分区，也没有，所以寻找是否有 2^9^&#x3D;512 的空闲分区，找到了，此时就把 512KB 一分为二：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128145950590.png" alt="image-20221128145950590"></p>
<p>一半的 256KB 加入到对应的空闲分区链表，一半的 256KB 用于分配，对这一半继续一分为二：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128145955549.png" alt="image-20221128145955549"></p>
<p>一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 A 来说足够了，于是占用它：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150408463.png" alt="image-20221128150408463"></p>
<p>进程 B 请求 50KB，因为 32&lt;50&lt;64，即 2^5^&lt;100&lt;2^6^，所以寻找是否有 2^6^&#x3D;64 的空闲分区，没有，所以寻找是否有 2^7^&#x3D;128，找到了，此时就把 128KB 一分为二：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150443884.png" alt="image-20221128150443884"></p>
<p>一半的 64KB 加入到对应的空闲分区链表，一半的 64KB 用于分配，这一半对进程 B 来说足够了，于是占用它：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150503276.png" alt="image-20221128150503276"></p>
<p>进程 C 请求 100KB，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^&#x3D;128 的空闲分区，没有，所以寻找是否有 2^8^&#x3D;256 的空闲分区，找到了，此时就把 256KB 一分为二：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150518634.png" alt="image-20221128150518634"></p>
<p>一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 C 来说足够了，于是占用它：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150534743.png" alt="image-20221128150534743"></p>
<p>进程 A 释放 100KB：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150557810.png" alt="image-20221128150557810"></p>
<p>进程 D 请求 20KB，因为 16&lt;20&lt;32，即 2^4^&lt;100&lt;2^5^，所以寻找是否有 2^5^&#x3D;32 的空闲分区，没有，所以寻找是否有 2^6^&#x3D;64 的空闲分区，找到了，此时就把 64KB 一分为二：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150616809.png" alt="image-20221128150616809"></p>
<p>一半的 32KB 加入到对应的空闲分区链表，一半的 32KB 用于分配，这一半对进程 D 来说足够了，于是占用它：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150637464.png" alt="image-20221128150637464"></p>
<p>进程 D 释放 20KB，回收 32KB，由于事先已经有一个 32KB，所以此时两个互为伙伴的 32KB 进行合并：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150655001.png" alt="image-20221128150655001"></p>
<p>进程 B 释放 50KB，回收 64KB，由于事先已经有一个 64KB，所以此时两个互为伙伴的 64KB 进行合并，形成 128KB，由于事先已经有一个 128KB，所以此时两个互为伙伴的 128KB 进行合并，形成 256KB：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150726683.png" alt="image-20221128150726683"></p>
<p><strong>计算伙伴地址的方法</strong>：对于给定的内存块，若它的大小为 2^k^，起始地址为 x，</p>
<ul>
<li>如果 <code>x/2^k</code> 为奇数，则伙伴地址为 <code>x - 2^k</code></li>
<li>如果 <code>x/2^k</code> 为偶数，则伙伴地址为 <code>x + 2^k</code></li>
</ul>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>快速适应和伙伴系统都是将空闲分区按照大小进行分类，并为每一类建立一个独立的空闲分区链表，再用一个总的索引表进行记录。不过，如果分类过多，则索引表的表项也会过多，这时候搜索索引表的<strong>时间开销</strong>就会比较大。</p>
<p>因此，哈希算法选择建立一张哈希表（而不是普通的索引表），这张哈希表以空闲分区大小作为关键字，每次需要进行分配的时候，会根据所需空闲分区的大小，通过哈希函数<strong>快速计算得到</strong>该空闲分区在表中的位置，从而得到对应的空闲分区链表。</p>
<h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><p><strong>动态可重定位分区分配算法</strong>与<strong>动态分区分配算法</strong>基本一致，仅仅增加了<strong>紧凑</strong>功能。</p>
<p>连续分配为某个进程分配的必须是一块连续的空间，若多个空闲分区不是相邻的，即便它们的大小总和已经满足进程的需求，也无法进行分配。采用紧凑技术解决这个问题。紧凑技术把内存中各个进程进行移动并使其相邻，从而化零为整，带来了更大的空闲分区：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128150124939.png" alt="image-20221128150124939"></p>
<p>在这里会发现，每次发生紧凑，各个程序和数据的物理地址就要发生改变。</p>
<ul>
<li>假定我们先前采用的是静态重定位装入方式，那么在模块装入内存的时候，就已经把逻辑地址转换为物理地址了，每次发生紧凑，都要在程序上重新修改一次物理地址。</li>
<li>如果我们采用动态重定位装入方式，各个程序和数据的地址全部都是逻辑地址，当程序需要访问地址时，无需修改程序上的地址，只需要<strong>将该逻辑地址与当前重定位寄存器里存放的物理起始地址进行相加</strong>。每次发生紧凑时，也只需要用紧凑后的新起始地址去替换重定位寄存器里的旧起始地址。</li>
</ul>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><p>固定分区分配容易产生内部碎片，动态分区分配容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。</p>
<h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小 <code>X</code> 分割为多个部分，同时把内存也按照固定大小 <code>X</code> 分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于 <code>X</code>，这部分若放到内存的某个 <code>X</code> 空间中，仍然会产生碎片（这种碎片称为页内碎片）。</p>
<h4 id="页面、页框"><a href="#页面、页框" class="headerlink" title="页面、页框"></a>页面、页框</h4><ul>
<li><p>页框(Page Frame)：具体来说，把内存分割为多个固定大小 <code>X</code> 的部分，这些部分就叫做页框 &#x2F; 页帧 &#x2F; 物理块 &#x2F; 内存块，每个页框会有一个数字编号，第一个页框就从 0 开始</p>
</li>
<li><p>页面(Page)：同样，进程被分割为多个固定大小 <code>X</code> 的部分，这些部分就叫做页面 &#x2F; 页，每个页面会有一个数字编号，第一个页面就从 0 开始</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128191916596.png" alt="image-20221128191916596"></p>
<p>若页面太小，虽然可使页内碎片减小、提高内存利用率，但是会使页表过长、降低页面换进换出的效率；若页面太大，则相反。因此页面的大小应是2的整数幂，通常为1KB~8KB。</p>
<p>系统以页框为单位为各个进程分配内存空间，一个页面就对应一个页框，它具体放到哪个页框是随意的，无需顾虑是否连续和先后顺序。</p>
<h4 id="地址转换的思路"><a href="#地址转换的思路" class="headerlink" title="地址转换的思路"></a>地址转换的思路</h4><p>假设我们采用动态重定位方式进行模块装入，程序中是逻辑地址，但在程序执行到需要访问地址的时候，需要进行逻辑地址到物理地址的转换。</p>
<h5 id="十进制地址"><a href="#十进制地址" class="headerlink" title="十进制地址"></a>十进制地址</h5><p>左边进程按照 50B 的大小分为 4 个页面，右边内存按照 50B 的大小分为若干个页框：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192409450.png" alt="image-20221128192409450"></p>
<p>在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：</p>
<ul>
<li>计算逻辑地址的页号</li>
<li>根据页号找到页号对应页面在内存中的<strong>起始地址</strong></li>
<li>计算逻辑地址在当前页面内的偏移量（<strong>页内偏移量</strong>）</li>
<li><code>物理地址 = 起始地址 + 页内偏移量</code></li>
</ul>
<p>从左图可以看出，逻辑地址 80 在 1 号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 <strong>在 1 号页面内的偏移量</strong>为 30；所以<code>物理地址 = 450 + 30 = 480</code></p>
<p>也可以用计算的方法，在已知逻辑地址的情况下：</p>
<ul>
<li><code>页号 = 逻辑地址 / 页面大小</code>，即<code>80/50 = 1</code>（取整数部分）</li>
<li><code>页内偏移量 = 逻辑地址 % 页面大小</code>，即<code>80%50 = 30</code></li>
</ul>
<h5 id="二进制地址"><a href="#二进制地址" class="headerlink" title="二进制地址"></a>二进制地址</h5><p>地址实际上是用 32 位二进制数表示的。这时候计算页号 P 和页内偏移量 W 实际上更加简单，因为地址本身已经包含了这两者的信息。</p>
<p>以页面&#x2F;页框大小 4KB 为例，用地址的前 20 位（红色部分，也叫高 20 位）表示页号 P，用地址的后 12 位（黑色部分，也叫低 12 位）表示页内偏移量 W。页内偏移量的位数可以表明每个页面的大小，即 2^12^ &#x3D; 4KB。0 号页、1 号页、2 号页的表示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192830159.png" alt="image-20221128192830159"></p>
<p>若页面&#x2F;页框大小为 1KB，也即 2^10^B &#x3D; 1024B，那么地址的前 22 位表示页号，剩余的 10 位表示页内偏移量：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192842511.png" alt="image-20221128192842511"></p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221201_110859.jpg" alt="IMG_20221201_110859"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221201_111601.jpg" alt="IMG_20221201_111601"></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>根据地址，就已经可以知道页号和页内偏移量，还有一个工作是<strong>根据页号找到对应页面在内存中的物理地址</strong>。</p>
<p>每一个进程都有一张页表来记录页面号（页号）与页框号（块号）的映射关系，可以根据页号找到内存中对应页框的编号。其中页号是隐含的，相当于从0开始的下标，不占存储空间，页表实际只保存了块号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192853911.png" alt="image-20221128192853911"></p>
<p>根据地址知道页号后，从页表中找出页号对应的块号，再用<code>块号 * 页框大小</code>，即可算出块的<strong>起始地址</strong>。用<code>起始地址 + 偏移量</code>，即可算出物理地址。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><p>上述的地址转换是通过<strong>基本地址变换机构</strong>这个硬件实现的，它借助页表将逻辑地址转换为物理地址。转换过程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192904519.png" alt="image-20221128192904519"></p>
<p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：</p>
<ul>
<li>首先将逻辑地址 A 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，因为页号从 0 开始计算）页表长度的，如果页号越界就会发生越界中断。</li>
<li>由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表在内存中连续分配的起始地址（假设为 X），所以页号 P 对应的页表项的存放地址等于 <code>X + P*size</code>，在这个地址保存着页号对应的块号</li>
<li>将块号与偏移量的二进制数<strong>拼接</strong>，就得到了物理地址，得以访问目标</li>
</ul>
<p>例子中涉及到的都是二进制数，要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可。如果例子给出的是十进制数，则应用 <code>块起始地址 + 页内偏移量</code> 进行<strong>相加</strong>，计算结果再转化为二进制数。</p>
<h5 id="例题1-5"><a href="#例题1-5" class="headerlink" title="例题1"></a>例题1</h5><p>若给定的是十进制：</p>
<blockquote>
<p>页面大小 1KB，块号 2，偏移量 1023。</p>
</blockquote>
<p>块起始地址等于 <code>2 * 1KB = 2 * 1024B = 2048B</code>，又偏移量 1023，所以物理地址等于 <code>2048 + 1023 = 3071</code>，转化为 32 位二进制数，就是 <code>0000000000000000000010,1111111111</code></p>
<p>若给定的是二进制：</p>
<blockquote>
<p>页面大小 1KB，块号 2，偏移量 1111111111。</p>
</blockquote>
<p>块号 2 转化为 22 位二进制数就是 <code>0000000000000000000010</code>，与偏移量拼接，就得到 <code>0000000000000000000010,1111111111</code>，与十进制的结果是一样的。</p>
<h5 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><p>在前面的基本地址变换机构中，存在两个问题：</p>
<ul>
<li>每次存取数据都需要<strong>访问内存两次</strong>：第一次访问内存中的页表，找到块号，并将块号与偏移量拼接得到物理地址；第二次根据物理地址访问内存中存放的数据。第二次访存肯定是不能避免的，但是第一次访存可以想办法避免</li>
<li>若多条指令涉及到的逻辑地址的页号都相同，就都必须经历第一次访存，找到该页号对应的块号</li>
</ul>
<p>这两个问题可以通过引入快表来解决。</p>
<p>快表（联想寄存器）是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程。引入快表后，地址转换大概率<strong>不需要经历第一次访存</strong>，而是直接从快表中拿到需要的页表项。于是内存中原本的页表被称为慢表。</p>
<p>此时的地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192914850.png" alt="image-20221128192914850"></p>
<p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：</p>
<ul>
<li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li>
<li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为这里我们是第一次查询，所以是没有的，即<strong>未命中</strong>，页号被送往慢表。</li>
<li>第一次访存，在慢表中找到页号对应的页表项的地址，意味着找到了页号对应的块号</li>
<li>将该页表项拷贝一份副本放到快表中</li>
<li>将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标</li>
</ul>
<p>我们需要继续访问某个地址，并且与上次访问的地址的页号一样：</p>
<ul>
<li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li>
<li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为快表中已经存放了一份页表项的副本，所以找到了匹配的页号，即<strong>命中</strong>。</li>
<li>从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址，得以访问目标</li>
</ul>
<h5 id="例题2-2"><a href="#例题2-2" class="headerlink" title="例题2"></a>例题2</h5><blockquote>
<p>某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。</p>
</blockquote>
<ul>
<li><p>若未引入快表，则访问一个逻辑地址耗时 <code>100 + 100 = 200us</code></p>
</li>
<li><p>若引入快表，则访问一个逻辑地址耗时 <code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code></p>
</li>
<li><p>若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时 <code>(1+100) * 0.9 + (100+100) * 0.1 = 110.9us</code></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/IMG_20221201_112527.jpg" alt="IMG_20221201_112527"></p>
<h4 id="页表项的大小"><a href="#页表项的大小" class="headerlink" title="页表项的大小"></a>页表项的大小</h4><blockquote>
<p>假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p>
</blockquote>
<p>一条页表项的大小取决于块号的位数。的4GB&#x3D;2^32^B， 4KB&#x3D;2^12^B，因此 4GB 的内存总共会被分为 2^32^&#x2F;2^12^ &#x3D; 2^20^ 个内存块，因此内存块号的范围应该是 0～2^20^-1。因此对于单个页表项，它要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要 3B 才可以表示这样的一个内存块号。</p>
<p>但是一个页表项用 3 个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面&#x2F;页框大小为 4KB，也即 4096B，由于一个页表项 3B，所以一个页框至多可以放 4096&#x2F;3&#x3D;1365 个页表项，并且这个页框剩余 1B 的空间。由于 1B 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。</p>
<p>这就会导致，前面 1365 个页表项的地址依然可以采用 <code>X + 3*P</code> 的方式计算，但是第 1366 个页表项，它的地址却应该是 <code>X + 3*P + 1</code>，也就是说，我们无法以一个通用的式子去计算页表项的存放地址。</p>
<p>因此，一个页表项的大小通常应选取 2 的整数幂。如果页表项大小为 4B，那么一个页框就刚好可以放 4096&#x2F;4&#x3D;1024 个页表项，余下的页表项可以依次放在下一个页框中。这样，涉及到页表项地址的计算都可以用通用的式子 <code>X + 4*P</code>，就无需考虑<strong>由于页框无法得到完全利用</strong>而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该<strong>连续地存放在内存块</strong>中，中间不出现断节。</p>
<blockquote>
<p><strong>Q:</strong> 首先，在 <a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">页表项的大小</a> 中，按照您的讲述，第 1366 个页表项的地址应为 <code>X + 3*(P+1)</code>。另外，我对“一个页表项的大小应同样选取 2 的整数幂”的说法抱有疑问，因为“一个页框能否在没有剩余空间的情况下装入足够多的页表项”并不会影响到“利用页号在页表中找到对应的块号”。即使页表项大小为 3B 时，第 1366 个页表项会被装入下一个页框，但是当页表项大小为 4B 时，第 4097 个页表项也同样会被装入下一个页框，不是吗？请问您是怎么理解的呢？</p>
<p><strong>A:</strong> 页表项的地址≠块号，页表项的存放地址的数据内容才是块号。同样的，块号≠内存块的物理地址，块号是内存块在内存中组织顺序的索引，<code>块号 * 页框大小</code>才等于内存块的起始物理地址。</p>
<p>问题不在于“如何从已经找到地址的页表项中读取块号”，而在于“如何根据隐含的页号找到页表项的存放地址”。<strong>页号是隐含的</strong>，页表中并没有储存页号，我们无法根据页号直接读取到页表项存储的块号，必须先根据<code>X + P*size</code>这个式子来<a href="#%E9%A1%B5%E8%A1%A8">确定页表项的存放地址</a>。页表项大小为 3B 时，第 1365 个页表项和第 1366 个页表项之间间隔了未分配的 1B，先前<code>X + 3*P</code>的寻址规律就被打破了。<code>X + 3*P + 1</code>中的<code>+1</code>是前一个页框剩余的 1B，而不是“下一个页框”的意思。</p>
</blockquote>
<h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><h5 id="单级页表占用过大的连续内存空间的问题"><a href="#单级页表占用过大的连续内存空间的问题" class="headerlink" title="单级页表占用过大的连续内存空间的问题"></a>单级页表占用过大的连续内存空间的问题</h5><p>假设页面&#x2F;页框大小 4KB，页表项大小 4B，一个页表占用的空间：</p>
<ul>
<li>计算页表一共有多少个页表项：4KB &#x3D; 2^12^B，所以 32 位逻辑地址中，后 12 位表示偏移量，前 20 位表示页号。总共有 2^20^ 个页面，也就是有 2^20^ 个页表项需要存放。</li>
<li>计算一个页框可以放多少个页表项：一个页框 4KB，一个页表项 4B，所以一个页框可以放 4096&#x2F;4 &#x3D; 1024 个页表项</li>
<li>计算存放所有页表项需要多少个页框：2^20^&#x2F;1024 &#x3D; 1024</li>
</ul>
<p>需要 1024 个页框才能放下整个页表，而且为了以通用的式子计算页表项地址，页表必须是连续存放的，这违背了分页存储的初衷。</p>
<h5 id="引入两级页表"><a href="#引入两级页表" class="headerlink" title="引入两级页表"></a>引入两级页表</h5><p>就像进程拆分为多个页面一样，页表也可以进行拆分：将长的单级页表分为多个子页表，再将每每个子页表离散地存放到各个内存块中。在<a href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98">之前的例子</a>中，一个页框可以放 1024 个页表项，那么每 1024 个页表项就拆分出一个子页表，因为页表一共有 2^20^ 个页表项，所以一共可以拆分出 1024 个子页表，这些子页表再各自存放到内存块中。</p>
<p>于是，我们需要一张<strong>页目录表</strong>（<strong>一级页表</strong>&#x2F;顶层页表&#x2F;外层页表）来记录页目录表和<strong>子页表</strong>（<strong>二级页表</strong>）之间的映射关系，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192925065.png" alt="image-20221128192925065"></p>
<p>同时，之前的逻辑地址的含义也发生了改变。在单级页表中，前 20 位表示页号；而在两级页表中，前 10 位表示<strong>一级页号</strong>（一级页表的页号），紧跟着的 10 位表示<strong>二级页号</strong>（二级页表的页号）。这么划分之后，一级页号共有 2^10^&#x3D;1024 种可能的取值，即页目录表的 1024 个页表项；二级页号也有 2^10^&#x3D;1024 种可能的取值，即子页表的 1024 个页表项。</p>
<p>在需要进行地址转换时：</p>
<ul>
<li>首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量</li>
<li>然后从 PCB 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即读取到了一级页号对应的块号</li>
<li>根据块号到内存中找到对应的二级页表</li>
<li>在二级页表中，根据二级页号找到对应的块号</li>
<li><code>块号 * 页框大小 + 偏移量</code>得到物理地址</li>
</ul>
<p>上面的过程也可以直接看这幅图理解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192933032.png" alt="image-20221128192933032"></p>
<h5 id="单级页表常驻内存的问题"><a href="#单级页表常驻内存的问题" class="headerlink" title="单级页表常驻内存的问题"></a>单级页表常驻内存的问题</h5><p>执行程序时，往往只需要访问特定的几个页面，但整个单级页表是常驻在内存中的。[虚拟存储技术](#第五章 虚拟存储器)可以在需要访问页面的时候才把对应的页表项调入内存。</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><blockquote>
<p>某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用多少级页表？页内偏移量为多少位？</p>
</blockquote>
<p>4KB &#x3D; 4*1024B &#x3D; 2^12^B，根据之前讲过的，页面偏移量应该是 12 位。40 - 12 &#x3D; 28，所以前面 28 位用来表示页号。</p>
<p>因为<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>，而一个页面最多只能放 1024 个页表项，所以应该限制页表最多只能包含 1024 个页表项（否则就放不下多余的页表项，导致页表超过一个页面），即逻辑地址中的 10 位二进制数。</p>
<p>在逻辑地址的前 28 位中，可以选择 10 位用于表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用 10 位表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用剩下的 8 位表示某一级的页号（这一级的页表假设页表项远远少于 1024 个）。</p>
<p>也可以考虑前面 8 位作为一级页号，紧接着的 10 位作为二级页号，再紧接着的 10 位作为三级页号，这样刚好就用完了逻辑地址前 28 位。所以题目需要采用三级页表。</p>
<p>那如果这里不采用三级页表，强行使用二级页表，则必定有某一级的页号位数超过了 10，说明页表的页表项个数超过了 2^10^&#x3D;1024 个，很显然就会导致一个页框放不下这一级的页表，需要跨页，这与规定“<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>”是相悖的。</p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><blockquote>
<ol>
<li>若系统采用两级分页存储方式，物理内存 64MB，页面大小 1KB，页表项大小 2B，则顶级页表有多少个页表项？</li>
</ol>
</blockquote>
<p>这里我们可以参考之前<a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">求页表项大小</a>的思路。物理内存 64MB &#x3D; 2^26^B，表示这么多内存需要 26 位逻辑地址。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。</p>
<p>因为页面大小 1KB &#x3D; 2^10^B，所以页内偏移量需要 10 位来表示，余下 16 位供一、二级页号使用。一个页面大小 2^10^B，一个页表项 2B，所以一个页框可以最多可以放 2^10^&#x2F;2 &#x3D; 2^9^ 个页表项，又由于<strong>各级页表不能超过一个页面</strong>，所以各级页表都不能超过 2^9^ 个页表项。在余下的 16 位中，用 9 位表示二级页表的页号（此时该页表的页表项个数取满）。剩下的 7 位表示一级页表的页号，可以包含 2^7^ &#x3D; 128 个页表项。</p>
<blockquote>
<ol start="2">
<li>若系统采用分页存储方式，物理内存 256MB，页面大小 1KB，页表如下：</li>
</ol>
<p>页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39</p>
<p>则逻辑地址 1A68（16 进制）对应的物理地址是多少？</p>
</blockquote>
<p>为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。</p>
<p>1A68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：</p>
<ul>
<li>页号 &#x3D; 6760&#x2F;1024 &#x3D; 6（取整数部分）</li>
<li>页内偏移量 &#x3D; 6760%1024 &#x3D; 616</li>
</ul>
<p>根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 &#x3D; 31744，偏移量和初始地址相加得到的物理地址为 31744+616 &#x3D; 32360。32360 是十进制的物理地址，短除法转化为对应的十六进制物理地址就是 7E68。</p>
<blockquote>
<p>若统一使用二进制计算：</p>
<p>256MB &#x3D; 2^28^B 逻辑地址共28位</p>
<p>1A68 转换为二进制：0001 1010 0110 1000</p>
<p>页内偏移量 10位</p>
<p>28-10&#x3D;18 页号位数</p>
<p>补齐位数0000 0000 0000 0001 1010 0110 1000</p>
<p>即000000000000000110,1001101000</p>
<p>页号为6，起始地址 31*1024&#x3D;31744</p>
<p>出题者想让你用十进制做，因为给的是十进制的页表</p>
</blockquote>
<blockquote>
<ol start="3">
<li>若系统采用分页存储方式，物理内存 1MB，共有 32 个页面，一个页面 2KB，则逻辑地址一共多少位？</li>
</ol>
</blockquote>
<p><del>因为物理内存 1MB &#x3D; 2^20^B，所以逻辑地址 20 位。</del></p>
<p>根据上面的经验，我们可能会这么做，但是<strong>这是错误的做法</strong>。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位，逻辑地址也需要多少位。但是这道题已经告诉了我们程序具体被划分为32个页面——显然，仅仅 32 个页面是不需要 20 这么多位的逻辑地址的。</p>
<p>逻辑地址包括两部分，页号和页内偏移量：</p>
<ul>
<li>考虑页内偏移量位数。由于一个页面 2KB，也即 2^11^B，所以页内偏移量占 11 位（注意这点是不变的）</li>
<li>考虑页号位数。<strong>由于页面仅仅被划分为 32 &#x3D; 2^5^ 个</strong>，所以页号只需要 5 位</li>
</ul>
<p>11 + 5 &#x3D; 16，所以逻辑地址一共 16 位。</p>
<p><strong>当题目明确给出分页个数的时候，按照页号位数 + 偏移量位数计算逻辑地址总位数。</strong></p>
<h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p>在基本分页存储管理中，我们将程序分为多个大小相等的物理单元（页面）。而在基本分段存储管理中，我们倾向于从逻辑功能的角度去考虑，将程序<strong>分为多个逻辑功能段</strong>，每个段都有自己的段名，并且都从 0 开始编址。分配内存时以段为单位进行分配，段内所占内存空间是连续的，但是各个段之间可以不相邻，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192944911.png" alt="image-20221128192944911"></p>
<p>编写程序时可以将程序按照逻辑功能模块进行划分，会更加方便，可读性会更高，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[D]|&lt;A&gt;</span><br><span class="line">STORE 1，[X]|&lt;B&gt;</span><br></pre></td></tr></table></figure>

<p>分别表示：将分段 D 中 A 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 X 的 B 单元中。这里的分段 D 和 X 都是段名，程序员在编程的时候只需要使用段名，编译时段名会转化为对应的段号。同理，A、B 单元编译时也会转化为寄存器地址。</p>
<h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>分段存储管理中逻辑地址的含义与分页存储管理不同。假设仍然是用 32 位二进制数表示逻辑地址，地址的前 16 位表示<strong>段号</strong>，后 16 位表示段内<strong>偏移量</strong>：</p>
<ul>
<li>段号是 16 位二进制数，有 2^16^ 种取值，即每个进程最多可以被分为 2^16^ 个段</li>
<li>段内偏移量也是 16 位二进制数，在一个段内，段内地址可能有 2^16^ 种取值，所以一个段的最大长度为 2^16^</li>
</ul>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>类似的，我们需要用<strong>段表</strong>来记录某个编号段与实际物理存放位置之间的映射关系。在分段存储管理中，程序被分为大小不等的多个段，且不连续，没法像之前一样只凭借块号来推导块的初始地址。为了准确地找出段存放在内存中的位置，我们要将<strong>段号、段长、基址</strong> 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的基址（即起始地址，不是块号），再结合段长，可以知道这个段具体占用了哪里的空间。</p>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128192954137.png" alt="image-20221128192954137"></p>
<h4 id="段表项的大小"><a href="#段表项的大小" class="headerlink" title="段表项的大小"></a>段表项的大小</h4><p>每个段表项由段号、段长、基址构成，我们可以依次考虑每一列可能占用的空间（假设物理内存 4GB，按字节寻址）：</p>
<ul>
<li>基址：因为物理内存 4GB，也就是 2^32^B，那么内存中的地址最多可能取到 2^32^ 种值。为了让基址列<strong>足够</strong>表示这些值，基址列占用了 32 位。</li>
<li>段长：前面讲过，在逻辑地址中，段号和段内偏移量都是 16 位，所以段内偏移量最多可能取到 2^16^ 种值，为了让段长列<strong>足够</strong>表示这些值，段长列占用了 16 位</li>
<li>段号：和页表一样，在<strong>段表中同样隐含段号</strong>，因为段表也是连续的，我们只需要知道<strong>段表的起始地址</strong>和<strong>每个段表项的大小</strong>就能定位一个<strong>段表项的地址</strong>，而无需去维护一个从段号到段表项的映射。</li>
</ul>
<p>因此，每个段表项占用了 16+32&#x3D;48 位，一个字节 8 位，占用了 6 个字节， 即 6B。</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>转换过程我们可以直接看下图理解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193010730.png" alt="image-20221128193010730"></p>
<p>可以联系分页存储的地址转换过程。在需要将逻辑地址转换为物理地址的时候：</p>
<ul>
<li>首先将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度保存了程序总共被分为了多少段，因此段号不应该超过段表长度，若超过则发生越界中断。</li>
<li>根据段号、段表初始地址和段表项的大小，找到段号对应的段表项。比较段表项中的段长 C 和逻辑地址中的段内偏移量 W，若 W &gt;&#x3D; C 则发生越界中断（此处比分页存储多一次越界判断，因为页表的页框大小固定，且受页内偏移量位数限制不会越界，而段长可变）</li>
<li>在段表项中找到段号对应的基址，将该基址与段内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li>
</ul>
<h4 id="分页和分段的对比"><a href="#分页和分段的对比" class="headerlink" title="分页和分段的对比"></a>分页和分段的对比</h4><h5 id="划分的角度和维度"><a href="#划分的角度和维度" class="headerlink" title="划分的角度和维度"></a>划分的角度和维度</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193022033.png" alt="image-20221128193022033"></p>
<h5 id="信息的共享和保护"><a href="#信息的共享和保护" class="headerlink" title="信息的共享和保护"></a>信息的共享和保护</h5><p>在分段存储方式中，更容易实现信息共享和保护：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193032194.png" alt="image-20221128193032194"></p>
<p>可重入代码(Reentry code)也叫纯代码(Pure code)是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。</p>
<p>在分页存储方式中，则很难：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193042146.png" alt="image-20221128193042146"></p>
<h5 id="访存次数"><a href="#访存次数" class="headerlink" title="访存次数"></a>访存次数</h5><p>两者的访存次数是一样的：</p>
<ul>
<li>若不引入快表，两者的第一次访存都是访问内存中的页&#x2F;段表，第二次是访问内存中的目标。</li>
<li>若引入快表，则两者的第一次访存有可能因为命中而省去。</li>
</ul>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护</li>
<li>采用分段存储管理，可以按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片</li>
</ul>
<p>所以结合二者之长，出现了段页式存储管理方式。</p>
<p>如下图，段页存储管理会首先将进程按照逻辑模块划分为多个段，针对每个段再划分为多个页；同时也把内存划分为多个页框。分配内存的时候，一个页面就对应了一个页框。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193050234.png" alt="image-20221128193050234"></p>
<h4 id="逻辑地址-1"><a href="#逻辑地址-1" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>在分段存储管理中，给出一个逻辑地址，可以划分为段号和段内地址两个部分；而在段页存储管理中，段内地址还要继续细分成页号和页内偏移量两个部分。所以逻辑地址由<strong>段号、页号和页内偏移量</strong>三个部分组成。</p>
<p>段号的位数仍然决定了一个进程可以被划分为多少个段，而页号的位数则决定了一个段可以被划分为多少个页面，页内偏移量则决定了一个页面可以有多大，即页面&#x2F;页框大小。</p>
<p>和分段存储管理一样，段页存储管理的地址结构也是二维的。</p>
<h4 id="段表-1"><a href="#段表-1" class="headerlink" title="段表"></a>段表</h4><p>段页存储管理中的段表不同于分段存储管理中的段表。程序被划分为多个段，每个段都会再被划分为多个页面，因此每一个段都维护着属于自己的一张页表。段表需要记录的是段号与段号对应段的页表之间的映射关系，包括<strong>段号</strong>、<strong>页表长度</strong>和<strong>存放页表的块号</strong>（块号 * 页框大小 &#x3D; 页表所在块的起始地址）。<strong>段号是隐含的</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193058929.png" alt="image-20221128193058929"></p>
<h4 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20221128193131085.png" alt="image-20221128192331085"></p>
<p>段页式存储的地址转换机构结合了分页存储和分段存储的方式，在需要将逻辑地址转换为物理地址的时候：</p>
<ul>
<li>首先将逻辑地址分为<strong>段号、页号和页内偏移量</strong>三个部分，段表寄存器中的段表长度仍代表程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则越界中断（同段式存储第一次越界检查）</li>
<li>根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。可以从这个段表项读取到该段号对应的页表的位置和大小。这里同样要比较段表项中的页表长度和逻辑地址中的页号 P，若页号大于等于页表长度则越界中断（同页式存储唯一一次越界检查，不同于段式存储第二次越界检查）</li>
<li>找到了段表项就是找到了该段的页表所在块的块号。根据块号，在内存中找到这个块，再从块中找到页表</li>
<li>根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li>
</ul>
<h4 id="访存次数-1"><a href="#访存次数-1" class="headerlink" title="访存次数"></a>访存次数</h4><p>不采用快表时，段页式存储管理需要经历三次访存：第一次访存，访问内存中的段表，找到段表中记录的页表信息；第二次访存，访问内存中的页表，找到目标所在的块；第三次访存，访问内存中的目标。</p>
<p>如果采用快表，会利用段号和页号去寄存器中检索，若命中，则无需经历第一次和第二次访存，可以直接拿到块号并和偏移量进行拼接，得到物理地址。同样只需要一次访存。</p>
<h1 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h1><h1 id="期末考试备考"><a href="#期末考试备考" class="headerlink" title="期末考试备考"></a>期末考试备考</h1><p>选择题 15分</p>
<p>判断题 10分</p>
<p>简答题 30分</p>
<p>综合应用题 45分</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pil0txia.com">Pil0tXia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pil0txia.com/post/2022-09-08_os-notes/">https://pil0txia.com/post/2022-09-08_os-notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pil0txia.com" target="_blank">Pil0tXia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E6%9C%AC%E7%A7%91CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">本科CS课程笔记</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A/">大三上</a></div><div class="post_share"><div class="social-share" data-image="https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2022-09-13_assembler-language-notes/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220913160311958.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">汇编语言程序设计学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/post/2022-06-20_ai-introductory-theory-notes/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220621130226727.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">人工智能重点题目整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2022-09-13_assembler-language-notes/" title="汇编语言程序设计学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220913160311958.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-13</div><div class="title">汇编语言程序设计学习笔记</div></div></a></div><div><a href="/post/2022-09-19_python-notes/" title="Python程序设计学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/image-20220919110722606.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-19</div><div class="title">Python程序设计学习笔记</div></div></a></div><div><a href="/post/2022-12-11_linux-background-programs/" title="Linux 后台程序的创建与管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/03_gettyimages-910112716_resized.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="title">Linux 后台程序的创建与管理</div></div></a></div><div><a href="/post/2022-02-21_DBMS-notes/" title="数据库系统笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/QQ%E5%9B%BE%E7%89%8720220228114653.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">数据库系统笔记</div></div></a></div><div><a href="/post/2022-03-17_Computer-Organization-and-Architecture-notes/" title="计算机组成与系统结构笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/117555599_664168731124086_868759872245613453_n.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-17</div><div class="title">计算机组成与系统结构笔记</div></div></a></div><div><a href="/post/2022-03-18_computer-networks-notes/" title="计算机网络笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/picgo/1996208-20200416224258894-1241589285.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">计算机网络笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/assets/03_3_tinypng.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Pil0tXia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" href="mailto:admin@pil0txia.com"><i class="fas fa-envelope"></i><span>Contact Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Pil0tXia" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/286768851/" rel="external nofollow noreferrer" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://user.qzone.qq.com/1837713753/main" rel="external nofollow noreferrer" target="_blank" title="Photography"><i class="fa-solid fa-camera"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不会摄影的白帽子不是好机长！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">单道批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">多道批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">并发与并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.</span> <span class="toc-text">分时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">操作系统的四个基础特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3OS%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">1.7.</span> <span class="toc-text">现代OS的基本单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A1"><span class="toc-number">1.8.</span> <span class="toc-text">作业1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">1.9.</span> <span class="toc-text">内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.</span> <span class="toc-text">中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">系统调用的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.2.</span> <span class="toc-text">系统调用与库函数的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8"><span class="toc-number">1.12.</span> <span class="toc-text">冷启动和热启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%B5%84%E6%96%99"><span class="toc-number">1.13.</span> <span class="toc-text">补充资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A2%EF%BC%88%E4%B9%A6%E9%9D%A2%E7%89%88%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%A6%82%E6%8B%AC%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">作业2（书面版进行了概括）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%A8%80"><span class="toc-number">1.15.</span> <span class="toc-text">附言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程的描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">程序的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">为什么程序不能调度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">判断程序是否可以并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程控制块PCB的组织方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">2.3.</span> <span class="toc-text">作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.1.</span> <span class="toc-text">进程的状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%80%81"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">三态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E6%80%81"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">五态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E4%BC%9A%E6%9C%89%E6%89%80%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">七态（重要，在后面的章节会有所拓展）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%AD%A2%E9%98%BB%E5%A1%9E-x2F-%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.1.3.1.</span> <span class="toc-text">静止阻塞&#x2F;就绪队列的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.3.2.</span> <span class="toc-text">挂起的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.1.3.3.</span> <span class="toc-text">挂起的特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%B1%87%E6%80%BB"><span class="toc-number">2.4.1.3.4.</span> <span class="toc-text">状态转换的汇总</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">进程的创建（创建原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">进程的终止（撤销原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%EF%BC%88%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%ADblock%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">进程的阻塞（阻塞原语block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92%EF%BC%88%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%ADwake-up%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">进程的唤醒（唤醒原语wake up）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%88%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.6.</span> <span class="toc-text">进程的切换（切换原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%EF%BC%88%E6%8C%82%E8%B5%B7%E5%8E%9F%E8%AF%ADsuspend%E5%92%8C%E6%BF%80%E6%B4%BB%E5%8E%9F%E8%AF%ADactive%EF%BC%89"><span class="toc-number">2.4.7.</span> <span class="toc-text">进程的挂起（挂起原语suspend和激活原语active）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.5.</span> <span class="toc-text">进程的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.6.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">进程互斥的基本实现逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">同步机制应遵循的原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CPV%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.2.</span> <span class="toc-text">信号量和PV操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.2.1.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.2.1.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">信号量机制实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.6.2.2.1.</span> <span class="toc-text">进程互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-number">2.6.2.2.2.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.2.2.3.</span> <span class="toc-text">前驱关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CPV%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">信号量和PV操作解决进程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">生产者-消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%B9%E6%9E%9C%E6%A9%98%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">苹果橘子问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.3.</span> <span class="toc-text">银行问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.4.</span> <span class="toc-text">五个哲学家进餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.3.4.1.</span> <span class="toc-text">实现原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E5%9B%9B%E4%B8%AA%E4%BA%BA%E5%8F%82%E4%B8%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.6.3.4.2.</span> <span class="toc-text">只有四个人参与这个过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E6%8B%BF%E5%B7%A6%E8%BE%B9%EF%BC%8C%E5%81%B6%E6%95%B0%E6%8B%BF%E5%8F%B3%E8%BE%B9"><span class="toc-number">2.6.3.4.3.</span> <span class="toc-text">奇数拿左边，偶数拿右边</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.6.4.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">管程的基本思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">进程通信的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.7.4.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">直接通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">间接通信方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">引入线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">线程与进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.3.</span> <span class="toc-text">线程的状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">第三章 处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.</span> <span class="toc-text">处理机调度的层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">三级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">作业调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">内存调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">进程调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">队列调度模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%85%E6%9C%89%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">仅有进程调度的队列模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">具有高级调度和低级调度的调度队列模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">具有三级调度的调度队列模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">选择调度算法的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.3.1.</span> <span class="toc-text">面向用户的准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">周转时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">响应时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">截止时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83%E5%87%86%E5%88%99"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">优先权准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">面向系统的准则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">先来先服务(FCFS)调度算法（作业调度+进程调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">最短作业(SJF)调度算法（作业调度+进程调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.3.</span> <span class="toc-text">高响应比优先(HRRN)调度算法（作业调度+进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83-FPF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.4.</span> <span class="toc-text">高优先权(FPF)调度算法（作业调度+进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">非抢占式优先权算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">抢占式优先权算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">静态优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">动态优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-1"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">例题1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-RR-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.5.</span> <span class="toc-text">时间片轮转(RR)调度算法（进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-2"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">例题1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.6.</span> <span class="toc-text">多级反馈调度算法（进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-3"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%88%E5%8F%AA%E6%9C%893%E4%B8%AA%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%9A%84%E4%BE%8B%E9%A2%981%EF%BC%89"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">例题2（只有3个就绪队列的例题1）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.1.</span> <span class="toc-text">出现死锁的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A8%E8%BF%9B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%BD%93"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">进程推进顺序不当</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">资源竞争</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.2.</span> <span class="toc-text">产生死锁的四个必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">非抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%8D%A0%E6%9C%89"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">请求和占有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E8%B7%AF%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">环路循环等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.3.</span> <span class="toc-text">预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">破坏非抢占条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E2%80%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%8D%A0%E6%9C%89%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">破坏“请求和占有”条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E2%80%9C%E7%8E%AF%E8%B7%AF%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">破坏“环路循环等待”条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.4.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">进程-资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A1%88%E4%BE%8B"><span class="toc-number">3.5.4.2.1.</span> <span class="toc-text">银行家算法案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.4.2.2.</span> <span class="toc-text">银行家算法过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-4"><span class="toc-number">3.5.4.2.3.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-1"><span class="toc-number">3.5.4.2.4.</span> <span class="toc-text">例题2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%983"><span class="toc-number">3.5.4.2.5.</span> <span class="toc-text">例题3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.5.</span> <span class="toc-text">检测死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">简化进程-资源分配图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA"><span class="toc-number">3.5.5.1.1.</span> <span class="toc-text">各类资源只有一个</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90%E6%9C%89%E5%A4%9A%E4%B8%AA"><span class="toc-number">3.5.5.1.2.</span> <span class="toc-text">各类资源有多个</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.6.</span> <span class="toc-text">解除死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%89%A5%E5%A4%BA%E6%B3%95"><span class="toc-number">3.5.6.1.</span> <span class="toc-text">资源剥夺法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B%E6%B3%95"><span class="toc-number">3.5.6.2.</span> <span class="toc-text">终止进程法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E9%80%80%E6%B3%95"><span class="toc-number">3.5.6.3.</span> <span class="toc-text">进程回退法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">多级存储器结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.</span> <span class="toc-text">程序的装入与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">装入时动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">运行时动态链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%85%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">装入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">绝对装入方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">静态重定位装入方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">动态重定位装入方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text">连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">4.3.1.</span> <span class="toc-text">外部碎片和内部碎片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.3.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.4.</span> <span class="toc-text">动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">主要过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">基于顺序搜索的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%EF%BC%88FF%EF%BC%89"><span class="toc-number">4.3.4.3.1.</span> <span class="toc-text">首次适应（FF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%EF%BC%88NF%EF%BC%89"><span class="toc-number">4.3.4.3.2.</span> <span class="toc-text">邻近适应（NF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%EF%BC%88BF%EF%BC%89"><span class="toc-number">4.3.4.3.3.</span> <span class="toc-text">最佳适应（BF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94-%EF%BC%88WF%EF%BC%89"><span class="toc-number">4.3.4.3.4.</span> <span class="toc-text">最坏适应 （WF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.4.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E6%90%9C%E7%B4%A2%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">基于索引搜索的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94"><span class="toc-number">4.3.4.4.1.</span> <span class="toc-text">快速适应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.4.4.2.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">哈希算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.5.</span> <span class="toc-text">动态可重定位分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.4.</span> <span class="toc-text">非连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E3%80%81%E9%A1%B5%E6%A1%86"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">页面、页框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">地址转换的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.3.1.</span> <span class="toc-text">十进制地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.3.2.</span> <span class="toc-text">二进制地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">4.4.1.3.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.4.1.5.</span> <span class="toc-text">地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.4.1.5.1.</span> <span class="toc-text">基本地址变换机构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-5"><span class="toc-number">4.4.1.5.2.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.4.1.5.3.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-2"><span class="toc-number">4.4.1.5.4.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.4.1.6.</span> <span class="toc-text">页表项的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.4.1.7.</span> <span class="toc-text">两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.7.1.</span> <span class="toc-text">单级页表占用过大的连续内存空间的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.4.1.7.2.</span> <span class="toc-text">引入两级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%B8%B8%E9%A9%BB%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.7.3.</span> <span class="toc-text">单级页表常驻内存的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.4.1.7.4.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">4.4.1.8.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.2.</span> <span class="toc-text">基本分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">逻辑地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">段表项的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.2.5.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.4.2.6.</span> <span class="toc-text">分页和分段的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%9A%84%E8%A7%92%E5%BA%A6%E5%92%8C%E7%BB%B4%E5%BA%A6"><span class="toc-number">4.4.2.6.1.</span> <span class="toc-text">划分的角度和维度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.4.2.6.2.</span> <span class="toc-text">信息的共享和保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E5%AD%98%E6%AC%A1%E6%95%B0"><span class="toc-number">4.4.2.6.3.</span> <span class="toc-text">访存次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-1"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">逻辑地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8-1"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E5%AD%98%E6%AC%A1%E6%95%B0-1"><span class="toc-number">4.4.3.5.</span> <span class="toc-text">访存次数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">第五章 虚拟存储器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">期末考试备考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2022-12-11_linux-background-programs/" title="Linux 后台程序的创建与管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/03_gettyimages-910112716_resized.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 后台程序的创建与管理"/></a><div class="content"><a class="title" href="/post/2022-12-11_linux-background-programs/" title="Linux 后台程序的创建与管理">Linux 后台程序的创建与管理</a><time datetime="2022-12-10T17:46:39.000Z" title="发表于 2022-12-11 01:46:39">2022-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-12-09_foreign-netdisk-download/" title="国外限流网盘的下载方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/material%20(0).webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国外限流网盘的下载方案"/></a><div class="content"><a class="title" href="/post/2022-12-09_foreign-netdisk-download/" title="国外限流网盘的下载方案">国外限流网盘的下载方案</a><time datetime="2022-12-09T15:58:03.000Z" title="发表于 2022-12-09 23:58:03">2022-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-12-09_chatgpt-teach-stable-diffusion/" title="我的 AI 的 AI 也是我的 AI——利用聊天 AI 指导 AI 绘画并迭代弥补瑕疵"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/gallery/ai_paint/00262-3244499331.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的 AI 的 AI 也是我的 AI——利用聊天 AI 指导 AI 绘画并迭代弥补瑕疵"/></a><div class="content"><a class="title" href="/post/2022-12-09_chatgpt-teach-stable-diffusion/" title="我的 AI 的 AI 也是我的 AI——利用聊天 AI 指导 AI 绘画并迭代弥补瑕疵">我的 AI 的 AI 也是我的 AI——利用聊天 AI 指导 AI 绘画并迭代弥补瑕疵</a><time datetime="2022-12-09T08:17:47.000Z" title="发表于 2022-12-09 16:17:47">2022-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10_why-python36-dict-is-ordered/" title="为什么 Python 3.6 以后字典有序并且效率更高？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/material%20(1).webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为什么 Python 3.6 以后字典有序并且效率更高？"/></a><div class="content"><a class="title" href="/post/2022-11-10_why-python36-dict-is-ordered/" title="为什么 Python 3.6 以后字典有序并且效率更高？">为什么 Python 3.6 以后字典有序并且效率更高？</a><time datetime="2022-11-10T11:48:46.000Z" title="发表于 2022-11-10 19:48:46">2022-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-09-29_servlet-get-post-garbage-characters/" title="Servlet 中请求和响应过程中的乱码问题解决"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.pil0txia.com/cover/230012419_1778894045652329_3166495515225915452_n.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Servlet 中请求和响应过程中的乱码问题解决"/></a><div class="content"><a class="title" href="/post/2022-09-29_servlet-get-post-garbage-characters/" title="Servlet 中请求和响应过程中的乱码问题解决">Servlet 中请求和响应过程中的乱码问题解决</a><time datetime="2022-09-29T10:33:36.000Z" title="发表于 2022-09-29 18:33:36">2022-09-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By Pil0tXia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">不会摄影的白帽子不是好机长！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://cdn.staticfile.org/instant.page/5.1.1/instantpage.min.js" type="module"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script src="https://cdn.staticfile.org/node-snackbar/0.1.16/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'Pil0tXia/hexo-giscus',
    'data-repo-id': 'R_kgDOIPxOww',
    'data-category-id': 'DIC_kwDOIPxOw84CSC9p',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/canvas-ribbon.min.js" size="170" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>