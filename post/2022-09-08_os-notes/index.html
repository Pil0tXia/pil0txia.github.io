<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统学习笔记 | Pil0tXia</title><meta name="author" content="Pil0tXia"><meta name="copyright" content="Pil0tXia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 引论单道批处理 多道批处理多道批处理系统宏观上并行微观上串行的含义   并发与并行的区别一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。 分时操作系统 实时操作系统  操作系统的四个基础特性1、并发性， 2、共享性，3、虚拟性，4、异步性 异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习笔记">
<meta property="og:url" content="https://pil0txia.com/post/2022-09-08_os-notes/index.html">
<meta property="og:site_name" content="Pil0tXia">
<meta property="og:description" content="第一章 引论单道批处理 多道批处理多道批处理系统宏观上并行微观上串行的含义   并发与并行的区别一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。 分时操作系统 实时操作系统  操作系统的四个基础特性1、并发性， 2、共享性，3、虚拟性，4、异步性 异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg">
<meta property="article:published_time" content="2022-09-08T03:11:56.000Z">
<meta property="article:modified_time" content="2022-11-18T15:43:19.479Z">
<meta property="article:author" content="Pil0tXia">
<meta property="article:tag" content="本科CS课程笔记">
<meta property="article:tag" content="大三上">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg"><link rel="shortcut icon" href="/me/favicon.ico"><link rel="canonical" href="https://pil0txia.com/post/2022-09-08_os-notes/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="rTQaiWh7-ABfHgHfDRir5VZEmaT71cHgcV-IPp_hjjk"/><meta name="baidu-site-verification" content="NJqTNAqxF4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-18 23:43:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/me/03_3_tinypng.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Pil0tXia</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-08T03:11:56.000Z" title="发表于 2022-09-08 11:11:56">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-18T15:43:19.479Z" title="更新于 2022-11-18 23:43:19">2022-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/Pasted%20image%2020220908221259.png"></p>
<h2 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/PriceCheap/article/details/125256919">多道批处理系统宏观上并行微观上串行的含义</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220908223051244.png" alt="image-20220908223051244"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220908224939144.png" alt="image-20220908224939144"></p>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p><strong>一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。</strong></p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220908225751025.png" alt="image-20220908225751025"></p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220908230010886.png" alt="image-20220908230010886"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220908230154923.png" alt="image-20220908230154923"></p>
<h2 id="操作系统的四个基础特性"><a href="#操作系统的四个基础特性" class="headerlink" title="操作系统的四个基础特性"></a>操作系统的四个基础特性</h2><p>1、并发性， 2、共享性，3、虚拟性，4、异步性</p>
<p>异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。</p>
<h2 id="现代OS的基本单位"><a href="#现代OS的基本单位" class="headerlink" title="现代OS的基本单位"></a>现代OS的基本单位</h2><p>内核、进程、线程、类程、管程</p>
<h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220919150833779.png" alt="image-20220919150833779"></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://chorer.github.io/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">Focus on FE learning 操作系统学习笔记-2：体系结构设计和运行机制</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://quemingfei.com/archives/wang-dao-kao-yan-cao-zuo-xi-tong-xue-xi-bi-ji-hui-zong">《王道考研 操作系统》学习笔记汇总</a></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220922101548539.png" alt="image-20220922101548539"></p>
<p>微内核中，应用程序与OS内核的通信：系统调用；非内核功能（用户空间的OS）和OS内核的通信：消息传递；非内核功能之间的通信：直接调用。</p>
<p>用户态切换到内核态的3种方式：系统调用、异常、外围设备的中断</p>
<p>内核态切换到用户态的方式：特权指令，设置程序状态字为PSW</p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断的类型：内中断（也称为“异常”、例外）；外中断（也称为“中断”）</p>
<p>内中断的案例：非法指令；应用程序请求操作系统时发出“陷入指令”，该指令会引发一个内部中断指令，意味着应用程序主动将CPU控制权还给OS。“系统调用”就是通过陷入指令完成。</p>
<p>中断处理程序一定是内核程序，需要运行在“内核态”。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是应用程序获得OS服务的唯一途径。内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。</p>
<h3 id="系统调用的方式"><a href="#系统调用的方式" class="headerlink" title="系统调用的方式"></a>系统调用的方式</h3><p>用户-&gt;应用程序-&gt;系统调用（系统调用组成了程序接口API，每一个系统调用都是一个完成特定功能的子程序）-&gt;OS内核（裸机）</p>
<p>用户-&gt;图形窗口-&gt;OS内核（裸机）</p>
<p>用户-&gt;操作命令-&gt;系统程序（操作接口由一组控制命令和作业控制语句组成）-&gt;OS内核（裸机）</p>
<h3 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h3><p>应用程序不可以直接调用系统调用，是通过库函数调用系统调用的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220922111334895.png" alt="image-20220922111334895"></p>
<h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220922111557735.png" alt="image-20220922111557735"></p>
<p>冷启动<br>（1）开机执行BIOS引导程序，标识和配置所有的即插即用设备，并配置DMA通道<br>（2）完成加电自检，测试内存，端口，键盘，视频适配器，磁盘驱动器等基本设备，及CD-ROM驱动器。<br>（3）对引导驱动器引导分区定位：在CMOS中，可以自行设置引导顺序，一般顺序是软盘，磁盘，光驱；<br>（4）加载主引导记录以及引导驱动器的分区表，执行主引导记录MBR。<br>（5）装入操作系统<br>热启动<br>（6）BOOT被自动执行，指引CPU把操作系统从大容量存储器中传送到主存储器的易失区；<br>（7）BOOT要求CPU执行一条转移指令，转到这个存储区域；此时，操作系统接管并且开始控制整个机器的活动。</p>
<h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><p>为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？</p>
<p>采用多道程序设计减少了CPU时间的浪费，增加了系统吞吐量，提高了系统的效率。.多道程序并发执行是指有的程序正在CPU上执行，而另一些程序正在I&#x2F;O设备上进行传输，即通过CPU操作与外设传输在时间上的重叠减少CPU时间的浪费，并提高了系统的效率。实现CPU操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：</p>
<p>（1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立与CPU运行，因而做到了输入输出操作与CPU并行工作。但早期CPU与通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到CPU与I&#x2F;O设备并行工作的。</p>
<p>（2）在硬件上引入了中断技术。所谓中断，就是在输入输出结束时，或硬件发生某种故障时，由相应硬件（即中断机构）向CPU发出信号。这时CPU立即停下手头的工作而转向处理中断请求，道处理完中断后再继续原来手头的工作。因此，通道技术和中断技术结合起来就可实现CPU与I&#x2F;O设备并行工作，即CPU启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作。这样，就真正做到了CPU与I&#x2F;O设备并行工作。此时，多道程序的概念才变为现实。</p>
<h2 id="作业2（书面版进行了概括）"><a href="#作业2（书面版进行了概括）" class="headerlink" title="作业2（书面版进行了概括）"></a>作业2（书面版进行了概括）</h2><ol>
<li><p>设计现代OS的主要目标是什么？</p>
<p>方便性，有效性，可扩充性，开放性</p>
</li>
<li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。</p>
<p>（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微秒。</p>
<p>（2）交互性：实时信息处理系统具有交互性，但实时终端设备只是作为执行装置或咨询装置，人与系统的交互仅限于访问系统中某些特定的专用服务程序。分时系统的用户可以与系统进行人机交互，包括在终端上可以直接调试自己的程序，系统能向终端用户提供数据和资源共享等服务。</p>
<p>（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。</p>
</li>
<li><p>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？</p>
<p>（1）OS 环境下与一般情况下的资源共享间的不同点</p>
<p>①一般情况下的共享</p>
<p>一般情况下的共享只是说明某种资源能被大家使用，对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。</p>
<p>②OS 环境下的共享</p>
<p>OS 环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。</p>
<p>（2）独占资源应采取的共享方式</p>
<p>对独占资源应采用互斥共享方式，该共享方式仅当占有该资源的进程访问并释放资源后，才允许另一进程对该资源进行访问。</p>
</li>
<li><p>什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。</p>
<p>（1）时分复用技术的定义<br>时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。<br>（2）时分复用技术能提高资源利用率的根本原因<br>时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务使设备得到最充分的利用。</p>
</li>
<li><p>何谓微内核技术？在基于微内核结构的OS中，应用了哪些新技术？在微内核中通常提供了哪些功能？</p>
<p>（1）把操作系统中更多的成分和功能放到更高的层次(即用户模式)中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。 </p>
<p>（2）面向对象的程序设计技术。</p>
<p>（3）在微内核中通常提供了进程(线程)管理、低级存储器管理、中断和陷入处理等功能。</p>
</li>
</ol>
<h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>最近我的操作系统老师和软件工程老师都在上课时讲鸿蒙OS有多么多么划时代，可事实上并非如此。我一问才知道，是华为有人找他们合作，让他们上课时多放入一点鸿蒙的知识。我理解鸿蒙是一个较为优秀的国产定制系统，但是把它等同于目前所有系统、实时操作系统的下一代系统，实在太误人子弟。</p>
<p>19年鸿蒙说是要完全自主开发内核，22年现在却在用AOSP<code>Andriod Open Source Project</code>；“分布式”有两个，真正意义上的分布式可以同步两台设备上同一版本软件的操作，目前还停留在SDK阶段，大肆宣传的那个分布式不过是投屏罢了。</p>
<p>要说怪谁，只能怪一开始饼画太大，缺口已经补不上了。其实按照开源协议使用开源代码不丢人，丢人的是欲盖弥彰啊。</p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="程序的基本概念"><a href="#程序的基本概念" class="headerlink" title="程序的基本概念"></a>程序的基本概念</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926155011586.png" alt="image-20220926155011586"></p>
<p>可再现性</p>
<h3 id="为什么程序不能调度？"><a href="#为什么程序不能调度？" class="headerlink" title="为什么程序不能调度？"></a>为什么程序不能调度？</h3><p>程序具有独立性，结果再现。如果程序执行过程中，出现结果无法再现的情况，则程序肯定有问题。如果要让程序被调度，必须满足Berstein条件（任意两条读写的交集不能为空，很难实现）。</p>
<h3 id="判断程序是否可以并发"><a href="#判断程序是否可以并发" class="headerlink" title="判断程序是否可以并发"></a>判断程序是否可以并发</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926154724920.png" alt="image-20220926154724920"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926154807286.png" alt="image-20220926154807286"></p>
<p>（1）程序顺序执行，因为某一时段独占全机，所以结果可再现。</p>
<p>（2）程序并发执行，若不满足Bernstein条件，则结果不再现。</p>
<p>总之，程序不可以并发执行。</p>
<h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926164342078.png" alt="image-20220926164342078"></p>
<p>正是因为有了PCB，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但PCB可以记录此时进程的状态。所以进程是“动态”的。</p>
<blockquote>
<p>简答题“程序为什么不能被调度+进程为什么可以并发执行”是捆绑在一起的。</p>
</blockquote>
<p>父&#x2F;子标识指向父&#x2F;子进程的PID</p>
<ul>
<li>进程调度信息</li>
</ul>
<p>进程的状态：三态、五态、七态</p>
<p>进程的优先级：一个整数</p>
<p>进程调度需要的信息：如等待CPU的时间、执行CPU的时间等等，是调度的一个参考。</p>
<p>阻塞原因：执行-&gt;阻塞状态转换发生的事件</p>
<ul>
<li>进程的控制信息</li>
</ul>
<p>程序和数据在内存、外存的地址</p>
<p>进程同步和通信机制</p>
<p>资源清单：列出除了CPU以外进程所需资源和已经拿到的资源。</p>
<p>链接指针：指出本进程的pcb在pcb队列中下一个进程的pcb首地址</p>
<h3 id="进程控制块PCB的组织方式"><a href="#进程控制块PCB的组织方式" class="headerlink" title="进程控制块PCB的组织方式"></a>进程控制块PCB的组织方式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926165848247.png" alt="image-20220926165848247"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220926170442110.png" alt="image-20220926170442110"></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote>
<p>为什么程序不能被调度？为什么要引入进程？</p>
</blockquote>
<p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E8%B0%83%E5%BA%A6%EF%BC%9F">为什么程序不能调度？</a></p>
<p><a href="#%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%8F%91">为什么程序不能并发？</a></p>
<p><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB">为什么要引入进程？</a></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制由“<strong>原语</strong>”实现。原语具有“原子性”，要么不被执行，一旦被执行，不可以被中断。</p>
<p>在<strong>关中断指令</strong>下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在<strong>开中断指令</strong>下，才会去处理中断。</p>
<p>原语的基本操作包括：</p>
<ul>
<li>更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）</li>
<li>将 PCB 插入到合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ul>
<p>创建原语和撤销原语配对，阻塞原语和唤醒原语配对。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_104925.jpg" alt="IMG_20221006_104925"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_111051.jpg" alt="IMG_20221006_111051"></p>
<p>进程的执行是“异步”的，进程的控制是“原子性”的。</p>
<h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_111447.jpg" alt="IMG_20221006_111447"></p>
<p>阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在CPU中。</p>
<h4 id="五态"><a href="#五态" class="headerlink" title="五态"></a>五态</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153725.jpg" alt="IMG_20221006_153725"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221006134335445.png" alt="image-20221006134335445"></p>
<p>创建进程的过程在内存里完成。</p>
<h4 id="七态（重要，在后面的章节会有所拓展）"><a href="#七态（重要，在后面的章节会有所拓展）" class="headerlink" title="七态（重要，在后面的章节会有所拓展）"></a>七态（重要，在后面的章节会有所拓展）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg" alt="IMG_20221006_153249"></p>
<h5 id="静止阻塞-x2F-就绪队列的理解"><a href="#静止阻塞-x2F-就绪队列的理解" class="headerlink" title="静止阻塞&#x2F;就绪队列的理解"></a>静止阻塞&#x2F;就绪队列的理解</h5><p>当我们把作业从外存拿到内存时，这个过程叫做高级调度。</p>
<p>进程PCB被创建后，PCB存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。</p>
<p>如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。</p>
<p>如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。</p>
<h5 id="挂起的原因"><a href="#挂起的原因" class="headerlink" title="挂起的原因"></a>挂起的原因</h5><p>负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要</p>
<h5 id="挂起的特征"><a href="#挂起的特征" class="headerlink" title="挂起的特征"></a>挂起的特征</h5><ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li>
<li>进程进人挂起状态是由于操作系统父进程或进程本身阻止它的运行</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出</li>
</ul>
<h5 id="状态转换的汇总"><a href="#状态转换的汇总" class="headerlink" title="状态转换的汇总"></a>状态转换的汇总</h5><table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">活动就绪态 → 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。<strong>处于静止就绪态的进程不再被调度执行</strong>；</td>
</tr>
<tr>
<td align="center">静止就绪态 → 活动就绪态</td>
<td align="center">内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行</td>
</tr>
<tr>
<td align="center">活动阻塞态→ 静止阻塞态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 静止就绪态</td>
<td align="center">常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 活动阻塞态</td>
<td align="center">但有时候，如果<strong>静止阻塞态进程</strong>的优先级高于<strong>静止就绪队列中的任何进程</strong>、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态</td>
</tr>
<tr>
<td align="center">运行态→ 静止就绪态</td>
<td align="center">优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态</td>
</tr>
<tr>
<td align="center">创建态→ 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存</td>
</tr>
</tbody></table>
<p>进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。</p>
<h3 id="进程的创建（创建原语）"><a href="#进程的创建（创建原语）" class="headerlink" title="进程的创建（创建原语）"></a>进程的创建（创建原语）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221010_143627.jpg" alt="IMG_20221010_143627"></p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配其运行所需的资源</li>
<li>初始化PCB</li>
<li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。</li>
</ol>
<h3 id="进程的终止（撤销原语）"><a href="#进程的终止（撤销原语）" class="headerlink" title="进程的终止（撤销原语）"></a>进程的终止（撤销原语）</h3><p>引起进程终止的事件包括正常结束、异常结束和外界干预。</p>
<p>终止进程的过程包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_114004.jpg" alt="IMG_20221006_114004"></p>
<ol>
<li>进入终止态的进程不能再执行</li>
<li>OS中保留其记录（状态码+计时统计数据），供其他进程收集</li>
<li>一旦其他进程完成了对终止状态进程的信息提取，OS将删除该进程</li>
</ol>
<h3 id="进程的阻塞（阻塞原语block）"><a href="#进程的阻塞（阻塞原语block）" class="headerlink" title="进程的阻塞（阻塞原语block）"></a>进程的阻塞（阻塞原语block）</h3><p>阻塞进程的过程包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的阻塞队列（即改变它的链接地址）。</p>
<p>引起进程阻塞的事件一般是：</p>
<ul>
<li>请求系统分配共享资源失败（系统已无足够的资源）</li>
<li>等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 I&#x2F;O 操作）</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ul>
<blockquote>
<p>进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程<strong>自己调用了</strong>阻塞原语。</p>
</blockquote>
<h3 id="进程的唤醒（唤醒原语wake-up）"><a href="#进程的唤醒（唤醒原语wake-up）" class="headerlink" title="进程的唤醒（唤醒原语wake up）"></a>进程的唤醒（唤醒原语wake up）</h3><p>唤醒进程的过程包括：在事件阻塞队列中找到 PCB 并将进程移出队列，修改 PCB 的状态信息，再将 PCB 插入到就绪队列。</p>
<p>一般在等待的事件发生时，进程就会被唤醒。</p>
<blockquote>
<p>阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程<strong>自己调用了</strong>唤醒原语，而是“合作”或相关进程进行了调用。</p>
</blockquote>
<h3 id="进程的切换（切换原语）"><a href="#进程的切换（切换原语）" class="headerlink" title="进程的切换（切换原语）"></a>进程的切换（切换原语）</h3><p>前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。</p>
<p>切换原语负责让当前运行的进程从 A 切换为 B，具体包括：</p>
<ul>
<li>一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）</li>
<li>另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）</li>
</ul>
<p>引起进程切换的事件一般有四种：</p>
<ul>
<li>当前进程的时间片被消耗完</li>
<li>有更高优先级的进程到达，抢占了当前进程正在使用的 CPU</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h3 id="进程的挂起（挂起原语suspend和激活原语active）"><a href="#进程的挂起（挂起原语suspend和激活原语active）" class="headerlink" title="进程的挂起（挂起原语suspend和激活原语active）"></a>进程的挂起（挂起原语suspend和激活原语active）</h3><p><strong>挂起原语：</strong></p>
<p>将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（活动就绪态 -&gt; 静止就绪态，活动阻塞态 -&gt; 静止阻塞态），之后将该 PCB 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。</p>
<p>引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。</p>
<p><strong>激活原语：</strong></p>
<p>将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态-&gt;活动就绪态，静止阻塞 -&gt; 活动阻塞态）。</p>
<p>引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。</p>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>结构性：程序块、数据块、进程控制块PCB</p>
<p>动态性：进程是程序在数据集合上的一次执行过程，有生命周期（由创建而产生、由调度而执行、由事件而等待、由撤销而消亡）</p>
<p>并发性：多个进程实体同时存在在内存中，能在一段时间内同时运行，是进程的重要特征</p>
<p>独立性：进程是独立运行、独立获取资源、独立接受调度的基本单位 -&gt; 线程就不独立，它没有资源，依赖于fork的进程的资源</p>
<p>异步性：进程按各自独立的、不可预知的速度向前推进。OS要根据“进程同步机制”来解决异步问题。</p>
<p>操作系统的“虚拟性”是进程所没有的。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。然而，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为<strong>临界资源</strong>——也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。我们通过<strong>进程互斥</strong>来解决此类问题。</p>
</blockquote>
<p>进程同步：指多个相关进程在执行次序上的协调</p>
<p>进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问</p>
<p>临界资源：一次仅供一个进程使用的资源</p>
<p>临界区：在进程中涉及到临界资源的程序段叫临界区</p>
<p>相关临界区：多个进程的临界区称为相关临界区</p>
<h4 id="进程互斥的基本实现逻辑"><a href="#进程互斥的基本实现逻辑" class="headerlink" title="进程互斥的基本实现逻辑"></a>进程互斥的基本实现逻辑</h4><p>为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    extry section;       <span class="comment">// 进入区</span></span><br><span class="line">    critical section;    <span class="comment">// 临界区</span></span><br><span class="line">    exit section;        <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;   <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；</li>
<li>临界区：实际访问临界资源的那段代码</li>
<li>退出区：负责解除之前的 Flag</li>
<li>剩余区：其它处理</li>
</ul>
<p>对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。</p>
<h4 id="同步机制应遵循的原则"><a href="#同步机制应遵循的原则" class="headerlink" title="同步机制应遵循的原则"></a>同步机制应遵循的原则</h4><p>空闲让进：临界区空闲时，应该让想要进入临界区的进程立刻进来</p>
<p>忙则等待：同一时刻只允许一个进程进入临界区</p>
<p>有限等待：要求访问临界资源的进程，应该保证在有限时间内进入临界区</p>
<p>让权等待：当 A 进程进入临界区而导致 B 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入“忙等”状态。</p>
<h3 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h3><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制可以让用户通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而方便地实现进程互斥和进程同步。信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语（或者说是 P 操作和 V 操作，即通过和释放），可以看作是两个函数。</p>
<h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int S = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">wait</span>(<span class="params">int S</span>)               </span><br><span class="line">&#123;                       </span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)			</span><br><span class="line">    S = S-<span class="number">1</span>              </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">int S</span>)</span><br><span class="line">&#123;</span><br><span class="line">    S = S+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样以进程 P0，P1 为例进行说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">P0</span>：                   <span class="attr">P1</span>:</span><br><span class="line"><span class="title function_">wait</span>(S)                <span class="title function_">wait</span>(S)            <span class="comment">// 进入区</span></span><br><span class="line">critical section       critical section   <span class="comment">// 临界区</span></span><br><span class="line"><span class="title function_">signal</span>(S)              <span class="title function_">signal</span>(S)          <span class="comment">// 退出区 </span></span><br></pre></td></tr></table></figure>

<p>假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行“检查”和“上锁”，由于 S 一开始是1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S &#x3D; 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。</p>
<p>整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查”和“上锁”两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是<strong>仍然违背了“让权等待”的原则</strong>。</p>
<p>于是在此基础上，又出现了记录型信号量</p>
<h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 <code>value</code>，而且还提供了一个等待队列 <code>L</code>。</p>
<p>记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，<strong>直接让它自己去阻塞队列</strong>，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。</p>
<p>记录型信号量的结构如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value</span><br><span class="line">    sturct process *L</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure>

<p>同时，记录型信号量的 P、V 操作也有所不同，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait (semaphore S)&#123;</span><br><span class="line">    S.<span class="property">value</span>--</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">block</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">semaphore S</span>)&#123;</span><br><span class="line">    S.<span class="property">value</span>++</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">wakeup</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里要注意的第一个地方是，<code>value</code> 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。</li>
<li>第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿</li>
<li>执行++或–前，<code>S.value</code>为正值时代表可利用的物理资源数；<code>S.value</code>为负值时，其绝对值代表阻塞队列中等待的进程数。</li>
</ul>
<p>下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PO</span>:            <span class="variable constant_">P1</span>              <span class="variable constant_">P2</span>           <span class="variable constant_">P3</span></span><br><span class="line"><span class="title function_">wait</span>(S)        <span class="title function_">wait</span>(S)         <span class="title function_">wait</span>(S)      <span class="title function_">wait</span>(S)</span><br><span class="line">临界区          临界区           临界区        临界区</span><br><span class="line"><span class="title function_">signal</span>(S)      <span class="title function_">signal</span>(S)       <span class="title function_">signal</span>(S)    <span class="title function_">signal</span>(S)</span><br></pre></td></tr></table></figure>

<p>假设计算机中有两台可用的打印机 A 和 B（也就是说，value &#x3D; 2），有四个进程需要用到打印机资源。</p>
<p>一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始“干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区“干活”。自此，两个打印机都被占用了。</p>
<p>在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 &lt; 0，前面我们说过，value &lt; 0 说明无可用资源，所以此时 P2 将自己<strong>主动</strong>送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。</p>
<p>处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。</p>
<p>当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。</p>
<p>显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常“老实”地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法“既方便了别人，也方便了自己”。这就正好与我们多次强调的“让权等待”非常契合了。</p>
<blockquote>
<p>记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。</p>
</blockquote>
<p>我们通过几道题加深一下印象：</p>
<ul>
<li>n 个并发进程，信号量初始值为 1，当 n 个进程都执行 P 操作后，信号量的值为多少？</li>
<li>信号量初值为 4，多次 PV 操作后变为 -2，那么获得资源的进程数目是多少？</li>
<li>5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？</li>
</ul>
<p>（1）每执行一次 P 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 P 操作，所以此后信号量的值是 1-n</p>
<p>（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源</p>
<p>（3）信号量初始值为3，所以最大值为3，如果 5 个进程都执行 P 操作，那么信号量会变成 3-5 &#x3D; -2，即最小值为 -2，所以取值范围 -2 ~ 3。</p>
<h4 id="信号量机制实现"><a href="#信号量机制实现" class="headerlink" title="信号量机制实现"></a>信号量机制实现</h4><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>其实上面讲的例子就已经很好地实现了进程互斥，但是我们可以简化一下写法，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">P0</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex) <span class="comment">//使用临界资源前需要加锁</span></span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex) <span class="comment">//使用临界资源前需要解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex)</span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们默认已经定义了 semaphore 的结构体，并用<strong>互斥信号量</strong> mutex 记录可用资源的个数（进入临界区的名额），初始值为1。要实现互斥，关键就是要<strong>在临界区之前使用 P 操作进行上锁，在临界区之后使用 V 操作进行解锁</strong>。</p>
<p>PV操作要成对出现，但不一定要在同一个进程中。不同的临界资源设置不同的互斥信号量。记录型信号量有时需要自己定义。</p>
<h5 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h5><p>多个进程（如P1、P2）一起完成某项任务的时候，如何确保它们按照一定的先后顺序（先P1后P2）有秩序地执行呢？信号量机制也可以很好地实现进程同步。它有三个关键步骤：</p>
<ul>
<li>设置<strong>同步信号量</strong>初始值为 0</li>
<li>在“前操作”之后执行 V(S)</li>
<li>在“后操作”之前执行 P(S)</li>
</ul>
<p>首先，<strong>0 是一个非常关键的“分水岭”</strong>，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。</p>
<p>我们要确保“前操作”在前面，“后操作”在后面，实际上只要做到三件事：V 在“前操作”后面、P 在“后操作”前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而<strong>要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0</strong>，因为一旦初始值为 0，则每当 P 想要“违规”抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：</p>
<p><strong>P 先于 V 执行 &#x3D;&#x3D;&#x3D;&gt; P 所在进程会被阻塞 &#x3D;&#x3D;&#x3D;&gt; ”后操作“始终无法执行</strong></p>
<p>所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在“前操作”后面，所以一定是“前操作”执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— <strong>虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞</strong>，所以 P 执行完后就顺序执行“后操作”。由此，我们确保了两个操作一定是严格按照先后顺序执行的。</p>
<p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序应该是：code1,code2,code4</span></span><br><span class="line"><span class="variable constant_">P0</span>：                 <span class="attr">P1</span>:</span><br><span class="line">code <span class="number">1</span>               <span class="title function_">P</span>(S)</span><br><span class="line">code <span class="number">2</span>               code <span class="number">4</span></span><br><span class="line"><span class="title function_">V</span>(S)                 code <span class="number">5</span></span><br><span class="line">code <span class="number">3</span>               code <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>我们设想比较差的情况 —— P1 想要抢先执行 code 4，看看会发生什么。假设是 P1 首先占用处理机，那么就会执行 P 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 P1 进程阻塞；这之后，处理机来到 P0，执行 code1，code2，V 操作，使得信号量由 -1 变成 0，同时唤醒 P1 进程；P1 进程被唤醒后从 P 操作之后的断点继续执行（P1 被唤醒后不会重新再执行一遍P操作，否则会再次进入阻塞。与七态中进程所需资源得到满足后会从阻塞队列转入就绪队列相同，P1 会接着之前停下的地方继续），来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。</p>
<h5 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h5><p>前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code* 语句仍然是前操作或者后操作，P1 进程有 code1 语句，P2 进程有 code2 语句… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092030.png"></p>
<p>其实这种情况就是把多个同步问题结合起来，我们仍然可以用信号量机制来实现：</p>
<ul>
<li>每一个前驱关系都是一个同步问题，要保证一前一后的操作</li>
<li>为每一个前驱关系各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行V操作</li>
<li>在“后操作”之前对相应的同步信号量执行P操作</li>
</ul>
<p>代码大概如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:          <span class="attr">P3</span>:          <span class="attr">P4</span>:        </span><br><span class="line">code1        <span class="title function_">P</span>(signal1)   <span class="title function_">P</span>(signal2)   <span class="title function_">P</span>(signal3)</span><br><span class="line"><span class="title function_">V</span>(signal1)   code2        code3        code4 </span><br><span class="line"><span class="title function_">V</span>(signal2)   <span class="title function_">V</span>(signal3)   <span class="title function_">V</span>(signal7)   <span class="title function_">V</span>(signal5)</span><br><span class="line">             <span class="title function_">V</span>(signal4)</span><br><span class="line"><span class="attr">P5</span>:          <span class="attr">P6</span>:         </span><br><span class="line"><span class="title function_">P</span>(signal4)   <span class="title function_">P</span>(signal5)   </span><br><span class="line">code5        <span class="title function_">P</span>(signal6) </span><br><span class="line"><span class="title function_">V</span>(signal6)   <span class="title function_">P</span>(signal7)</span><br><span class="line">             code6</span><br></pre></td></tr></table></figure>

<p>可以观察到，除了 P1 进程之外，其它进程首先执行的都是 P 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——</p>
<p>假设一开始是 P2 占有处理机，那么由于 signal1 初始为 0，导致了 P2 进队列，此后处理机来到 P3，P3 同样进队列… 以此类推，阻塞队列就会变成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092052.png"></p>
<p>随后总算来到 P1 进程了，P1 进程作为一切的开始，特殊之处就在于它不是以 P 操作开始的，P1 会首先执行 V(signal1)，这一步把 signal1 加一，同时唤醒 P2 进程，P2 进程进入就绪队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092059.png"></p>
<p>再之后，P1 执行 V(signal2)，这一步把 signal2 加一，同时唤醒 P3 进程，P3 进程也进入就绪队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092212.png"></p>
<p>P1 执行完之后，就绪队列队头的 P2 进入运行态，执行到 V(signal3) 的时候，signal3 加一，同时唤醒 P4 进程，P4 进程进入就绪队列，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092320.png"></p>
<p>再之后，P2 执行 V(signal4)，这一步把 signal4 加一，同时唤醒 P5 进程，P5 进程也进入就绪队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092343.png"></p>
<p>P2 执行完之后，处理机调度就绪队列队头的 P3 开始执行，P3 执行到 V(signal7) 的时候，signal7 加一，<strong>注意这一步没有唤醒任何进程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092414.png"></p>
<p>P3 执行完之后，处理机调度就绪队列队头的 P4 开始执行，P4 执行到 V(signal5) 的时候，signal5 加一，同时唤醒 P6 进程，P6 进程进入就绪队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092431.png"></p>
<p>P4 执行完之后，处理机调度就绪队列队头的 P5 开始执行，P5 执行到 V(signal6) 的时候，signal6 加一，<strong>注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092450.png"></p>
<p>P5 执行完之后，处理机调度就绪队列队头的 P6 开始执行，P6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20221017092510.png"></p>
<p>这样基本就把整个流程过了一遍，当然，经过排列组合之后，分析过程都是大同小异的。</p>
<h3 id="信号量和PV操作解决进程同步问题"><a href="#信号量和PV操作解决进程同步问题" class="headerlink" title="信号量和PV操作解决进程同步问题"></a>信号量和PV操作解决进程同步问题</h3><h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者-消费者问题是系统中并发进程内在关系的一种抽象，是典型的进程同步问题。生产者进程P1可以是计算进程、发送进程；而消费者进程P2可以是打印进程、接收进程等等。</p>
<blockquote>
<p>有界缓冲：</p>
<ul>
<li><p>一个生产者一次放入缓冲区一个产品，且无限次循环</p>
</li>
<li><p>一个消费者一次取出缓冲区一个产品，且无限次循环</p>
</li>
<li><p>两个进程独立</p>
</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>缓冲池满生产者不能放产品</li>
<li>缓冲池空消费者不能取产品</li>
<li>只能一个生产者或者消费者对缓冲区进行操作</li>
</ul>
</blockquote>
<p>进程个数：2</p>
<p>关系分析：</p>
<ul>
<li>互斥关系 P1、P2互斥访问缓冲区</li>
<li>同步关系 P1生产后P2才能消费</li>
</ul>
<p>信号量设置：</p>
<ul>
<li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li>
<li>同步信号量<code>empty = n</code> ，表示空闲缓冲区的数量</li>
<li>同步信号量<code>full = 0</code> ，表示非空闲缓冲区的数量，也即产品数量</li>
</ul>
<p>产品： <code>P1 V</code> <code>P2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p>
<p>空间：<code>P1 P</code> <code>P2 V</code></p>
<p>先考虑对互斥关系的实现。这里的临界资源是缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。P1、P2都各有一对 PV 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 PV 操作之前，必定要先生产产品；而消费者在进行 PV 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                              <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                             从缓冲区中取走产品 </span><br><span class="line">		把产品放入缓冲区                       <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">V</span>(mutex)                             使用产品 </span><br><span class="line">    &#125;                                   &#125;</span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>接着考虑第一个同步关系，关注空缓冲区。先释放缓冲区，后使用缓冲区，且缓冲区满不再放入产品，所以这里“前操作”是消费者释放缓冲区，“后操作”是生产者占用缓冲区，根据 “前V后P”，我们需要在“前操作”之后针对 empty 这个信号量进行一次 V 操作，需要在“后操作”之前针对 empty 进行一次 P 操作。生产者执行 P 操作检查是否还有空缓冲区时，若缓冲区已满，将进入阻塞。所以，这时候代码变成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                             <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(empty)                            从缓冲区中取走产品 </span><br><span class="line">		<span class="title function_">P</span>(mutex)                            <span class="title function_">V</span>(mutex)</span><br><span class="line">        把产品放入缓冲区                      <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(mutex)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>再考虑第二个同步关系，关注产品。先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再安排一对 PV 操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(full)</span><br><span class="line">        <span class="title function_">P</span>(empty)                           <span class="title function_">P</span>(mutex)</span><br><span class="line">		<span class="title function_">P</span>(mutex)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>这就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty &#x3D; n，表示所有缓冲区都是空闲的，同时 full &#x3D; 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 <code>P(full)</code> 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 <code>P(empty)</code> 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。</p>
<blockquote>
<p>P 操作不可以随意对调位置，V 操作可以。</p>
</blockquote>
<p><strong>这里要注意可能会引起“死锁”现象的一种写法。如下所示：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                           <span class="title function_">P</span>(full)</span><br><span class="line">		<span class="title function_">P</span>(empty)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>

<p>这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的“上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接“上锁”了，这导致它在 <code>P(full)</code> 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 <code>P(mutex)</code> 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了“死锁”。</p>
<p>另一种情况，我们也可以设想一开始处理机是在 producer 这里，依然会导致“死锁”。按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 <code>P(empty)</code> 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 <code>P(mutex)</code> 这一步陷入等待。也就是说，这不过是前面那种”死锁“现象的翻版。</p>
<p><strong>总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。</strong></p>
<h4 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h4><p>盘子 缓冲区</p>
<p>2水果 2产品</p>
<p>爸爸 妈妈 2生产者，P1 P2</p>
<p>儿子 女儿 2消费者，C1 C2</p>
<p>进程个数：4</p>
<p>关系分析：</p>
<ul>
<li>互斥关系 P1、P2、C1、C2互斥访问缓冲区</li>
<li>同步关系 P1生产后C1才能消费，P2生产后C2才能消费</li>
</ul>
<p>信号量设置：</p>
<ul>
<li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li>
<li>同步信号量<code>apple = 0</code> ，表示苹果的数量</li>
<li>同步信号量<code>orange = 0</code> ，表示橘子的数量</li>
</ul>
<p>产品： <code>P1 P2 V</code> <code>C1 C2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p>
<p>空间：<code>P1 P2 P</code> <code>C1 C2 V</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把苹果放入盘子</span><br><span class="line">      <span class="title function_">V</span>(apple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把橘子放入盘子</span><br><span class="line">      <span class="title function_">V</span>(orange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">C1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(apple)</span><br><span class="line">       从盘子中取走苹果</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="title function_">C2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(orange)</span><br><span class="line">       从盘子中取走橘子</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="银行问题"><a href="#银行问题" class="headerlink" title="银行问题"></a>银行问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221024_140725.jpg" alt="IMG_20221024_140725"></p>
<p>顾客的 V(full) 与 P(service) 应调换位置，并去除“获取服务”</p>
<p>service 默认值应为1</p>
<h4 id="五个哲学家进餐问题"><a href="#五个哲学家进餐问题" class="headerlink" title="五个哲学家进餐问题"></a>五个哲学家进餐问题</h4><p>一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：<strong>保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118204800390.png" alt="image-20221118204800390"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221024_145433.jpg"></p>
<p>如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么 1 号是会被阻塞的，所以这样相邻的哲学家中有一个可以吃饭。但是，如果 0 号拿起左筷子后进程切换到 1 号， 1 号也拿起自己的左筷子，以此类推，所有的哲学家都只有左筷子，这导致了所有的哲学家都被阻塞，没有任何哲学家能够吃饭，也没有人可以释放筷子，使这些哲学家都陷入无限的等待中，造成“死锁”的发生。</p>
<p>解决这个问题有三个方法：</p>
<h5 id="实现原子操作"><a href="#实现原子操作" class="headerlink" title="实现原子操作"></a>实现原子操作</h5><p>很容易想到，拿起左筷子和拿起右筷子并不是一个原子操作。准备一个互斥信号量 <code>mutex = 1</code> ，并把拿筷子的操作封装在一个 PV 操作里。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 0 号哲学家拿起左筷子之后，即使发生进程切换， 1 号进程也会被卡在 <code>mutex</code> 的 P 操作，被送往阻塞队列，其它进程也同理。所以最后再次来到 0 号进程时便可以顺利拿起右筷子。这种做法保证了有一个哲学家是可以吃饭的。</p>
<blockquote>
<p>这里涉及到了<strong>一个进程需要一次性两个资源才能完成任务</strong>的问题，也可以使用 AND 信号量集机制。AND 信号量集机制的 P 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到。一开始筷子数量足够，所以 0 号在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title class_">Swait</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title class_">Ssignal</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="只有四个人参与这个过程"><a href="#只有四个人参与这个过程" class="headerlink" title="只有四个人参与这个过程"></a>只有四个人参与这个过程</h5><p>之前的情况是五个哲学家，五支筷子，所以容易出现谁也无法吃饭的情况，但是如果规定整个过程最多只有四个哲学家参与，即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。</p>
<p>如何限定“最多四个人可以参与这个过程”呢？准备一个互斥信号量 <code>count</code>，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 <code>count</code> 减少到 -1 的时候，就不能再让哲学家进来了。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(count)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来演示前面发生“死锁”的过程。假如从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 <code>count</code> 数量充足，所以它不会阻塞，而是同样拿到了左筷子…以此类推，到了 4 号哲学家的时候，由于 <code>count = -1 &lt; 0</code>，所以它此时无法进来。 4 号哲学家左边的筷子在第一轮谁也没拿到，第二轮轮到 3 号哲学家时，就可以拿到这支筷子了。总会存在至少一个进程可以吃到饭。</p>
<h5 id="奇数拿左边，偶数拿右边"><a href="#奇数拿左边，偶数拿右边" class="headerlink" title="奇数拿左边，偶数拿右边"></a>奇数拿左边，偶数拿右边</h5><p>还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118205737280.png" alt="image-20221118205737280"></p>
<p>伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">eat</span>();</span><br><span class="line">			<span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>   <span class="comment">//奇数哲学家，先左后右。</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			<span class="title function_">eat</span>();</span><br><span class="line">			<span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line">			<span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。</p>
<p>这只是其中一种情况，但无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，因此这个“被淘汰的”进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子“淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote>
<p>信号量机制效率低，且通信对用户不透明</p>
</blockquote>
<h4 id="管程的基本思想"><a href="#管程的基本思想" class="headerlink" title="管程的基本思想"></a>管程的基本思想</h4><p>管程&#x3D;共享资源+同步操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221024_150901.jpg"></p>
<p>进入管程无法直接访问临界资源，而是通过管程的方法来访问临界资源：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221024_151827.jpg"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的概念"><a href="#进程通信的概念" class="headerlink" title="进程通信的概念"></a>进程通信的概念</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_135843.jpg" alt="IMG_20221031_135843"></p>
<p>任何时候都不能直接访问临界资源</p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>共享空间是临界区，P1和P2互斥访问（PV操作）</p>
<p>共享方式上，共享存储分为基于数据结构的共享（较为低级，速度慢限制多，例如开辟一个数组）和基于存储区的共享（高级通信方式，速度快，在内存中划出一块共享存储区，数据结构和存放位置都由进程控制，而不是OS）</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_140352.jpg" alt="IMG_20221031_140352"></p>
<p>从P2传回给P1时，必须再开辟一个管道，以实现全双工。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><a href="#%E5%86%85%E6%A0%B8">回顾第一章消息传递等通信方式</a></p>
<blockquote>
<h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。</p>
<h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="引入线程"><a href="#引入线程" class="headerlink" title="引入线程"></a>引入线程</h3><p>首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程<strong>既是一个携带资源的独立单位，也是独立调度的基本单位</strong>，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。</p>
<p>如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的<strong>线程</strong>了。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p><strong>调度的基本单位</strong></p>
<p>引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。</p>
<p><strong>执行的基本单位</strong></p>
<p>我们可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。但我们不能说“挂起线程”，只能说“挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程”没有意义。</p>
<p><strong>并发性</strong></p>
<p>进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。</p>
<p><strong>资源</strong></p>
<p>资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。虽然线程不携带资源，但它可以使用fork的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。</p>
<p><strong>系统开销</strong></p>
<p>在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。</p>
<blockquote>
<p><strong>独立性</strong></p>
<p>同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。</p>
<p><strong>支持多处理机系统</strong></p>
<p>传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。</p>
</blockquote>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_145313.jpg" alt="IMG_20221031_145313"></p>
<h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><p>作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是根据某种算法从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。</p>
<p>这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_150025.jpg" alt="IMG_20221031_150025"></p>
</blockquote>
<h4 id="内存调度"><a href="#内存调度" class="headerlink" title="内存调度"></a>内存调度</h4><p>内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存（虚拟内存）中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。引入中级调度的主要目的是提高内存利用率和系统吞吐量，它实际上就是存储器管理中的对换功能。</p>
<p>这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程（内核级线程），分配处理机给它。进程调度是最基本、次数最频繁的阶段。</p>
<p>这个阶段进程的状态变化是： 就绪态 –&gt; 活动态</p>
<blockquote>
<p>根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：非抢占式和抢占式，为抢占式时，抢占原则有：优先权原则、短作业（进程）优先原则、时间片原则。</p>
<p>抢占式的缺点在于进程切换频繁发生，系统开销大。优点在于对短作业而言能更及时的得到调度。</p>
</blockquote>
<h2 id="队列调度模型"><a href="#队列调度模型" class="headerlink" title="队列调度模型"></a>队列调度模型</h2><h3 id="仅有进程调度的队列模型"><a href="#仅有进程调度的队列模型" class="headerlink" title="仅有进程调度的队列模型"></a>仅有进程调度的队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_151833.jpg" alt="IMG_20221031_151833"></p>
<p>分时操作系统没有后备作业队列，所以没有高级调度；又因为此系统的应用范围大多只是查询，分配的任务比较简单，以时间片轮转的方式执行终端的任务，所以没有中级调度。也即分时操作系统只有低级调度。</p>
<h3 id="具有高级调度和低级调度的调度队列模型"><a href="#具有高级调度和低级调度的调度队列模型" class="headerlink" title="具有高级调度和低级调度的调度队列模型"></a>具有高级调度和低级调度的调度队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_152200.jpg" alt="IMG_20221031_152200"></p>
<p>看到这张图，要想到<a href="#%E4%BA%94%E6%80%81">五态转换</a></p>
<h3 id="具有三级调度的调度队列模型"><a href="#具有三级调度的调度队列模型" class="headerlink" title="具有三级调度的调度队列模型"></a>具有三级调度的调度队列模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221031_152456.jpg" alt="IMG_20221031_152456"></p>
<p>看到这张图，要想到<a href="#%E4%B8%83%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E4%BC%9A%E6%9C%89%E6%89%80%E6%8B%93%E5%B1%95%EF%BC%89">七态转换</a></p>
<h2 id="选择调度算法的原则"><a href="#选择调度算法的原则" class="headerlink" title="选择调度算法的原则"></a>选择调度算法的原则</h2><h3 id="面向用户的准则"><a href="#面向用户的准则" class="headerlink" title="面向用户的准则"></a>面向用户的准则</h3><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>面向批处理OS</p>
<p><strong>周转时间：</strong><code>作业完成时刻 - 作业提交时刻 = 作业实际运行的时间 + 等待时间</code></p>
<blockquote>
<p><strong>等待时间</strong>包括在后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、等待I&#x2F;O操作完成的时间。<strong>作业实际运行的时间</strong>即进程在CPU上执行的时间。<strong>周转时间</strong>是衡量批处理OS性能的重要指标。</p>
</blockquote>
<p><strong>平均周转时间：</strong> <code>各作业周转时间之和 / 作业数</code></p>
<p><strong>带权周转时间：</strong><code>周转时间 / 作业实际运行的时间</code>（≥1，比周转时间更能衡量一个调度算法的优劣）</p>
<p><strong>平均带权周转时间：</strong><code>各作业带权周转时间之和 / 作业数</code></p>
<h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>面向分时OS</p>
<p><strong>响应时间：</strong>从用户提交请求到首次产生响应所用的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔。包括从键盘输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间、将所形成的响应时间回送到终端显示器的时间。</p>
<h4 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h4><p>面向实时OS</p>
<p><strong>截止时间：</strong>指某任务必须开始执行的最迟时间，或必须完成的最迟时间</p>
<h4 id="优先权准则"><a href="#优先权准则" class="headerlink" title="优先权准则"></a>优先权准则</h4><h3 id="面向系统的准则"><a href="#面向系统的准则" class="headerlink" title="面向系统的准则"></a>面向系统的准则</h3><p><strong>系统吞吐量：</strong><code>完成作业量 / 总时间</code></p>
<p><strong>CPU 利用率：</strong><code>忙碌的时间 / 总时间</code></p>
<p><strong>公平性：</strong>确保每个用户每个进程获得合理的CPU份额，不会出现饿死情况。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS-调度算法（作业调度-进程调度）"><a href="#先来先服务-FCFS-调度算法（作业调度-进程调度）" class="headerlink" title="先来先服务(FCFS)调度算法（作业调度+进程调度）"></a>先来先服务(FCFS)调度算法（作业调度+进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221107_142009.jpg" alt="IMG_20221107_142009"></p>
<blockquote>
<p>周转时间&#x3D;完成时间-到达时间</p>
<p>带权周转时间&#x3D;周转时间&#x2F;服务时间</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221107_143022.jpg" alt="IMG_20221107_143022"></p>
<p>FCFS算法对长作业（CPU时间长的作业）有利，对短作业不利。</p>
<h3 id="最短作业-SJF-调度算法（作业调度-进程调度）"><a href="#最短作业-SJF-调度算法（作业调度-进程调度）" class="headerlink" title="最短作业(SJF)调度算法（作业调度+进程调度）"></a>最短作业(SJF)调度算法（作业调度+进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221107_144647.jpg" alt="IMG_20221107_144647"></p>
<p>对这个情况而言，SJF比FCFS更好，尤其是C。</p>
<p>SJF调度算法也存在不容忽视的缺点：</p>
<ul>
<li><p>该算法对长作业不利，更严重的是，如果有一长作业（进程）进入系统的后备队列（就绪队列），由于调度程序总是优先调度那些（即使是后进来的）短作业（进程），将导致长作业（进程）长期不被调度。</p>
</li>
<li><p>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理。</p>
</li>
<li><p>由于作业（进程）的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</p>
</li>
</ul>
<h3 id="高响应比优先-HRRN-调度算法（作业调度-进程调度）"><a href="#高响应比优先-HRRN-调度算法（作业调度-进程调度）" class="headerlink" title="高响应比优先(HRRN)调度算法（作业调度+进程调度）"></a>高响应比优先(HRRN)调度算法（作业调度+进程调度）</h3><blockquote>
<p>HRRN (Highest Response Ratio Next) &#x3D; HRRF (Highest Response Ratio First)</p>
<p>NUIST老师习惯用HRRF，我觉得HRRN更合适</p>
</blockquote>
<p>FCFS与SJF是片面的调度算法。FCFS只考虑作业等候时间而忽视了作业的计算时间问题；SJF只考虑用户估计的作业计算时间而忽视了作业等待时间。</p>
<p>HRRN是介乎这两者之间的非剥夺式算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。</p>
<p><strong>响应比</strong>（带权周转时间） &#x3D; 作业周转时间 &#x2F; 作业处理时间 &#x3D; （作业等待时间+作业处理时间） &#x2F; 作业处理时间 &#x3D; <strong>1 + 作业等待时间 &#x2F; 作业处理时间</strong></p>
<ul>
<li>短作业容易得到较高响应比（分母小）</li>
<li>长作业等待时间足够长后，也将获得足够高的响应比（分子足够大）</li>
<li>饥饿现象不会发生</li>
</ul>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221107_150432.jpg" alt="IMG_20221107_150432"></p>
<p>首先调度J1，然后计算响应比：</p>
<p>J2 1+15&#x2F;15&#x3D;2</p>
<p>J3 1+10&#x2F;5&#x3D;3</p>
<p>J4 1+5&#x2F;10&#x3D;1.5</p>
<p>J3的响应比最大，调度J3。随后计算J3完成后的响应比：</p>
<p>t&#x3D;20+5</p>
<p>J2 1+20&#x2F;15&#x3D;2.3</p>
<p>J4 1+10&#x2F;10&#x3D;2</p>
<p>所以调用J2，最后调用J4。</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221107_152959.jpg" alt="IMG_20221107_152959"></p>
<p>FCFS J1 2 3 4</p>
<p>8 10 2 1</p>
<p>10 10.5 1.5+1&#x2F;6 (1.5+1&#x2F;6)&#x2F;0.5&#x3D;3.3</p>
<p>10.5 10.6 1.6 1.6&#x2F;0.1&#x3D;16</p>
<p>10.6 10.8 0.8+2&#x2F;3 (0.8+2&#x2F;3)&#x2F;0.2&#x3D;7.3</p>
<p>(2+1.5+1&#x2F;6+1.6+0.8+2&#x2F;3)&#x2F;4&#x3D;1.68</p>
<p>(1+(1.5+1&#x2F;6)&#x2F;0.5+1.6&#x2F;0.1+(0.8+2&#x2F;3)&#x2F;0.2)&#x2F;4&#x3D;6.92</p>
<p>SJF J1 3 4 2</p>
<p>8 10 2 1</p>
<p>10.3 10.8 1.8+1&#x2F;6 (1.8+1&#x2F;6)&#x2F;0.5&#x3D;3.93</p>
<p>10 10.1 1.1 1.1&#x2F;0.1&#x3D;11</p>
<p>10.1 10.3 0.3+2&#x2F;3 (0.3+2&#x2F;3)&#x2F;0.2&#x3D;4.83</p>
<p>(2+1.8+1&#x2F;6+1.1+0.3+2&#x2F;3)&#x2F;4&#x3D;1.51</p>
<p>(1+(1.8+1&#x2F;6)&#x2F;0.5+1.1&#x2F;0.1+(0.3+2&#x2F;3)&#x2F;0.2)&#x2F;4&#x3D;5.19</p>
<p>HRRF J1 </p>
<p>8 10 2 1</p>
<p>(10) J2 未完成</p>
<h3 id="高优先权-FPF-调度算法（作业调度-进程调度）"><a href="#高优先权-FPF-调度算法（作业调度-进程调度）" class="headerlink" title="高优先权(FPF)调度算法（作业调度+进程调度）"></a>高优先权(FPF)调度算法（作业调度+进程调度）</h3><h4 id="非抢占式优先权算法"><a href="#非抢占式优先权算法" class="headerlink" title="非抢占式优先权算法"></a>非抢占式优先权算法</h4><p>和 HRRN 算法很像，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。</p>
<h4 id="抢占式优先权算法"><a href="#抢占式优先权算法" class="headerlink" title="抢占式优先权算法"></a>抢占式优先权算法</h4><p>除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。</p>
<h4 id="静态优先权"><a href="#静态优先权" class="headerlink" title="静态优先权"></a>静态优先权</h4><p>静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变。一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；I&#x2F;O 型进程优先级会比较高。</p>
<h4 id="动态优先权"><a href="#动态优先权" class="headerlink" title="动态优先权"></a>动态优先权</h4><p>动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直“霸占”处理机了。另外，之前说过 I&#x2F;O 型进程的优先级会很高，所以如果某个进程频繁进行 I&#x2F;O 操作，也可以考虑提高它的优先级。</p>
<p>优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 HRRN 算法也是很像的。（其实也可以把 HRRN 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）</p>
<h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221114_141012.jpg" alt="IMG_20221114_141012"></p>
<p>可剥夺：</p>
<p>开始执行时间:进程 0:P1 3:P2 5:P3 10:P4 20:P3 21:P1 23:DONE</p>
<p>进程 周转时间 带权周转时间</p>
<p>P1 23-0&#x3D;23 23&#x2F;5&#x3D;4.6</p>
<p>P2 5-3&#x3D;2 2&#x2F;2&#x3D;1</p>
<p>P3 21-5&#x3D;16 16&#x2F;6&#x3D;2.67</p>
<p>P4 20-10&#x3D;10 10&#x2F;10&#x3D;1</p>
<p>平均周转时间：12.75</p>
<p>带权周转时间：2.32</p>
<h3 id="时间片轮转-RR-调度算法（进程调度）"><a href="#时间片轮转-RR-调度算法（进程调度）" class="headerlink" title="时间片轮转(RR)调度算法（进程调度）"></a>时间片轮转(RR)调度算法（进程调度）</h3><p>RR 算法的特点则在于“公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出“交替”的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。</p>
<blockquote>
<p>答题需表格+执行顺序时间线</p>
</blockquote>
<h4 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221114_151836.jpg" alt="IMG_20221114_151836"></p>
<p>开始执行时间:进程(剩余时间)：0:P1(33) 20:P2(0) 37:P3(48) 57:P4(4) 77:P1(13) 97:P3(28) 117:P4(0) 121:P1(0)  134:P3(8) 154:P3(0) 162:DONE</p>
<p>P1 134 134&#x2F;50</p>
<p>P2 17 17&#x2F;17</p>
<p>P3 162 162&#x2F;68</p>
<p>P4 121 121&#x2F;24</p>
<p>平均周转时间：108.5</p>
<p>带权平均周转时间：2.78</p>
<h3 id="多级反馈调度算法（进程调度）"><a href="#多级反馈调度算法（进程调度）" class="headerlink" title="多级反馈调度算法（进程调度）"></a>多级反馈调度算法（进程调度）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221114_142817.jpg" alt="IMG_20221114_142817"></p>
<ul>
<li>有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾</li>
<li>当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度</li>
<li>关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>对各类型进程相对公平（FCFS 的优点）：谁先进来，谁就会处于高级队列，优先得到服务</li>
<li>每个新到达的进程都可以很快就得到响应（RR 的优点）：新到达的进程首先在高级队列，可以很快得到响应</li>
<li>短进程只用较少的时间就可完成（SPF 的优点）：不需要经历过多的队列</li>
<li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I&#x2F;O 密集型进程（拓展：可以将因 I&#x2F;O 而阻塞的进程重新放回原队列，这样 I&#x2F;O 型进程就可以保持较高优先级）</li>
<li>对各类型用户友好。对于<strong>终端型用户</strong>来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对<strong>短批处理作业用户</strong>来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对<strong>长批处理作业用户</strong>来说，只要让作业依次在第 1, 2，… n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。</li>
</ul>
<h4 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1"></a>例题1</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221114_145035.jpg" alt="IMG_20221114_145035"></p>
<blockquote>
<p>D就绪队列2有误</p>
</blockquote>
<h4 id="例题2（只有3个就绪队列的例题1）"><a href="#例题2（只有3个就绪队列的例题1）" class="headerlink" title="例题2（只有3个就绪队列的例题1）"></a>例题2（只有3个就绪队列的例题1）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221114150810280.png" alt="image-20221114150810280"></p>
<p>A 2-0&#x3D;2 2&#x2F;2</p>
<p>B 22-2&#x3D;20 20&#x2F;6</p>
<p>C 58-4&#x3D;54 54&#x2F;10</p>
<p>D 66-6&#x3D;60 60&#x2F;14</p>
<p>E 110-8&#x3D;102 102&#x2F;18</p>
<p>F 118-10&#x3D;108 108&#x2F;22</p>
<p>G 146-12&#x3D;134 134&#x2F;26</p>
<p>H 154-14&#x3D;140 140&#x2F;30</p>
<p>I 166-16&#x3D;150 150&#x2F;34</p>
<p>平均周转时间：85.56</p>
<p>带权平均周转时间：4.31</p>
<p>平均周转时间&#x3D;结束时间-开始时间 ×，平均周转时间&#x3D;结束时间-到达时间 √；若没有给到达时间，则默认所有任务一开始就同时到达。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="出现死锁的场景"><a href="#出现死锁的场景" class="headerlink" title="出现死锁的场景"></a>出现死锁的场景</h3><h4 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221117_102117.jpg" alt="IMG_20221117_102117"></p>
<h4 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221117_102345.jpg" alt="IMG_20221117_102345"></p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。</p>
<h4 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h4><p>一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。</p>
<h4 id="请求和占有"><a href="#请求和占有" class="headerlink" title="请求和占有"></a>请求和占有</h4><p>申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure>

<p>如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。</p>
<p>换一种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure>

<p>如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是<strong>是在不占有资源的情况下阻塞的</strong>，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。</p>
<h4 id="环路循环等待"><a href="#环路循环等待" class="headerlink" title="环路循环等待"></a>环路循环等待</h4><p>要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。</p>
<p>[P0，P1，P2，…Pn]中的P0正在等待P1占用的资源，P1正在等待P2占用的资源……Pn正在等待P0占用的资源。</p>
<p>发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。</p>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低</p>
<h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。</p>
<h4 id="破坏非抢占条件"><a href="#破坏非抢占条件" class="headerlink" title="破坏非抢占条件"></a>破坏非抢占条件</h4><p>如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：</p>
<ul>
<li>从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请</li>
<li>从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。</li>
</ul>
<p>这种做法的问题在于：</p>
<ul>
<li>实现起来复杂</li>
<li>某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失</li>
<li>反复的申请和释放资源会增加系统开销</li>
<li>可能导致饥饿</li>
</ul>
<h4 id="破坏“请求和占有”条件"><a href="#破坏“请求和占有”条件" class="headerlink" title="破坏“请求和占有”条件"></a>破坏“请求和占有”条件</h4><p>所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。</p>
<p>该方法可能导致饥饿现象。若有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，如果 AB 源源不断进入就绪队列，那么 C 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。</p>
<h4 id="破坏“环路循环等待”条件"><a href="#破坏“环路循环等待”条件" class="headerlink" title="破坏“环路循环等待”条件"></a>破坏“环路循环等待”条件</h4><p>将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。</p>
<p>优点：和前两种相比，资源利用率和吞吐量利用率高</p>
<p>缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。</p>
<p>以之前的例子讲解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure>

<p>这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure>

<p>实际上，这里除了破坏“占有和请求条件”之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。</p>
<p>也可以拿之前的<a href="#%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98">哲学家进餐问题</a>解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走， 4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。</p>
<p>还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。</p>
<blockquote>
<p>但这种预防死锁的方法，问题在于：</p>
<ul>
<li>如何进行编号，从什么角度考虑？</li>
<li>如果增加资源或设备，怎么重新编号？</li>
<li>虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。</li>
</ul>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全状态：指系统按某种顺序(P1,P2,…,Pn)(称&lt;P1,P2,…,Pn&gt;为安全序列)来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
<p>避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p>
<p>安全状态之例：假定系统中有三个进程P1、P2和P3,共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3分别获得5台、2台和2台，尚有3台未分配，如下表所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221117_111227.jpg" alt="IMG_20221117_111227"></p>
<h4 id="简化资源分配图"><a href="#简化资源分配图" class="headerlink" title="简化资源分配图"></a>简化资源分配图</h4><p>当各类资源都<strong>只有一个</strong>的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118230915805.png" alt="image-20221118230915805"></p>
<ul>
<li>如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。</li>
<li>如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221117_105216.jpg" alt="IMG_20221117_105216"></p>
<p><strong>死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。</strong></p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li><p>银行家拥有一笔周转资金</p>
</li>
<li><p>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷</p>
</li>
<li><p>银行家应谨慎的贷款，防止出现坏帐</p>
</li>
</ul>
<h5 id="银行家算法案例"><a href="#银行家算法案例" class="headerlink" title="银行家算法案例"></a>银行家算法案例</h5><p>设银行家有10万贷款，P,Q,R分别需要8,3,9万元搞项目（假设任何人满足资金总额后都会归还所有贷款)</p>
<p>如果P已申请到了4万：</p>
<ul>
<li><p>Q要申请2万，显然，如果满足Q的申请，有安全序列&lt;P,Q,R&gt;&#x2F;&lt;Q,P,R&gt;</p>
</li>
<li><p>R要申请4万，显然，如果满足R的申请，则不存在安全序列。</p>
</li>
</ul>
<p><strong>基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。</strong></p>
<h5 id="银行家算法过程"><a href="#银行家算法过程" class="headerlink" title="银行家算法过程"></a>银行家算法过程</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118233726331.png"></p>
<p>假设系统中有 n 个进程，m 种资源，规定：</p>
<ul>
<li>每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 <code>Max</code> 表示各个进程的需求情况，比如 <code>Max[i][j]= K</code> 就表示进程 i 需要 K 个 j 类型资源</li>
<li>用一个 n*m 的分配矩阵 <code>Allocation</code> 表示各个进程的已分配资源情况</li>
<li>用一个 n*m 的需求矩阵 <code>Need</code> 表示各个进程的最多还需要资源情况，<code>Need = Max - Allocation</code></li>
<li>用一个 m 长度的一维数组 <code>Avaliable</code> 表示剩余资源数目</li>
<li>用一个 m 长度的一维数组 <code>Request_i</code> 表示某个进程 i 某次申请的资源数目</li>
</ul>
<p>按照之前说过的流程图，银行家算法的工作过程是：</p>
<ul>
<li>请求资源数是否超过最大资源数？<code>Request_i[j]&lt;=Need[i][j]</code>，则到下一步；否则出错</li>
<li>请求资源数是否超过剩余资源数？<code>Request_i[j]&lt;=Available[j]</code>，则到下一步；否则说明资源不够，进程等待</li>
<li>尝试进行资源分配。<ul>
<li>剩余资源减少：<code>Available = Available - Request</code></li>
<li>已分配资源增加：<code>Allocation[i][j] = Allocation[i][j] + Request_i[j]</code></li>
<li>需求资源减少：<code>Need[i][j] = Need[i][j] - Request_i[j]</code></li>
</ul>
</li>
<li>对分配后的状态通过安全性算法进行预判：<ul>
<li>安全状态：不会发生死锁，可以分配资源</li>
<li>不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态</li>
</ul>
</li>
</ul>
<h5 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1"></a>例题1</h5><p>假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118232822744.png" alt="image-20221118232822744"></p>
<p>如何检测当前是否处于安全状态呢？尝试寻找安全序列：</p>
<ul>
<li>当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。</li>
<li>P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）&#x3D;（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列</li>
<li>所以存在安全序列 <code>P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4</code> ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。</li>
</ul>
<p>看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20221118232808706.png" alt="image-20221118232808706"></p>
<p>当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。</p>
<h5 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h5><p>t0时刻安全状态检查。如果t0时刻都不安全，则后面的部分都不用做了。但是考试时t0都是安全的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221117_114149.jpg" alt="IMG_20221117_114149"></p>
<p>安全序列之一：&lt;p1,p3,p4,p2,p0&gt;</p>
<h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>(1)如果<a href="#%E7%AE%80%E5%8C%96%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE">进程-资源分配图</a>中无环路，则此时系统没有发生死锁。</p>
<p>(2)如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。</p>
<p>(3)如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pil0txia.com">Pil0tXia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pil0txia.com/post/2022-09-08_os-notes/">https://pil0txia.com/post/2022-09-08_os-notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pil0txia.com" target="_blank">Pil0tXia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%AC%E7%A7%91CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">本科CS课程笔记</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A/">大三上</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2022-09-13_assembler-language-notes/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220913160311958.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">汇编语言程序设计笔记</div></div></a></div><div class="next-post pull-right"><a href="/post/2022-06-20_ai-introductory-theory-notes/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220621130226727.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">人工智能重点题目整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2022-09-13_assembler-language-notes/" title="汇编语言程序设计笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220913160311958.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-13</div><div class="title">汇编语言程序设计笔记</div></div></a></div><div><a href="/post/2022-09-19_python-notes/" title="Python程序设计学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220919110722606.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-19</div><div class="title">Python程序设计学习笔记</div></div></a></div><div><a href="/post/2022-02-21_DBMS-notes/" title="数据库系统笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/QQ%E5%9B%BE%E7%89%8720220228114653.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">数据库系统笔记</div></div></a></div><div><a href="/post/2022-03-17_Computer-Organization-and-Architecture-notes/" title="计算机组成与系统结构笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/cover/157917931_280152366963718_6400725182258147228_n.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-17</div><div class="title">计算机组成与系统结构笔记</div></div></a></div><div><a href="/post/2022-03-18_computer-networks-notes/" title="计算机网络笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/1996208-20200416224258894-1241589285.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">计算机网络笔记</div></div></a></div><div><a href="/post/2022-06-20_ai-introductory-theory-notes/" title="人工智能重点题目整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220621130226727.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-20</div><div class="title">人工智能重点题目整理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/me/03_3_tinypng.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Pil0tXia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" href="mailto:admin@pil0txia.com"><i class="fas fa-envelope"></i><span>Contact Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Pil0tXia" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/286768851/" rel="external nofollow noreferrer" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://user.qzone.qq.com/1837713753/main" rel="external nofollow noreferrer" target="_blank" title="Photography"><i class="fa-solid fa-camera"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不会摄影的白帽子不是好机长！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">单道批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">多道批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">并发与并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.</span> <span class="toc-text">分时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">操作系统的四个基础特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3OS%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">1.7.</span> <span class="toc-text">现代OS的基本单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A1"><span class="toc-number">1.8.</span> <span class="toc-text">作业1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">1.9.</span> <span class="toc-text">内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.</span> <span class="toc-text">中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">系统调用的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.2.</span> <span class="toc-text">系统调用与库函数的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8"><span class="toc-number">1.12.</span> <span class="toc-text">冷启动和热启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%B5%84%E6%96%99"><span class="toc-number">1.13.</span> <span class="toc-text">补充资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A2%EF%BC%88%E4%B9%A6%E9%9D%A2%E7%89%88%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%A6%82%E6%8B%AC%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">作业2（书面版进行了概括）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%A8%80"><span class="toc-number">1.15.</span> <span class="toc-text">附言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">程序的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">为什么程序不能调度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">判断程序是否可以并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程控制块PCB的组织方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">2.3.</span> <span class="toc-text">作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.1.</span> <span class="toc-text">进程的状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%80%81"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">三态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E6%80%81"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">五态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E4%BC%9A%E6%9C%89%E6%89%80%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">七态（重要，在后面的章节会有所拓展）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%AD%A2%E9%98%BB%E5%A1%9E-x2F-%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.1.3.1.</span> <span class="toc-text">静止阻塞&#x2F;就绪队列的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.3.2.</span> <span class="toc-text">挂起的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.1.3.3.</span> <span class="toc-text">挂起的特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%B1%87%E6%80%BB"><span class="toc-number">2.4.1.3.4.</span> <span class="toc-text">状态转换的汇总</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">进程的创建（创建原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">进程的终止（撤销原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%EF%BC%88%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%ADblock%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">进程的阻塞（阻塞原语block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92%EF%BC%88%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%ADwake-up%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">进程的唤醒（唤醒原语wake up）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%88%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-number">2.4.6.</span> <span class="toc-text">进程的切换（切换原语）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%EF%BC%88%E6%8C%82%E8%B5%B7%E5%8E%9F%E8%AF%ADsuspend%E5%92%8C%E6%BF%80%E6%B4%BB%E5%8E%9F%E8%AF%ADactive%EF%BC%89"><span class="toc-number">2.4.7.</span> <span class="toc-text">进程的挂起（挂起原语suspend和激活原语active）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.5.</span> <span class="toc-text">进程的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.6.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">进程互斥的基本实现逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">同步机制应遵循的原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CPV%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.2.</span> <span class="toc-text">信号量和PV操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.2.1.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.2.1.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">信号量机制实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.6.2.2.1.</span> <span class="toc-text">进程互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-number">2.6.2.2.2.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.2.2.3.</span> <span class="toc-text">前驱关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CPV%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">信号量和PV操作解决进程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">生产者-消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%B9%E6%9E%9C%E6%A9%98%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">苹果橘子问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.3.</span> <span class="toc-text">银行问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.4.</span> <span class="toc-text">五个哲学家进餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.3.4.1.</span> <span class="toc-text">实现原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E5%9B%9B%E4%B8%AA%E4%BA%BA%E5%8F%82%E4%B8%8E%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.6.3.4.2.</span> <span class="toc-text">只有四个人参与这个过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E6%8B%BF%E5%B7%A6%E8%BE%B9%EF%BC%8C%E5%81%B6%E6%95%B0%E6%8B%BF%E5%8F%B3%E8%BE%B9"><span class="toc-number">2.6.3.4.3.</span> <span class="toc-text">奇数拿左边，偶数拿右边</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.6.4.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">管程的基本思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">进程通信的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.7.4.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">直接通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">间接通信方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">引入线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">线程与进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.3.</span> <span class="toc-text">线程的状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.</span> <span class="toc-text">处理机调度的层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">三级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">作业调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">内存调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">进程调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">队列调度模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%85%E6%9C%89%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">仅有进程调度的队列模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">具有高级调度和低级调度的调度队列模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">具有三级调度的调度队列模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">选择调度算法的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.3.1.</span> <span class="toc-text">面向用户的准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">周转时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">响应时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">截止时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83%E5%87%86%E5%88%99"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">优先权准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">面向系统的准则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">先来先服务(FCFS)调度算法（作业调度+进程调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">最短作业(SJF)调度算法（作业调度+进程调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.3.</span> <span class="toc-text">高响应比优先(HRRN)调度算法（作业调度+进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83-FPF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.4.</span> <span class="toc-text">高优先权(FPF)调度算法（作业调度+进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">非抢占式优先权算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">抢占式优先权算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">静态优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">动态优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-1"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">例题1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-RR-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.5.</span> <span class="toc-text">时间片轮转(RR)调度算法（进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-2"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">例题1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">3.4.6.</span> <span class="toc-text">多级反馈调度算法（进程调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-3"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%88%E5%8F%AA%E6%9C%893%E4%B8%AA%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E7%9A%84%E4%BE%8B%E9%A2%981%EF%BC%89"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">例题2（只有3个就绪队列的例题1）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.1.</span> <span class="toc-text">出现死锁的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A8%E8%BF%9B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%BD%93"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">进程推进顺序不当</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">资源竞争</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.2.</span> <span class="toc-text">产生死锁的四个必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">非抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%8D%A0%E6%9C%89"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">请求和占有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E8%B7%AF%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">环路循环等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.3.</span> <span class="toc-text">预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">破坏非抢占条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E2%80%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%8D%A0%E6%9C%89%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">破坏“请求和占有”条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E2%80%9C%E7%8E%AF%E8%B7%AF%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">破坏“环路循环等待”条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.4.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">简化资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A1%88%E4%BE%8B"><span class="toc-number">3.5.4.2.1.</span> <span class="toc-text">银行家算法案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.4.2.2.</span> <span class="toc-text">银行家算法过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-4"><span class="toc-number">3.5.4.2.3.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-1"><span class="toc-number">3.5.4.2.4.</span> <span class="toc-text">例题2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.5.</span> <span class="toc-text">检测死锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10_why-python36-dict-is-ordered/" title="为什么Python 3.6以后字典有序并且效率更高？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/cover/07_gettyimages-969671974_resized.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为什么Python 3.6以后字典有序并且效率更高？"/></a><div class="content"><a class="title" href="/post/2022-11-10_why-python36-dict-is-ordered/" title="为什么Python 3.6以后字典有序并且效率更高？">为什么Python 3.6以后字典有序并且效率更高？</a><time datetime="2022-11-10T11:48:46.000Z" title="发表于 2022-11-10 19:48:46">2022-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-09-29_servlet-get-post-garbage-characters/" title="Servlet中请求和响应过程中的乱码问题解决"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/cover/219688951_3119004568424371_6383122843225861057_n.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Servlet中请求和响应过程中的乱码问题解决"/></a><div class="content"><a class="title" href="/post/2022-09-29_servlet-get-post-garbage-characters/" title="Servlet中请求和响应过程中的乱码问题解决">Servlet中请求和响应过程中的乱码问题解决</a><time datetime="2022-09-29T10:33:36.000Z" title="发表于 2022-09-29 18:33:36">2022-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-09-23_git-reset-3-models/" title="Git reset 版本回退的三种模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/20220923232627.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git reset 版本回退的三种模式"/></a><div class="content"><a class="title" href="/post/2022-09-23_git-reset-3-models/" title="Git reset 版本回退的三种模式">Git reset 版本回退的三种模式</a><time datetime="2022-09-23T13:33:06.000Z" title="发表于 2022-09-23 21:33:06">2022-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-09-20_win11-explorer-doesnt-refresh/" title="解决Win11文件资源管理器不自动刷新问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/cover/06_gettyimages-624690854_resized.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决Win11文件资源管理器不自动刷新问题"/></a><div class="content"><a class="title" href="/post/2022-09-20_win11-explorer-doesnt-refresh/" title="解决Win11文件资源管理器不自动刷新问题">解决Win11文件资源管理器不自动刷新问题</a><time datetime="2022-09-20T07:28:01.000Z" title="发表于 2022-09-20 15:28:01">2022-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-09-19_python-notes/" title="Python程序设计学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/image-20220919110722606.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python程序设计学习笔记"/></a><div class="content"><a class="title" href="/post/2022-09-19_python-notes/" title="Python程序设计学习笔记">Python程序设计学习笔记</a><time datetime="2022-09-19T02:38:13.000Z" title="发表于 2022-09-19 10:38:13">2022-09-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Pil0tXia/imghost/picgo/IMG_20221006_153249.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By Pil0tXia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">不会摄影的白帽子不是好机长！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'Pil0tXia/hexo-giscus',
    'data-repo-id': 'R_kgDOIPxOww',
    'data-category-id': 'DIC_kwDOIPxOw84CSC9p',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="170" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>