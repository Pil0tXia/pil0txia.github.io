<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 后台程序的创建与管理</title>
      <link href="/post/2022-12-11_linux-background-programs/"/>
      <url>/post/2022-12-11_linux-background-programs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用 ssh 登录远程的 Linux 服务器，某些程序或脚本会在前台持续运行、占用 shell 窗口，且终端连接断开时任务也会中止。如何让运行命令提交后不受本地关闭终端窗口或网络断开连接的干扰呢？本文列举了一些实用的命令。</p></blockquote><h2 id="省流版"><a href="#省流版" class="headerlink" title="省流版"></a>省流版</h2><p><code>nohop &lt;command&gt; &amp;</code></p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>我们知道，当用户注销 (logout) 或者网络断开时，终端会收到 HUP(hangup) 信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。</p><p>nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NOHUP(1)                        User Commands                        NOHUP(1)</span><br><span class="line">NAME</span><br><span class="line">       nohup - run a command immune to hangups, with output to a non-tty</span><br><span class="line">SYNOPSIS</span><br><span class="line">       nohup COMMAND [ARG]...</span><br><span class="line">       nohup OPTION</span><br><span class="line">DESCRIPTION</span><br><span class="line">        Run COMMAND, ignoring hangup signals.</span><br><span class="line">       --help display this help and exit</span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br></pre></td></tr></table></figure><p>nohup 的使用只需在要处理的命令前加上 <code>nohup</code> 即可，标准输出和标准错误默认会被重定向到当前目录下的 nohup.out 文件中。此时，终端将不再打印输入输出，但终端依然被占用着。退出终端时，程序将继续运行。</p><p>一般我们可以在结尾加上<code>&amp;</code>将命令放入后台运行，终端将不再被占用。</p><h3 id="后台进程管理"><a href="#后台进程管理" class="headerlink" title="后台进程管理"></a>后台进程管理</h3><h4 id="jobs-管理作业"><a href="#jobs-管理作业" class="headerlink" title="jobs 管理作业"></a>jobs 管理作业</h4><p>通过 <code>jobs</code> 命令可以看到<strong>由当前终端创建</strong>的后台作业的运行状况。编号为作业号（jobspec）。</p><ul><li><p><code>bg %JOBSPEC</code> 可以让后台 Stopped 的命令继续 Running</p></li><li><p><code>fg %JOBSPEC</code> 可以让后台的作业来前台执行</p></li><li><p><code>Ctrl+Z</code>可以把前台执行的作业送进后台并挂起</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">jobs</span></span><br><span class="line">[1]-  Running                 <span class="built_in">nohup</span> ping www.ibm.com &amp;  (wd: ~/mirai-api-http/mcl-installer)</span><br><span class="line">[2]+  Running                 <span class="built_in">nohup</span> ping www.baidu.com &amp;</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="built_in">nohup</span> ping www.ibm.com  (wd: ~/mirai-api-http/mcl-installer)</span><br><span class="line">^Cazure_root@UbuntuVM:~$ <span class="built_in">jobs</span></span><br><span class="line">[2]+  Running                 <span class="built_in">nohup</span> ping www.baidu.com &amp;</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">fg</span> %2</span><br><span class="line"><span class="built_in">nohup</span> ping www.baidu.com</span><br><span class="line">^Z</span><br><span class="line">[2]+  Stopped                 <span class="built_in">nohup</span> ping www.baidu.com</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">bg</span> %2</span><br><span class="line">[2]+ <span class="built_in">nohup</span> ping www.baidu.com &amp;</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">jobs</span></span><br><span class="line">[2]+  Running                 <span class="built_in">nohup</span> ping www.baidu.com &amp;</span><br></pre></td></tr></table></figure><p><code>jobs</code>的缺点在于，一旦丢失 ssh 连接，将再也无法管理作业。</p><h4 id="ps-搜索进程"><a href="#ps-搜索进程" class="headerlink" title="ps 搜索进程"></a>ps 搜索进程</h4><p>Process Status 类似于 Windows 的任务管理器，可以显示系统的所有进程。编号为 PID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">nohup</span> ping www.ibm.com &amp;</span><br><span class="line">[1] 1408536</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">nohup</span>: ignoring input and appending output to <span class="string">&#x27;nohup.out&#x27;</span></span><br><span class="line">^C</span><br><span class="line">azure_root@UbuntuVM:~$ ps -ef | grep 1408536</span><br><span class="line">azure_r+ 1408536 1407733  0 19:01 pts/0    00:00:00 ping www.ibm.com</span><br><span class="line">azure_r+ 1408544 1407733  0 19:01 pts/0    00:00:00 grep --color=auto 1408536</span><br></pre></td></tr></table></figure><p>可以附加 <code>grep -v grep</code> 来忽略 grep 自身进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ ps -ux | grep ping | grep -v grep</span><br><span class="line">azure_r+ 1408536  0.0  0.2   8964  2700 pts/0    S    19:01   0:00 ping www.ibm.com</span><br></pre></td></tr></table></figure><p>其中，<code>ps -ef</code>和<code>ps -ux</code>的区别在于输出风格和内容的不同，<code>ps -ux</code>和<code>ps -aux</code>的区别在于进程所属用户不同。对我而言，<code>ps -ux</code>获得的信息更直接。</p><h4 id="killl-结束进程"><a href="#killl-结束进程" class="headerlink" title="killl 结束进程"></a>killl 结束进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> %JOBSPEC</span><br></pre></td></tr></table></figure><p><code>-9</code>是可选的，用于强制杀死进程。若要使用作业号，需要在 jobspec 前加上<code>%</code>。纯数字会被认为是 PID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">kill</span> %2</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">jobs</span></span><br><span class="line">[2]+  Terminated              <span class="built_in">nohup</span> ping www.baidu.com</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">kill</span> -9 %2</span><br><span class="line">-bash: <span class="built_in">kill</span>: %2: no such job</span><br><span class="line">azure_root@UbuntuVM:~$ <span class="built_in">jobs</span></span><br><span class="line">azure_root@UbuntuVM:~$</span><br></pre></td></tr></table></figure><h3 id="更改默认的-nohup-out"><a href="#更改默认的-nohup-out" class="headerlink" title="更改默认的 nohup.out"></a>更改默认的 nohup.out</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python file.py &gt; log.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><code>&gt;</code> 表示重定向标准输出（STDOUT），这里重定向到了当前目录下的 log.txt，不存在此文件时会自动创建。</p><p>若无<code>2&gt;&amp;1</code>则错误信息不会重定向。</p><h2 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h2><p>nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断。除此之外，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)</span><br><span class="line">NAME</span><br><span class="line">       setsid - run a program <span class="keyword">in</span> a new session</span><br><span class="line">SYNOPSIS</span><br><span class="line">       setsid program [ arg ... ]</span><br><span class="line">DESCRIPTION</span><br><span class="line">       setsid runs a program <span class="keyword">in</span> a new session.</span><br></pre></td></tr></table></figure><p>可见 setsid 的使用也是非常方便的，也是只需要在要处理的命令前加上 <code>setsid</code> 即可，不过 shell 依然会被占用，<code>Ctrl+C</code>和<code>Ctrl+Z</code>也不会生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ setsid ping www.google.com</span><br><span class="line">azure_root@UbuntuVM:~$ ps -ef | grep www.google.com | grep -v grep</span><br><span class="line">azure_r+ 1409166       1  0 19:43 ?        00:00:00 ping www.google.com</span><br></pre></td></tr></table></figure><p>值得注意的是，此例中我们的 PID 为 31094，而它的 PPID（父ID）为1（即 init 进程 ID），并不是当前终端的进程 ID。这一点与 nohup 例不同。</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在<code>()</code>中就能让这些命令在子 shell 中运行，从而扩展出很多有趣的功能，我们现在讨论的就是其中之一。</p><p>当我们将<code>&amp;</code>也放入<code>()</code>内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过 jobs 来查看的，<code>Ctrl+C</code>和<code>Ctrl+Z</code>同样不会生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">azure_root@UbuntuVM:~$ (ping www.office.com &amp;)</span><br><span class="line">azure_root@UbuntuVM:~$ ps -ef | grep www.office.com | grep -v grep</span><br><span class="line">azure_r+ 1409270       1  0 19:56 pts/0    00:00:00 ping www.office.com</span><br></pre></td></tr></table></figure><h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>此时再想用 nohup 或者 setsid 已经为时已晚，只能用作业调度和 <code>disown</code> 来解决了。让我们来看一下 disown 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disown</span> [-ar] [-h] [jobspec ...]</span><br><span class="line">Without options, each jobspec is  removed  from  the  table  of</span><br><span class="line">active  <span class="built_in">jobs</span>.   If  the -h option is given, each jobspec is not</span><br><span class="line">removed from the table, but is marked so  that  SIGHUP  is  not</span><br><span class="line">sent  to the job <span class="keyword">if</span> the shell receives a SIGHUP.  If no jobspec</span><br><span class="line">is present, and neither the -a nor the -r option  is  supplied,</span><br><span class="line">the  current  job  is  used.  If no jobspec is supplied, the -a</span><br><span class="line">option means to remove or mark all <span class="built_in">jobs</span>; the -r option  without</span><br><span class="line">a  jobspec  argument  restricts operation to running <span class="built_in">jobs</span>.  The</span><br><span class="line"><span class="built_in">return</span> value is 0 unless a jobspec does  not  specify  a  valid</span><br><span class="line">job.</span><br></pre></td></tr></table></figure><ul><li>用 <code>disown -h JOBSPEC</code> 来使某个作业忽略 HUP 信号。</li><li>用 <code>disown -ah</code> 来使所有的作业都忽略 HUP 信号。</li><li>用 <code>disown -rh</code> 来使正在运行的作业忽略 HUP 信号。</li></ul><p>需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用 jobs 来查看它，但 ps 依然可以查找到它。</p><p>这种方法的操作对象是作业，如果需要通过 jobs 命令得到作业列表，在运行命令时应该在结尾添加<code>&amp;</code>来使命令成为一个作业并在后台运行。</p><p>如果没有把命令作为作业来运行，我们需要按下 <code>Ctrl+Z</code> 将前台进程送入后台并挂起，然后才可以用 jobs 命令查询它的作业号，接着用 <code>bg %JOBSPEC</code> 让它继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后台 </tag>
            
            <tag> 挂起 </tag>
            
            <tag> 进程管理 </tag>
            
            <tag> 作业调度 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国外限流网盘的下载方案</title>
      <link href="/post/2022-12-09_foreign-netdisk-download/"/>
      <url>/post/2022-12-09_foreign-netdisk-download/</url>
      
        <content type="html"><![CDATA[<h2 id="油猴脚本"><a href="#油猴脚本" class="headerlink" title="油猴脚本"></a>油猴脚本</h2><p><a href="https://greasyfork.org/zh-CN/scripts/449511-%E6%98%9F%E8%80%80%E4%BA%91-%E9%A3%9E%E7%8C%AB%E4%BA%91-kufile-rosefile-expfile-%E5%9F%8E%E9%80%9A%E7%BD%91%E7%9B%98%E7%A0%B4%E8%A7%A3%E4%BC%98%E5%8C%96">星耀云&#x2F;飞猫云&#x2F;kufile&#x2F;rosefile&#x2F;expfile&#x2F;城通网盘破解优化</a></p><p><a href="https://static.pil0txia.com/file/%E6%98%9F%E8%80%80%E4%BA%91-%E9%A3%9E%E7%8C%AB%E4%BA%91-kufile-rosefile-expfile-%E5%9F%8E%E9%80%9A%E7%BD%91%E7%9B%98%E7%A0%B4%E8%A7%A3%E4%BC%98%E5%8C%96.user.js">备份下载链接</a></p><h2 id="Premium-Link-Generator"><a href="#Premium-Link-Generator" class="headerlink" title="Premium Link Generator"></a>Premium Link Generator</h2><p>网盘中转站，用于为以盈利为主的小型网盘（如Katfile，Uploaded，Goloady，Rapidgator等）生成VIP高速下载链接。类似于会员共享 + 离线下载，存在限制。</p><ul><li><p><a href="https://leechall.com/index.php">Leechall</a>：（免注册）支持28种站点</p></li><li><p><a href="https://cocoleech.com/">CoCoLeech</a>：（免注册）免费用户支持13种站点</p></li><li><p><a href="https://simply-debrid.com/generate">SimplyDebrid</a>：（需要注册）免费用户支持13种站点</p></li><li><p><a href="https://hungryleech.com/">HungryLeech</a>：（免注册）只支持4种站点</p></li><li><p><a href="https://www.uploadedpremiumlink.net/">UploadedPremiumLink</a>：（可选注册）支持23种站点，亲测能用，不过不知道有没有数量和流量限制，网页上也没说，非注册用户单文件大小限制521MB，注册免费用户可以下载更大的文件</p></li><li><p><a href="https://www.deepbrid.com/downloader">Deepbrid</a>：（需要注册）支持25种站点，单日限3次下载，文件最大不得超过300M</p></li><li><p><a href="https://neodebrid.com/">NeoDebrid</a>：（免注册）免费用户支持20种站点，但是每日限5次下载且下载间隔为10min</p></li><li><p><a href="https://leechpremium.net/">LeechPremium</a>：（免注册）支持14种站点，2022-12-10获取文件大小有误、反复跳转</p></li><li><p><a href="https://hyperdebrid.net/">HyperDebrid</a>：（可选注册）支持34种站点</p></li></ul><h3 id="Clash-Parser-直连规则"><a href="#Clash-Parser-直连规则" class="headerlink" title="Clash Parser 直连规则"></a>Clash Parser 直连规则</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># premium link generator</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,leechall.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cocoleech.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,simply-debrid.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hungryleech.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,uploadedpremiumlink.net,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,deepbrid.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,leechpremium.net,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hyperdebrid.net,DIRECT</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
            <tag> 分享 </tag>
            
            <tag> 限流 </tag>
            
            <tag> 中转 </tag>
            
            <tag> 下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 Python 3.6 以后字典有序并且效率更高？</title>
      <link href="/post/2022-11-10_why-python36-dict-is-ordered/"/>
      <url>/post/2022-11-10_why-python36-dict-is-ordered/</url>
      
        <content type="html"><![CDATA[<p>在Python 3.5（含）以前，字典是不能保证顺序的，键值对A先插入字典，键值对B后插入字典，但是当你打印字典的Keys列表时，你会发现B可能在A的前面。</p><p>但是从Python 3.6开始，字典是变成有顺序的了。你先插入键值对A，后插入键值对B，那么当你打印Keys列表的时候，你就会发现B在A的后面。</p><p>不仅如此，从Python 3.6开始，下面的三种遍历操作，效率要高于Python 3.5之前：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> 字典</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> 字典.values()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> 字典.items()</span><br></pre></td></tr></table></figure><p>从Python 3.6开始，字典占用内存空间的大小，视字典里面键值对的个数，只有原来的30%~95%。</p><p>Python 3.6到底对字典做了什么优化呢？为了说明这个问题，我们需要先来说一说，在Python 3.5（含）之前，字典的底层原理。</p><p>当我们初始化一个空字典的时候，CPython的底层会初始化一个二维数组，这个数组有8行，3列，如下面的示意图所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">[[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在，我们往字典里面添加一个数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;kingname&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">[[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[1278649844881305901, 指向name的指针, 指向kingname的指针],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里解释一下，为什么添加了一个键值对以后，内存变成了这个样子：</p><p>首先我们调用Python 的<code>hash</code>函数，计算<code>name</code>这个字符串在<strong>当前运行时</strong>的hash值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="number">1278649844881305901</span></span><br></pre></td></tr></table></figure><p>特别注意，我这里强调了『当前运行时』，这是因为，Python自带的这个<code>hash</code>函数，和我们传统上认为的Hash函数是不一样的。Python自带的这个<code>hash</code>函数计算出来的值，只能保证在每一个运行时的时候不变，但是当你关闭Python再重新打开，那么它的值就可能会改变，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-12-21-49-44.png" alt="img"></p><p>假设在某一个运行时里面，<code>hash(&#39;name&#39;)</code>的值为<code>1278649844881305901</code>。现在我们要把这个数对8取余数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1278649844881305901</span> % <span class="number">8</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>余数为5，那么就把它放在刚刚初始化的二维数组中，下标为5的这一行。由于<code>name</code>和<code>kingname</code>是两个字符串，所以底层C语言会使用两个字符串变量存放这两个值，然后得到他们对应的指针。于是，我们这个二维数组下标为5的这一行，第一个值为<code>name</code>的hash值，第二个值为<code>name</code>这个字符串所在的内存的地址（指针就是内存地址），第三个值为<code>kingname</code>这个字符串所在的内存的地址。</p><p>现在，我们再来插入两个键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&#x27;age&#x27;</span>] = <span class="number">26</span></span><br><span class="line">my_dict[<span class="string">&#x27;salary&#x27;</span>] = <span class="number">999999</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">[[-4234469173262486640, 指向salary的指针, 指向999999的指针],</span></span><br><span class="line"><span class="string">[1545085610920597121, 执行age的指针, 指向26的指针],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[1278649844881305901, 指向name的指针, 指向kingname的指针],</span></span><br><span class="line"><span class="string">[---, ---, ---],</span></span><br><span class="line"><span class="string">[---, ---, ---]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>那么字典怎么读取数据呢？首先假设我们要读取<code>age</code>对应的值。</p><p>此时，Python先计算在当前运行时下面，<code>age</code>对应的Hash值是多少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="number">1545085610920597121</span></span><br></pre></td></tr></table></figure><p>现在这个hash值对8取余数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1545085610920597121</span> % <span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>余数为1，那么二维数组里面，下标为1的这一行就是需要的键值对。直接返回这一行第三个指针对应的内存中的值，就是<code>age</code>对应的值<code>26</code>。</p><p>当你要循环遍历字典的Key的时候，Python底层会遍历这个二维数组，如果当前行有数据，那么就返回Key指针对应的内存里面的值。如果当前行没有数据，那么就跳过。所以总是会遍历整个二位数组的每一行。</p><p>每一行有三列，每一列占用8byte的内存空间，所以每一行会占用24byte的内存空间。</p><p>由于Hash值取余数以后，余数可大可小，所以字典的Key并不是按照插入的顺序存放的。</p><blockquote><p>注意，这里我省略了与本文没有太大关系的两个点：</p><ol><li>开放寻址，当两个不同的Key，经过Hash以后，再对8取余数，可能余数会相同。此时Python为了不覆盖之前已有的值，就会使用<code>开放寻址</code>技术重新寻找一个新的位置存放这个新的键值对。</li><li>当字典的键值对数量超过当前数组长度的2&#x2F;3时，数组会进行扩容，8行变成16行，16行变成32行。长度变了以后，原来的余数位置也会发生变化，此时就需要移动原来位置的数据，导致插入效率变低。</li></ol></blockquote><p>在Python 3.6以后，字典的底层数据结构发生了变化，现在当你初始化一个空的字典以后，它在底层是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">indices = [None, None, None, None, None, None, None, None]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = []</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>当你初始化一个字典以后，Python单独生成了一个长度为8的一维数组。然后又生成了一个空的二维数组。</p><p>现在，我们往字典里面添加一个键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;kingname&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">indices = [None, 0, None, None, None, None, None, None]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么内存会变成这个样子呢？我们来一步一步地看：</p><p>在当前运行时，<code>name</code>这个字符串的hash值为<code>-5954193068542476671</code>，这个值对8取余数是1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">-<span class="number">5954193068542476671</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;name&#x27;</span>) % <span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以，我们把<code>indices</code>这个一维数组里面，下标为1的位置修改为0。</p><p>这里的0是什么意思呢？0是二位数组<code>entries</code>的索引。现在<code>entries</code>里面只有一行，就是我们刚刚添加的这个键值对的三个数据：<code>name</code>的hash值、指向<code>name</code>的指针和指向<code>kinganme</code>的指针。所以<code>indices</code>里面填写的数字0，就是刚刚我们插入的这个键值对的数据在二位数组里面的行索引。</p><p>好，现在我们再来插入两条数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">my_dict[<span class="string">&#x27;salary&#x27;</span>] = <span class="number">999999</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此时的内存示意图</span></span><br><span class="line"><span class="string">indices = [1, 0, None, None, None, None, 2, None]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针],</span></span><br><span class="line"><span class="string">          [9043074951938101872, 指向address的指针，指向xxx的指针],</span></span><br><span class="line"><span class="string">          [7324055671294268046, 指向salary的指针, 指向999999的指针]</span></span><br><span class="line"><span class="string">         ]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在如果我要读取数据怎么办呢？假如我要读取<code>salary</code>的值，那么首先计算<code>salary</code>的hash值，以及这个值对8的余数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;salary&#x27;</span>)</span><br><span class="line"><span class="number">7324055671294268046</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&#x27;salary&#x27;</span>) % <span class="number">8</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>那么我就去读<code>indices</code>下标为6的这个值。这个值为2.</p><p>然后再去读entries里面，下标为2的这一行的数据，也就是salary对应的数据了。</p><p>新的这种方式，当我要插入新的数据的时候，始终只是往<code>entries</code>的后面添加数据，这样就能保证插入的顺序。当我们要遍历字典的Keys和Values的时候，直接遍历<code>entries</code>即可，里面每一行都是有用的数据，不存在跳过的情况，减少了遍历的个数。</p><p>老的方式，当二维数组有8行的时候，即使有效数据只有3行，但它占用的内存空间还是 <code>8*24 = 192 byte</code>。但使用新的方式，如果只有三行有效数据，那么<code>entries</code>也就只有3行，占用的空间为<code>3*24 =72 byte</code>，而<code>indices</code>由于只是一个一维的数组，只占用8 byte，所以一共占用 80 byte。内存占用只有原来的41%。</p><blockquote><p><a href="https://www.kingname.info/2019/07/13/python-dict/">原文地址</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 字典 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 键值对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 中请求和响应过程中的乱码问题解决</title>
      <link href="/post/2022-09-29_servlet-get-post-garbage-characters/"/>
      <url>/post/2022-09-29_servlet-get-post-garbage-characters/</url>
      
        <content type="html"><![CDATA[<h3 id="一、POST请求中的乱码问题："><a href="#一、POST请求中的乱码问题：" class="headerlink" title="一、POST请求中的乱码问题："></a>一、POST请求中的乱码问题：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须要在获取请求参数之前调用才有效</span></span><br><span class="line">request.<span class="title function_">setCharacterEncoding</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="二、Get请求中的乱码问题："><a href="#二、Get请求中的乱码问题：" class="headerlink" title="二、Get请求中的乱码问题："></a>二、Get请求中的乱码问题：</h3><p>可以在获取到请求参数后，先进行tomcat端的编码（也就是先以 iso8859-1 进行编码），然后再用utf-8解码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> name = request.<span class="title function_">getParameter</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name = <span class="keyword">new</span> <span class="title class_">String</span>(name.<span class="title function_">getBytes</span>(<span class="string">&quot;iso-8859-1&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="三、响应中的乱码问题解决："><a href="#三、响应中的乱码问题解决：" class="headerlink" title="三、响应中的乱码问题解决："></a>三、响应中的乱码问题解决：</h3><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>将服务器端和浏览器端的字符集都统一设置为UTF-8字符集。位置没要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置服务器字符集为 UTF-8</span></span><br><span class="line">response.<span class="title function_">setCharacterEncoding</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 通过响应头，设置浏览器也使用 UTF-8 字符集</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="方案二（推荐）："><a href="#方案二（推荐）：" class="headerlink" title="方案二（推荐）："></a>方案二（推荐）：</h4><p>代码更加简洁，但是这种方式设置一定要在获取流对象之前调用才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头</span></span><br><span class="line">response.<span class="title function_">setContentType</span>(<span class="string">&quot;text/html; Charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//一定要记住在获取流对象之前调用才会有效。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
            <tag> post </tag>
            
            <tag> get </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git reset 版本回退的三种模式</title>
      <link href="/post/2022-09-23_git-reset-3-models/"/>
      <url>/post/2022-09-23_git-reset-3-models/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们用 Git commit 提交代码后，有时会发现这一次 commit 的内容是有错误的，那么有三种处理方法：</p><ol><li>修改错误内容，再次 commit 一次</li><li>使用 <strong>git revert</strong> 命令撤销这一次错误的 commit</li><li>使用 <strong>git reset</strong> 命令回退到正确的 commit</li></ol><p>第一、二种方法比较直接，会多次一次 commit 记录。对图床来说，我个人更倾向第三种方法，图片批量上传会提交大量的 commit，回退显然更直接有效。那么来说一下 <strong>git reset</strong>，它的一句话概括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-reset - Reset current HEAD to the specified state</span><br></pre></td></tr></table></figure><p>意思就是可以让 HEAD 这个指针指向其他的地方。例如我们有一次 commit 不是不是很满意，需要回到上一次的 Commit 里面。那么这个时候就需要通过 reset，把 HEAD 指针指向上一次的 commit 的点。<br>它有三种模式，soft,mixed,hard，具体的使用方法下面这张图，展示的很全面了。</p><p><img src="https://static.pil0txia.com/picgo/20220923232627.png" alt="git 各个区域和命令关系"></p><p>这三个模式理解了，对于使用这个命令很有帮助。在理解这三个模式之前，需要略微知道一点 Git 的基本流程。正如上图，Git 会有三个区域：</p><ul><li><strong>Working Tree</strong> 当前的工作区域</li><li><strong>Index&#x2F;Stage</strong> 暂存区域，和 git stash 命令暂存的地方不一样。使用 git add xx，就可以将 xx 添加近 Stage 里面</li><li><strong>Repository</strong> 提交的历史，即使用 git commit 提交后的结果</li></ul><p><img src="https://static.pil0txia.com/picgo/20220923232649.png" alt="文件存入 Repository 流程"></p><p>以下简单叙述一下把文件存入 Repository 流程：</p><ol><li><p>刚开始 working tree 、 index 与 repository(HEAD) 里面的内容都是一致的</p><p><img src="https://static.pil0txia.com/picgo/20220923232706.png" alt="阶段 1"></p></li><li><p>当 git 管理的文件夹里面的内容出现改变后，此时 working tree 的内容就会跟 index 及 repository(HEAD)的不一致，而 Git 知道是哪些文件 (Tracked File) 被改动过，直接将文件状态设置为 modified (Unstaged files)。</p><p><img src="https://static.pil0txia.com/picgo/20220923232723.png" alt="阶段 2"></p></li><li><p>当我们执行 git add 后，会将这些改变的文件内容加入 index 中 (Staged files)，所以此时 working tree 跟 index 的内容是一致的，但他们与 repository(HEAD) 内容不一致。</p><p><img src="https://static.pil0txia.com/picgo/20220923232731.png" alt="阶段 3"></p></li><li><p>接着执行 git commit 后，将 Git 索引中所有改变的文件内容提交至 Repository 中，建立出新的 commit 节点 (HEAD) 后， working tree 、 index 与与 repository(HEAD)区域的内容 又会保持一致。</p><p><img src="https://static.pil0txia.com/picgo/20220923232739.png" alt="阶段 4"></p></li></ol><h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><h3 id="reset-–hard：重置-stage-区和工作目录"><a href="#reset-–hard：重置-stage-区和工作目录" class="headerlink" title="reset –hard：重置 stage 区和工作目录:"></a>reset –hard：重置 stage 区和工作目录:</h3><p><strong>reset –hard</strong> 会在重置 <strong>HEAD</strong> 和 <strong>branch</strong> 的同时，重置 stage 区和工作目录里的内容。当你在 <strong>reset</strong> 后面加了 <strong>–hard</strong> 参数时，你的 stage 区和工作目录里的内容会被完全重置为和 <strong>HEAD</strong> 的新位置相同的内容。换句话说，就是你的没有 <strong>commit</strong> 的修改会被全部擦掉。</p><p>例如你在上次 <strong>commit</strong> 之后又对文件做了一些改动：把修改后的 <strong>ganmes.txt</strong> 文件 <strong>add</strong> 到 <strong>stage 区</strong>，修改后的 <strong>shopping list.txt</strong> 保留在<strong>工作目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923232750.png" alt="最初状态"></p><p>然后，你执行了<strong>reset</strong>并附上了**–hard**参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>你的 <strong>HEAD <strong>和当前</strong> branch</strong> 切到上一条 <strong>commit</strong> 的同时，你工作目录里的新改动和已经 add 到 stage 区的新改动也一起全都消失了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923232804.png" alt="reset --hard head^ 之后"></p><p>可以看到，在<strong>reset –hard</strong>后，所有的改动都被擦掉了。</p><h3 id="reset-–soft：保留工作目录，并把重置-HEAD-所带来的新的差异放进暂存区"><a href="#reset-–soft：保留工作目录，并把重置-HEAD-所带来的新的差异放进暂存区" class="headerlink" title="reset –soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区"></a>reset –soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区</h3><p><strong>reset –soft</strong> 会在重置 <strong>HEAD</strong> 和 <strong>branch</strong> 时，保留工作目录和暂存区中的内容，并把重置 <strong>HEAD</strong> 所带来的新的差异放进暂存区。</p><p>什么是「重置 <strong>HEAD</strong> 所带来的新的差异」？就是这里：  </p><p><img src="https://static.pil0txia.com/picgo/4428238-75ef41dc9eec6f8e.gif"></p><p>由于 <strong>HEAD</strong> 从 4 移动到了 3，而且在 reset 的过程中工作目录和暂存区的内容没有被清理掉，所以 4 中的改动在 <strong>reset</strong> 后就也成了工作目录新增的「工作目录和 <strong>HEAD</strong> 的差异」。这就是上面一段中所说的「重置 <strong>HEAD</strong> 所带来的差异」。</p><p>此模式下会保留 <strong>working tree 工作目录</strong>的內容，不会改变到目前所有的 git 管理的文件夹的內容；也会保留 <strong>index 暂存区</strong>的內容，让 <strong>index 暂存区</strong>与 <strong>working tree</strong> 工作目录的內容是一致的。就只有 <strong>repository</strong> 中的內容的更变需要与 <strong>reset</strong> 目标节点一致，因此原始节点与 <strong>reset</strong> 节点之间的差异变更集合会存在与 index 暂存区中 (<strong>Staged files</strong>)，所以我们可以直接执行 <strong>git commit</strong> 將 <strong>index 暂存区</strong>中的內容提交至 <strong>repository</strong> 中。当我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 <strong>commit</strong> 记录 (可能是阶段性地频繁提交) 時，可以考虑使用 <strong>Soft Reset</strong> 来让 <strong>commit</strong> 演进线图较为清晰点。  </p><p><img src="https://static.pil0txia.com/picgo/20220923232948.png"></p><p>所以在同样的情况下，还是老样子：把修改后的 <strong>ganmes.txt</strong> 文件 <strong>add</strong> 到 <strong>stage 区</strong>，修改后的 <strong>shopping list.txt</strong> 保留在<strong>工作目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923232955.png" alt="最初状态"></p><p>假设此时当前<strong>commit</strong>的改动内容是新增了<strong>laughters.txt</strong>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show --stat</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923233008.png" alt="git show --stat"></p><p>如果这时你执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>那么除了 <strong>HEAD</strong> 和它所指向的 <strong>branch1</strong> 被移动到 <strong>HEAD^</strong> 之外，原先 <strong>HEAD</strong> 处 <strong>commit</strong> 的改动（也就是那个 <strong>laughters.txt</strong> 文件）也会被放进暂存区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923233024.png" alt="使用 git reset --soft HEAD^ 后"></p><p>这就是**–soft<strong>和</strong>–hard<strong>的区别：</strong>–hard<em><em>会清空工作目录和暂存区的改动,</em> 而</em>*–soft 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区**。</p><h3 id="reset-不加参数-mixed-：保留工作目录，并清空暂存区"><a href="#reset-不加参数-mixed-：保留工作目录，并清空暂存区" class="headerlink" title="reset 不加参数 (mixed)：保留工作目录，并清空暂存区"></a>reset 不加参数 (mixed)：保留工作目录，并清空暂存区</h3><p><strong>reset</strong> 如果不加参数，那么默认使用 <strong>–mixed</strong> 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 <strong>reset</strong> 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。</p><p>还以同样的情况为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923233031.png" alt="最初状态"></p><p><strong>修改了 的 games.txt 和 shopping list.txt，并把 games.txt 放进了暂存区。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show --stat</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923233040.png" alt="git show --stat"></p><p><strong>最新的 commit 中新增了 laughters.txt 文件。</strong></p><p>这时如果你执行<strong>无参数</strong>的 <strong>reset</strong> 或者带 <strong>–mixed</strong> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br><span class="line">git reset --mixed HEAD^</span><br></pre></td></tr></table></figure><p>工作目录的内容和 <strong>–soft</strong> 一样会被保留，但和 <strong>–soft</strong> 的区别在于，它会把暂存区清空, 并把原节点和 <strong>reset</strong> 节点的差异的文件放在工作目录，总而言之就是，工作目录的修改、暂存区的内容以及由 <strong>reset</strong> 所导致的新的文件差异，都会被放进工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/20220923233048.png" alt="git reset HEAD^ 之后"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="reset-的本质：移动-HEAD-以及它所指向的-branch"><a href="#reset-的本质：移动-HEAD-以及它所指向的-branch" class="headerlink" title="reset 的本质：移动 HEAD 以及它所指向的 branch"></a>reset 的本质：移动 HEAD 以及它所指向的 branch</h3><p>实质上，<strong>reset</strong> 这个指令虽然可以用来撤销 <strong>commit</strong> ，但它的实质行为并不是撤销，而是移动 <strong>HEAD</strong> ，并且「捎带」上 <strong>HEAD</strong> 所指向的 <strong>branch</strong>（如果有的话）。也就是说，<strong>reset</strong> 这个指令的行为其实和它的字面意思 “<strong>reset</strong>“（重置）十分相符：它是用来重置 <strong>HEAD</strong> 以及它所指向的 <strong>branch</strong> 的位置的。</p><p>而 <strong>reset –hard HEAD^</strong> 之所以起到了撤销 <strong>commit</strong> 的效果，是因为它把 <strong>HEAD</strong> 和它所指向的 branch 一起移动到了当前 <strong>commit</strong> 的父 <strong>commit</strong> 上，从而起到了「撤销」的效果：</p><p><img src="https://static.pil0txia.com/picgo/4428238-6dbab74ae9ad2e1f.gif" alt="git reset"></p><p>Git 的历史只能往回看，不能向未来看，所以把 <strong>HEAD</strong> 和 <strong>branch</strong> 往回移动，就能起到撤回 <strong>commit</strong> 的效果。</p><p>所以同理，<strong>reset –hard</strong> 不仅可以撤销提交，还可以用来把 <strong>HEAD</strong> 和 <strong>branch</strong> 移动到其他的任何地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard branch2</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/4428238-71f7141a3878da7e.gif" alt="git reset --hard branch2"></p><h3 id="reset-三种模式区别和使用场景"><a href="#reset-三种模式区别和使用场景" class="headerlink" title="reset 三种模式区别和使用场景"></a>reset 三种模式区别和使用场景</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li><p><strong>–hard</strong>：重置位置的同时，直接将 <strong>working Tree 工作目录</strong>、 <strong>index 暂存区</strong>及 <strong>repository</strong> 都重置成目标 <strong>Reset</strong> 节点的內容, 所以效果看起来等同于清空暂存区和工作区。</p></li><li><p><strong>–soft</strong>：重置位置的同时，保留 <strong>working Tree 工作目录</strong>和 <strong>index 暂存区</strong>的内容，只让 <strong>repository</strong> 中的内容和 <strong>reset</strong> 目标节点保持一致，因此原节点和 <strong>reset</strong> 节点之间的【差异变更集】会放入 <strong>index 暂存区</strong>中 (<strong>Staged files</strong>)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 <strong>Reset</strong> 节点之间的所有差异都会放到暂存区中。</p></li><li><p><strong>–mixed（默认）</strong>：重置位置的同时，只保留 <strong>Working Tree 工作目录</strong>的內容，但会将 <strong>Index 暂存区</strong> 和 <strong>Repository</strong> 中的內容更改和 reset 目标节点一致，因此原节点和 <strong>Reset</strong> 节点之间的【差异变更集】会放入 <strong>Working Tree 工作目录</strong>中。所以效果看起来就是原节点和 <strong>Reset</strong> 节点之间的所有差异都会放到工作目录中。</p></li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><ol><li><p><strong>–hard</strong>：(1) <strong>要放弃目前本地的所有改变時</strong>，即去掉所有 add 到暂存区的文件和工作区的文件，可以执行 <strong>git reset -hard HEAD</strong> 来强制恢复 git 管理的文件夹的內容及状态；(2) <strong>真的想抛弃目标节点后的所有 commit</strong>（可能觉得目标节点到原节点之间的 commit 提交都是错了，之前所有的 commit 有问题）。</p></li><li><p><strong>–soft</strong>：原节点和 <strong>reset</strong> 节点之间的【差异变更集】会放入 <strong>index 暂存区</strong>中 (<strong>Staged files</strong>)，所以假如我们之前工作目录没有改过任何文件，也没 add 到暂存区，那么使用 <strong>reset –soft</strong> 后，我们可以直接执行 <strong>git commit</strong> 將 index 暂存区中的內容提交至 <strong>repository</strong> 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「<strong>reset</strong> 目标节点」之间不具太大意义的 <strong>commit</strong> 记录 (可能是阶段性地频繁提交, 就是开发一个功能的时候，改或者增加一个文件的时候就 <strong>commit</strong>，这样做导致一个完整的功能可能会好多个 <strong>commit</strong> 点，这时假如你需要把这些 <strong>commit</strong> 整合成一个 <strong>commit</strong> 的时候) 時，可以考虑使用 <strong>reset –soft</strong> 来让 <strong>commit</strong> 演进线图较为清晰。总而言之，<strong>可以使用 –soft 合并 commit 节点</strong>。</p></li><li><p><strong>–mixed（默认）</strong>：(1) 使用完 <strong>reset –mixed</strong> 后，我們可以直接执行 <strong>git add</strong> 将這些改变果的文件內容加入 <strong>index 暂存区</strong>中，再执行 <strong>git commit</strong> 将 <strong>Index 暂存区</strong> 中的內容提交至 <strong>Repository</strong> 中，这样一样可以达到合并 <strong>commit</strong> 节点的效果（与上面 –soft 合并 commit 节点差不多，只是多了 git add 添加到暂存区的操作）；(2) 移除所有 Index 暂存区中准备要提交的文件 (Staged files)，我们可以执行 <strong>git reset HEAD</strong> 来 <strong>Unstage</strong> 所有已列入 <strong>Index 暂存区</strong> 的待提交的文件。(有时候发现 add 错文件到暂存区，就可以使用命令)。(3)<strong>commit</strong> 提交某些错误代码，或者没有必要的文件也被 <strong>commit</strong> 上去，不想再修改错误再 <strong>commit</strong>（因为会留下一个错误 <strong>commit</strong> 点），可以回退到正确的 <strong>commit</strong> 点上，然后所有原节点和 <strong>reset</strong> 节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再 <strong>commit</strong> 上去就 OK 了。</p></li></ol><h3 id="如果想回退撤销的版本"><a href="#如果想回退撤销的版本" class="headerlink" title="如果想回退撤销的版本?"></a>如果想回退撤销的版本?</h3><p>上面提的<strong>并不是真正的物理删除</strong>，因为Git会把分支的每次修改记录保留下来，包括某次的reset。使用 <strong>git reflog show</strong> 命令，可以查看完整的提交历史。只要有commit_id，我们就能用 <strong>git reset commit_id</strong> 恢复任意版本的代码，在各版本之间来回穿梭。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://dotblogs.com.tw/wasichris/2016/04/29/225157">https://dotblogs.com.tw/wasichris/2016/04/29/225157</a></p><p><a href="https://www.domon.cn/2018/09/06/Git-reset-used-in-coding/">https://www.domon.cn/2018/09/06/Git-reset-used-in-coding/</a> </p><p><a href="https://juejin.im/book/5a124b29f265da431d3c472e/section/5a14529bf265da43310d7351">https://juejin.im/book/5a124b29f265da431d3c472e/section/5a14529bf265da43310d7351</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 版本回退 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Win11 文件资源管理器不自动刷新问题</title>
      <link href="/post/2022-09-20_win11-explorer-doesnt-refresh/"/>
      <url>/post/2022-09-20_win11-explorer-doesnt-refresh/</url>
      
        <content type="html"><![CDATA[<h3 id="重置文件夹视图"><a href="#重置文件夹视图" class="headerlink" title="重置文件夹视图"></a>重置文件夹视图</h3><p>文件资源管理器-选项-查看-重置文件夹</p><h3 id="重建资源管理器图标缓存"><a href="#重建资源管理器图标缓存" class="headerlink" title="重建资源管理器图标缓存"></a>重建资源管理器图标缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd %homepath%\AppData\Local\Microsoft\Windows\Explorer</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">del iconcache* thumbcache*</span><br><span class="line">explorer.exe</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件资源管理器 </tag>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python程序设计学习笔记</title>
      <link href="/post/2022-09-19_python-notes/"/>
      <url>/post/2022-09-19_python-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static.pil0txia.com/picgo/image-20220919103829099.png" alt="image-20220919103829099"></p><p><img src="https://static.pil0txia.com/picgo/image-20220919105043868.png" alt="image-20220919105043868"></p><p><img src="https://static.pil0txia.com/picgo/image-20220919110722606.png" alt="image-20220919110722606"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大三上 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你的 IPv6 Wake-On-WAN 没有起效？</title>
      <link href="/post/2022-09-17_why-ipv6-WOL-fails/"/>
      <url>/post/2022-09-17_why-ipv6-WOL-fails/</url>
      
        <content type="html"><![CDATA[<h2 id="家庭-x2F-私人C类网络环境"><a href="#家庭-x2F-私人C类网络环境" class="headerlink" title="家庭&#x2F;私人C类网络环境"></a>家庭&#x2F;私人C类网络环境</h2><blockquote><p>此章节为我与WolOn APP开发者的往来邮件。基本Wake-On-LAN网络唤醒原理和主机设置就不赘述了。</p></blockquote><h3 id="A-question-about-wake-up-on-WAN-with-ipv6"><a href="#A-question-about-wake-up-on-WAN-with-ipv6" class="headerlink" title="A question about wake up on WAN with ipv6"></a><strong>A question about wake up on WAN with ipv6</strong></h3><p>Hello!</p><p>I encountered a problem when using your WolOn APP. My padavan router and PCs have native ipv6 address and all configured ipv6 DDNS. My ISP can’t provide me with a public ipv4 address. So I would like to use the router to forward ipv6 packets when wake up on WAN.</p><p>Wake up on LAN and wake up on WAN with ipv4 (like <code>192.168.1.2</code> and <code>100.65.119.101</code>) works very well. However wake up on WAN with ipv6 (like <code>2409:8a23:a60a:8698:c051:c583:f271:adef</code>) and pure ipv6 domain (only has AAAA record) doesn’t work.</p><p>I configured router ipv6 firewall like this:</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -A INPUT -p udp --dport 9 -j ACCEPT</span><br><span class="line">ip6tables -I FORWARD -p udp --dport 9 -j ACCEPT</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -A INPUT -p udp --dport 9 -j ACCEPT</span><br><span class="line">ip6tables -I FORWARD -p udp -d 2409:8a23:a6af:c612:3129:3b6f:e6a5:844b --dport 9 -j ACCEPT</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -F</span><br><span class="line">ip6tables -X</span><br><span class="line">ip6tables -P INPUT ACCEPT</span><br><span class="line">ip6tables -P OUTPUT ACCEPT</span><br><span class="line">ip6tables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>Each kind of 3 configs doesn’t work.</p><p>Does your software fully support ipv6? May you please give me some advice?</p><p>Thank you.</p><h3 id="The-supplement-of-“A-question-about-wake-up-on-WAN-with-ipv6”"><a href="#The-supplement-of-“A-question-about-wake-up-on-WAN-with-ipv6”" class="headerlink" title="The supplement of “A question about wake up on WAN with ipv6”"></a><strong>The supplement of “A question about wake up on WAN with ipv6”</strong></h3><p>Hello!</p><p>I have done many attempts.</p><p>I filled in “100.65.119.101”(the router ipv4 WAN IP) in the “Router IP&#x2F;Hostname” of WolOn&#x2F;WAN. The packets arrived. As is shown in the screenshot of Wireshark. The lower entry is for WolOn&#x2F;LAN.</p><p><img src="https://static.pil0txia.com/picgo/image-20220917141359119.png" alt="image-20220917141359119"></p><p>I filled in the router ipv6 WAN IP in the “Router IP&#x2F;Hostname” of WolOn&#x2F;WAN. The packets didn’t arrive. Wireshark caught nothing. However, the router ip6table log indicates that the packet was accepted by the firewall:</p><p><img src="https://static.pil0txia.com/picgo/image-20220917142356270.png" alt="image-20220917142356270"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">1        0     0 ACCEPT     udp      *      *       ::/0                 ::/0                 udp dpt:3389</span><br><span class="line">2        0     0 ACCEPT     tcp      *      *       ::/0                 ::/0                 tcp dpt:3389</span><br><span class="line">3       30  4500 ACCEPT     udp      *      *       ::/0                 ::/0                 udp dpt:9</span><br><span class="line">4       16  2694 ACCEPT     all      *      *       ::/0                 ::/0                 state RELATED,ESTABLISHED</span><br><span class="line">5      139 25724 ACCEPT     all      br0    *       ::/0                 ::/0               </span><br><span class="line">6        0     0 ACCEPT     all      lo     *       ::/0                 ::/0               </span><br><span class="line">7        8   600 logaccept  icmpv6    *      *       ::/0                 ::/0                 ipv6-icmp !<span class="built_in">type</span> 128</span><br><span class="line">8        0     0 DROP       all      *      *       ::/0                 ::/0                 state INVALID</span><br><span class="line">9        0     0 logaccept  udp      *      *       ::/0                 ::/0                 udp spt:547 dpt:546</span><br><span class="line">10       0     0 logaccept  tcp      *      *       ::/0                 ::/0                 tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">1        0     0 ACCEPT     udp      *      *       ::/0                 ::/0                 udp dpt:3389</span><br><span class="line">2      102 19720 ACCEPT     tcp      *      *       ::/0                 ::/0                 tcp dpt:3389</span><br><span class="line">3        0     0 ACCEPT     udp      *      *       ::/0                 ::/0                 udp dpt:9</span><br><span class="line">4        0     0 ACCEPT     all      br0    br0     ::/0                 ::/0               </span><br><span class="line">5       66  4944 TCPMSS     tcp      *      !br0    ::/0                 ::/0                 tcp flags:0x06/0x02 TCPMSS clamp to PMTU</span><br><span class="line">6     3571 1582K ACCEPT     all      *      *       ::/0                 ::/0                 state RELATED,ESTABLISHED</span><br><span class="line">7        0     0 logaccept  icmpv6    *      *       ::/0                 ::/0                 ipv6-icmp !<span class="built_in">type</span> 128</span><br><span class="line">8       56  3866 DROP       all      *      *       ::/0                 ::/0                 state INVALID</span><br><span class="line">9      835  131K ACCEPT     all      br0    *       ::/0                 ::/0               </span><br><span class="line">10       0     0 upnp       all      *      *       ::/0                 ::/0               </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 557 packets, 215K bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain bfplimit (0 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain logaccept (4 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">1        0     0 LOG        all      *      *       ::/0                 ::/0                 state NEW LOG flags 6 level 4 prefix <span class="string">&quot;ACCEPT &quot;</span></span><br><span class="line">2        8   600 ACCEPT     all      *      *       ::/0                 ::/0               </span><br><span class="line"></span><br><span class="line">Chain upnp (1 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br></pre></td></tr></table></figure><p>Each time I click on the botton of WolOn, the “pkts” adds 10.</p><p>So what do these tests show? I am looking forward to your reply!</p><h3 id="Re-The-supplement-of-“A-question-about-wake-up-on-WAN-with-ipv6”"><a href="#Re-The-supplement-of-“A-question-about-wake-up-on-WAN-with-ipv6”" class="headerlink" title="Re: The supplement of “A question about wake up on WAN with ipv6”"></a><strong>Re: The supplement of “A question about wake up on WAN with ipv6”</strong></h3><p>Hi,</p><p>You’ve done some pretty deep research.</p><p>For your internal network you should use IPv4 as WOL protocol doesn’t work on IPv6, it relies on broadcast and IPv6 doesn’t have broadcast addresses. I didn’t dive into your iptables config, but the idea is simple - get the WOL packed on your external router interface and broadcast it into your LAN. In your case I presume you should have your router’s external interface on IPv6 and your LAN on IPv4 then do the proper routing to broadcast WOL packets to your IPv4 network.</p><p>WolOn sends a burst of WOL packets, so it’s ok if you see in logs more than one packet at a time.</p><p>I hope it helps,</p><p>Alex.</p><h3 id="Thank-you-for-your-reply"><a href="#Thank-you-for-your-reply" class="headerlink" title="Thank you for your reply."></a><strong>Thank you for your reply.</strong></h3><p>Hello!</p><p>Thank you for your prompt reply. I got you. I did add a static ARP IPv4-MAC binding rule in my router. However I have left my home and now back to campus. Maybe I should try to install a tool like <code>socat</code> or <code>xinetd</code> to forward ipv6 WAN packets as ipv4 into LAN (broadcast or directly sent to <code>192.168.123.48</code>) the next time.</p><p>You may have noticed that there was a forward rule in my first email: <code>ip6tables -I FORWARD -p udp -d 2409:8a23:a6af:c612:3129:3b6f:e6a5:844b --dport 9 -j ACCEPT</code>. It means that the ipv6 wol packets will be forwarded to the PC with this ipv6 address, but the PC didn’t receive it. If the PC was shutdown, I guess that’s because there was no MAC record coresponding to this ipv6 address. But even if the PC was on, it didn’t receive the packets. That’s one question I have.</p><p>Appreciate your efforts,</p><p>Xia.</p><h3 id="简洁翻译"><a href="#简洁翻译" class="headerlink" title="简洁翻译"></a>简洁翻译</h3><p>WOL协议在ipv6上无法工作，因为ipv6没有广播地址。路由器WAN口收到的ipv6 WOL包必须在内网以ipv4的方式广播出去。</p><h2 id="校园-x2F-办公B类网络环境"><a href="#校园-x2F-办公B类网络环境" class="headerlink" title="校园&#x2F;办公B类网络环境"></a>校园&#x2F;办公B类网络环境</h2><p>PC在<code>10.12.148.143</code>，手机在<code>10.0.161.8</code>，分属于两个路由器下的广播域，虽然可以凭借静态路由表直接互相通信，但是广播WOL包只在<code>10.0.255.255</code>下起效，<code>10.12.255.254</code>网关不会广播来自<code>10.0.x.x</code>的WOL包。</p><p>因此，跨网段只能直接发送WOL包实现唤醒，不能广播。关机后一段时间内，交换机还留存着IP地址对应的MAC地址，此时可以成功唤醒。但交换机没有设置静态ARP IP地址绑定，超过超时时间就无法唤醒了。</p><p>但是校园网的这个情况也有解决方案，在台式机与网口之间再接一台路由器。路由器长期在线，手机也可以直接给路由器发送WOL数据包，由路由器端口转发给台式机。普通路由器可能会遇到地址过期后换了新地址的问题，但如果是Padavan的话，可以进行DDNS。虽然上传的是内网NAT的WAN口地址，但是只要手机也在内网，那就可以利用域名访问。</p><p>这落后的校园网，明明去年还有2001开头的教育网IPv6，今年就没有了。打电话问了一下网络中心，被矢口否认了，便无法利用纯IPv6域名从公网访问路由器。NAT类型也只有对称型NAT4，连江苏移动都可以在路由拨号后做到全锥形NAT1，BT的末路，115大展拳脚。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LAN</code>指只填写MAC地址和广播地址的WOL方式，<code>WAN</code>指填写MAC地址和目标（主机或路由器）IP地址:端口号的WOL方式。以LAN方式直接发送给目标主机WOL包是没有意义的，因为WOL靠负载MAC工作。</p><ul><li><input checked="" disabled="" type="checkbox"> LAN 同网段广播WOL包：成功</li><li><input checked="" disabled="" type="checkbox"> LAN 跨网段广播WOL包：失败，路由器广播域隔离</li><li><input checked="" disabled="" type="checkbox"> IPv4 WAN 直接发送给目标主机WOL包：成功，若路由器未设置静态ARP IP地址绑定，则会超时失效</li><li><input checked="" disabled="" type="checkbox"> IPv4 WAN 直接发送给路由器WOL包：成功，由路由器端口转发</li><li><input disabled="" type="checkbox"> IPv6 WAN 直接发送给目标主机WOL包：失败，Padavan无法设置IPv6地址绑定，需进一步探讨原因</li><li><input checked="" disabled="" type="checkbox"> IPv6 WAN 直接发送给路由器WOL包：失败，IPv6不使用广播地址，需进行6to4转发</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP6-LISTEN:9,fork TCP4:192.168.123.48:9</span><br></pre></td></tr></table></figure><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://www.cnblogs.com/michael9/p/13360084.html">隔离广播域的 VLAN 来了 - 来份锅包肉 - 博客园</a></p><p><a href="https://serverfault.com/questions/276515/use-iptables-to-forward-ipv6-to-ipv4">port forwarding - Use iptables to forward ipv6 to ipv4? - Server Fault</a></p><p><a href="https://www.cnblogs.com/fengf233/p/10906444.html">IPv6笔记-地址结构与分类 - fengf233 - 博客园</a></p><p><a href="https://blog.51cto.com/u_7658423/1337745">IPv6的组播地址（掌握IPv6通信原理的关键知识点）_无名的基督的技术博客_51CTO博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络唤醒 </tag>
            
            <tag> IPv6 </tag>
            
            <tag> 广播 </tag>
            
            <tag> 校园网 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> Padavan </tag>
            
            <tag> 端口转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言程序设计学习笔记</title>
      <link href="/post/2022-09-13_assembler-language-notes/"/>
      <url>/post/2022-09-13_assembler-language-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记使用教材《汇编语言（第三版）》清华大学出版社</p></blockquote><h2 id="引入-进制转换"><a href="#引入-进制转换" class="headerlink" title="引入 进制转换"></a>引入 进制转换</h2><h3 id="十六转十进制"><a href="#十六转十进制" class="headerlink" title="十六转十进制"></a>十六转十进制</h3><p>就用乘法，每一位乘以 16^0, 16^1, 16^2 … 然后加在一起。</p><p>举个例子，ff bf 是几？答：65471</p><p><img src="https://static.pil0txia.com/picgo/v2-49b3cf1778203483549538d2507d7d14_r.jpg"></p><h3 id="十六转二进制"><a href="#十六转二进制" class="headerlink" title="十六转二进制"></a>十六转二进制</h3><p>更简单了，只需把每一位，变成二进制的四位数，然后拼在一起。</p><p>看个例子就懂了，ff bf 是二进制的几？答：1111 1111 1011 1111</p><p><img src="https://static.pil0txia.com/picgo/v2-fa81bde836d04d2c611e3262621a690f_r.jpg"></p><h3 id="十进制转十六"><a href="#十进制转十六" class="headerlink" title="十进制转十六"></a>十进制转十六</h3><p>稍微复杂些，用短除法。每次除以 16，把余数从下到上拼起来，就得到了 16 进制的数。</p><p>来一起试试，65471 是十六进制的几？答：ff bf</p><p><img src="https://static.pil0txia.com/picgo/v2-257788a2cf75694f6df06cde9dc5cb50_r.jpg"></p><h3 id="二进制转十六"><a href="#二进制转十六" class="headerlink" title="二进制转十六"></a>二进制转十六</h3><p>又容易了，只需切成 4 个 4 个的小段，把每段对应的字母 &#x2F; 数字拼在一起，就可以了。</p><p>比如这个例子，11 1111 1011 1111 是几？答：3f bf</p><p><img src="https://static.pil0txia.com/picgo/v2-e4a8f95238e7b5d7ffd2ced29375a3e8_r.jpg"></p><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p> 除二取余，倒序排列，高位补零。</p><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p>同十六转十进制，但16改成2</p><h3 id="巧算法"><a href="#巧算法" class="headerlink" title="巧算法"></a>巧算法</h3><p>如何快速把 2^n 的十进制数，转换为二进制？</p><p>只需把 n 除以 4，得到 j 余 i。把 i 变成 2^i 做为第一位，其余的就是，j 是几就跟几个零。</p><p><img src="https://static.pil0txia.com/picgo/v2-1bfa1c7bcc6f2cf25f51f5dc08ba47ff_r.jpg"></p><h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><h3 id="8086-访问地址"><a href="#8086-访问地址" class="headerlink" title="8086 访问地址"></a>8086 访问地址</h3><p><img src="https://static.pil0txia.com/picgo/image-20220913160043333.png" alt="image-20220913160043333"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913160006739.png" alt="image-20220913160006739"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913160226911.png" alt="image-20220913160226911"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913160311958.png" alt="image-20220913160311958"></p><p><strong>一个段的最大大小为2^16&#x3D;65536&#x3D;64K，此为偏移地址的最大表示大小FFFFH。</strong></p><p><img src="https://static.pil0txia.com/picgo/image-20220913160354815.png" alt="image-20220913160354815"></p><h3 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h3><p>代码段的段地址存放在CS中，指令指针寄存器IP指示代码段中指令的偏移地址，处理器利用CS:IP取得下一条要执行的指令。</p><p><img src="https://static.pil0txia.com/picgo/image-20220913160541141.png" alt="image-20220913160541141"></p><h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h2><h3 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h3><p><img src="https://static.pil0txia.com/picgo/image-20220913155716253.png" alt="image-20220913155716253"></p><p>(1) 20H (2) 4E20H</p><p>字节型数据＜字型数据。一个字型数据(如 1234H)存放在内存中，<strong>由2个连续的地址的内存单元组成</strong>。高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。</p><p><img src="https://static.pil0txia.com/picgo/image-20220913160921444.png" alt="image-20220913160921444"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913182153695.png" alt="image-20220913182153695"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913182321717.png" alt="image-20220913182321717"></p><p><strong>mov的大小就是al的大小</strong></p><p><img src="https://static.pil0txia.com/picgo/image-20220913175140878.png" alt="image-20220913175140878"></p><p><img src="https://static.pil0txia.com/picgo/image-20220913182520984.png" alt="image-20220913182520984"></p><p><strong>此处“一般的寄存器”就是上例中的bx</strong></p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://static.pil0txia.com/picgo/image-20220920084151074.png" alt="image-20220920084151074"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="https://static.pil0txia.com/picgo/image-20220920090126282.png" alt="image-20220920090126282"></p><p>1200+7C0A+4532+A963（舍弃溢出）</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>8086CPU入栈出栈都以字为单位，不能push&#x2F;pop一个al</p><h4 id="先进后出"><a href="#先进后出" class="headerlink" title="先进后出"></a>先进后出</h4><p><img src="https://static.pil0txia.com/picgo/image-20220920090712907.png" alt="image-20220920090712907"></p><h4 id="SS-SP"><a href="#SS-SP" class="headerlink" title="SS:SP"></a>SS:SP</h4><p><img src="https://static.pil0txia.com/picgo/image-20220920090806265.png" alt="image-20220920090806265"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920091135542.png" alt="image-20220920091135542"></p><p>入栈出栈时SP会先进行-2&#x2F;+2的操作，push时SP向上（低位）移动-2。然后将数据送入SS:SP指向的内存单元处。</p><p><img src="https://static.pil0txia.com/picgo/image-20220920094349099.png" alt="image-20220920094349099"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920094416090.png" alt="image-20220920094416090"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920094504975.png" alt="image-20220920094504975"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920094531191.png" alt="image-20220920094531191"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920094635326.png" alt="image-20220920094635326"></p><p><img src="https://static.pil0txia.com/picgo/image-20220920095356999.png" alt="image-20220920095356999"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="源程序中的“程序”"><a href="#源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h3><p>汇编源程序：</p><ul><li>伪指令（编译器处理）</li><li>汇编指令（编译为机器码）</li></ul><p>程序：源程序中最终由计算机执行、处理的指令或数据。</p><h3 id="汇编程序-amp-伪指令"><a href="#汇编程序-amp-伪指令" class="headerlink" title="汇编程序&amp;伪指令"></a>汇编程序&amp;伪指令</h3><p>codesg：标号，放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><p><img src="https://static.pil0txia.com/picgo/image-20220927170327619.png" alt="image-20220927170327619"></p><p><img src="https://static.pil0txia.com/picgo/image-20220927170240588.png" alt="image-20220927170240588"></p><h3 id="编译-amp-连接"><a href="#编译-amp-连接" class="headerlink" title="编译&amp;连接"></a>编译&amp;连接</h3><p>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；</p><p>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</p><p>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。</p><p>所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</p><h3 id="谁将可执行文件中的程序装载进入内存并使它运行？"><a href="#谁将可执行文件中的程序装载进入内存并使它运行？" class="headerlink" title="谁将可执行文件中的程序装载进入内存并使它运行？"></a>谁将可执行文件中的程序装载进入内存并使它运行？</h3><p>在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P2。</p><p>（1）我们在DOS中直接执行1.exe时，是正在运行的command将1.exe中的程序加载入内存。</p><p>（2）command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。</p><p>（3）程序运行结束后，返回到command中，CPU继续运行command</p><p><img src="https://static.pil0txia.com/picgo/image-20220927201137970.png" alt="image-20220927201137970"></p><h3 id="EXE文件中的程序的加载过程-DS"><a href="#EXE文件中的程序的加载过程-DS" class="headerlink" title="EXE文件中的程序的加载过程 DS"></a>EXE文件中的程序的加载过程 DS</h3><p><img src="https://static.pil0txia.com/picgo/image-20220927203832279.png" alt="image-20220927203832279"></p><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为：ds:0；</p><p>这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。</p><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SAX16+0。</p><p>因为PSP占256（100H）字节，所以程序的物理地址是：</p><p>SA×16+0+256&#x3D; SA×16+16×16&#x3D; (SA+16)×16+0</p><p>可用段地址和偏移地址表示为：SA+10:0</p><h3 id="程序执行过程的跟踪"><a href="#程序执行过程的跟踪" class="headerlink" title="程序执行过程的跟踪"></a>程序执行过程的跟踪</h3><p>用R命令查看各个寄存器的设置情况</p><p><img src="https://static.pil0txia.com/picgo/image-20220927211120745.png" alt="image-20220927211120745"></p><p>用U命令查看其他指令</p><p><img src="https://static.pil0txia.com/picgo/image-20220927211023177.png" alt="image-20220927211023177"></p><p>使用P命令执行int 21</p><p>使用Q命令退出Debug</p><h2 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h2><h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221004_082246.jpg" alt="IMG_20221004_082246"></p><p>程序解读见书P124。<code>mov ax,4c00h</code>代表终止。</p><p>程序6.2</p><p>end start除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p><h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>程序6.3</p><p>30h是48字节，正好对应dw分配的16个字型数据，用于栈的空间。</p><h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>程序6.4</p><p>cs是自动装载的，不用在代码段中指定cs的指向。</p><ul><li><p>为什么<code>mov bx,0</code>可以将ds:bx指向data段中的第一个单元？</p><p>因为0被认为是ds,[0]</p></li><li><p>为什么<code>mov cx,5</code>表示循环5次？</p><p>cs用来控制循环次数，每次执行loop指令时，都会检查cs的值是否为0</p></li></ul><h2 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>程序7.1</p><p>inc 加1，而不是加2，因为一个ASCII码占一个字节</p><h3 id="bx-idata-寄存器相对寻址"><a href="#bx-idata-寄存器相对寻址" class="headerlink" title="[bx+idata] 寄存器相对寻址"></a>[bx+idata] 寄存器相对寻址</h3><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata（bx中的数值加上idata）</p><p><code>mov ax,[bx+200]</code></p><p>数学化描述：(ax)&#x3D;((ds)*16+(bx)+200)</p><h3 id="SI和DI-基址变址寻址"><a href="#SI和DI-基址变址寻址" class="headerlink" title="SI和DI 基址变址寻址"></a>SI和DI 基址变址寻址</h3><p>类似于bx，但是不能分成两个8位寄存器</p><p>段寄存器、两个内存单元之间、两个段之间都不能直接mov，需要用寄存器中转</p><blockquote><p>SI元变址寄存器</p><p>DI目的变址寄存器</p></blockquote><h3 id="相对基址变址寻址（-bx-si-idata-和-bx-di-idata-）"><a href="#相对基址变址寻址（-bx-si-idata-和-bx-di-idata-）" class="headerlink" title="相对基址变址寻址（[bx+si+idata]和[bx+di+idata]）"></a>相对基址变址寻址（[bx+si+idata]和[bx+di+idata]）</h3><p>问题7.1、7.3、7.4、7.5的分析很实用</p><h2 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h2><blockquote><p>用reg表示一个寄存器，sreg表示段寄存器</p></blockquote><h3 id="bx，si，di，bp"><a href="#bx，si，di，bp" class="headerlink" title="bx，si，di，bp"></a>bx，si，di，bp</h3><p>bp用于在堆栈段上寻址，bs默认用于数据段寻址。都是基址(base)</p><p>“两个i不相见，两个b不相见”</p><p>错误指令：</p><p><code>mov ax,[bx+bp]</code></p><p><code>mov ax,[si+di]</code></p><p>只要在[…]中使用寄存器bp，且指令中没有显性地给出段地址，段地址就<a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5">默认在ss中</a>。</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>P164 表8.2</p><h3 id="指令要处理的数据有多长？"><a href="#指令要处理的数据有多长？" class="headerlink" title="指令要处理的数据有多长？"></a>指令要处理的数据有多长？</h3><p><code>word ptr</code>和<code>byte ptr</code>来显式的指定内存单元的长度</p><p>P166: <code>mov word ptr [1000H],1</code> -&gt; 0100FF</p><h3 id="div指令-书P169"><a href="#div指令-书P169" class="headerlink" title="div指令 书P169"></a>div指令 书P169</h3><p><code>div byte ptr ds:[0]</code></p><p>(al) &#x3D; (ax) &#x2F; ((ds) * 16 + 0)的商</p><p>(ah) &#x3D; (ax) &#x2F; ((ds) * 16 + 0)的余数</p><p><code>div word ptr es:[0]</code></p><p>(ax) &#x3D; [(dx) * 10000H + (ax)] &#x2F; ((es) * 16 + 0)的商</p><p>(dx) &#x3D; [(dx) * 10000H + (ax)] &#x2F; ((es) * 16 + 0)的余数</p><blockquote><p>低商高余</p></blockquote><blockquote><p>例题</p><p>mov ax,data</p><p>mov ds,ax</p><p>mov ax,ds[0]</p><p>mov dx,ds[2]</p><p>div word ptr ds:[4]</p></blockquote><h2 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>P175、176</p><blockquote><p>问题9.1 为什么要加<code>cs:</code>？</p></blockquote><p>不加冒号复制的是默认ds段</p><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>讲得太快</p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="PF标志（Parity）"><a href="#PF标志（Parity）" class="headerlink" title="PF标志（Parity）"></a>PF标志（Parity）</h3><p>表示奇偶性，1的个数为奇数时PF&#x3D;0，为偶数个时PF为1</p><h3 id="SF标志（Sign）"><a href="#SF标志（Sign）" class="headerlink" title="SF标志（Sign）"></a>SF标志（Sign）</h3><p>结果为负那么SF&#x3D;1，结果非负数则SF&#x3D;0；</p><h3 id="ZF标志（Zero）"><a href="#ZF标志（Zero）" class="headerlink" title="ZF标志（Zero）"></a>ZF标志（Zero）</h3><p>结果为0那么ZF&#x3D;1,结果不为0则ZF&#x3D;0；</p><h3 id="CF标志（Carry）"><a href="#CF标志（Carry）" class="headerlink" title="CF标志（Carry）"></a>CF标志（Carry）</h3><p>mov al,97H</p><p>sub al,98H</p><p>执行后：(al)&#x3D;FFH, CF&#x3D;1, CF记录了向更高位的借位值</p><p>10010111</p><p>10011000</p><p>(-1)11111111</p><p>FFH</p><h3 id="OF标志（Overflow）"><a href="#OF标志（Overflow）" class="headerlink" title="OF标志（Overflow）"></a>OF标志（Overflow）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,98</span><br><span class="line">add al,99</span><br></pre></td></tr></table></figure><p>执行后CF&#x3D;0, OF&#x3D;1</p><p>对于无符号数运算，没有进位，CF&#x3D;0；对于有符号数运算，发生了溢出（数值位向符号位进了一位，虽然污染了符号位，但此时数还是八位。如果进到第九位，则产生了进位），OF&#x3D;1</p><h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add ax,ax</span><br><span class="line">adc ax,3</span><br></pre></td></tr></table></figure><p>adc利用了CF，执行时相当于计算(ax)+3+CF&#x3D;2+3+0&#x3D;5</p><p>计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>adc的减法版</p><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>不保存结果的减法比较，仅仅根据结果设置标志位</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221101_091647.jpg" alt="IMG_20221101_091647"></p><p>cmp比较大小不能仅靠SF，因为可能溢出，还需要借助OF</p><ul><li><p>SF&#x3D;1, OF&#x3D;0，说明没有溢出，逻辑上结果正负&#x3D;实际上结果正负，即ah＜bh</p></li><li><p>SF&#x3D;1, OF&#x3D;1，溢出会污染符号位，正负性颠倒，即ah＞bh</p></li><li><p>SF&#x3D;0, OF&#x3D;1，跟刚才逻辑一样，ah＜bh</p></li><li><p>SF&#x3D;0, OF&#x3D;0，ah＞bh；若ZF&#x3D;0，则ah&#x3D;bh</p></li></ul><p>任意一个为1，另一个为0时，前者＜后者</p><h3 id="je指令等"><a href="#je指令等" class="headerlink" title="je指令等"></a>je指令等</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221101_093204.jpg" alt="IMG_20221101_093204"></p><p>有符号位的是jl（小于）、jg（大于）</p><h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>df&#x3D;0 每次操作后si、di递增</p><p>df&#x3D;1 每次操作后si、di递减</p><p>movsb将ds:si指向的内存单元的一个字节送入es:di中，然后根据df位的值，将si和di递增或递减</p><p>movsw</p><p>rep</p><h2 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h2><p>中断向量表 四个单元</p><p>do0</p><h2 id="第十三章-int指令"><a href="#第十三章-int指令" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h2><p>int n，n是中断类型码，功能是引发中断，相当于引发一个n号中断的中断过程，执行过程：</p><p>标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；CS、IP入栈；(IP)&#x3D;(n*4), (CS)&#x3D;(n*4+2)</p><h3 id="13-5-BIOS和DOS中断例程的安装过程"><a href="#13-5-BIOS和DOS中断例程的安装过程" class="headerlink" title="13.5 BIOS和DOS中断例程的安装过程"></a>13.5 BIOS和DOS中断例程的安装过程</h3><p>编程时可以用int指令调用BIOS和DOS提供的中断例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不重要</span><br><span class="line">mov ah,9 //调用设置光标的子程序</span><br><span class="line">mov al,&#x27;a&#x27;</span><br><span class="line">mov bh,7 //颜色设置</span><br></pre></td></tr></table></figure><h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><p>逻辑移位指令。将一个寄存器或内存单元中的数据向左移位，最后移出的一位写入CF中，最低为用0来补充。移动位数大于1时，必须把移动位数放在cl中。</p><p>shl左移，shr右移。会影响到符号位。（算术右移不会影响符号位）</p><h2 id="期末考试复习"><a href="#期末考试复习" class="headerlink" title="期末考试复习"></a>期末考试复习</h2><p>选择，可能有判断题</p><p>写一些指令，进行纠正</p><p>2道编程题</p><p>宏不作要求</p><p>一直到系统调用，比较重要</p><p><a href="https://github.com/sanmianti/AssemblyLanguageTest/blob/master/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.md">https://github.com/sanmianti/AssemblyLanguageTest/blob/master/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大三上 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记</title>
      <link href="/post/2022-09-08_os-notes/"/>
      <url>/post/2022-09-08_os-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><h2 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h2><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220908221259.png"></p><h2 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h2><p><a href="https://blog.csdn.net/PriceCheap/article/details/125256919">多道批处理系统宏观上并行微观上串行的含义</a></p><p><img src="https://static.pil0txia.com/picgo/image-20220908223051244.png" alt="image-20220908223051244"></p><p><img src="https://static.pil0txia.com/picgo/image-20220908224939144.png" alt="image-20220908224939144"></p><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p><strong>一个宏观的时间段内，单CPU核心处理多个进程任务，称为并发；多CPU核心在同一时间处理多个进程任务，称为并行。</strong></p><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p><img src="https://static.pil0txia.com/picgo/image-20220908225751025.png" alt="image-20220908225751025"></p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p><img src="https://static.pil0txia.com/picgo/image-20220908230010886.png" alt="image-20220908230010886"></p><p><img src="https://static.pil0txia.com/picgo/image-20220908230154923.png" alt="image-20220908230154923"></p><h2 id="操作系统的四个基础特性"><a href="#操作系统的四个基础特性" class="headerlink" title="操作系统的四个基础特性"></a>操作系统的四个基础特性</h2><p><strong>并发性，共享性，虚拟性，异步性</strong></p><p>异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。</p><h2 id="现代OS的基本单位"><a href="#现代OS的基本单位" class="headerlink" title="现代OS的基本单位"></a>现代OS的基本单位</h2><p>内核、进程、线程、类程、管程</p><h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><p><img src="https://static.pil0txia.com/picgo/image-20220919150833779.png" alt="image-20220919150833779"></p><p><a href="https://chorer.github.io/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">Focus on FE learning 操作系统学习笔记-2：体系结构设计和运行机制</a></p><p><a href="https://quemingfei.com/archives/wang-dao-kao-yan-cao-zuo-xi-tong-xue-xi-bi-ji-hui-zong">《王道考研 操作系统》学习笔记汇总</a></p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><img src="https://static.pil0txia.com/picgo/image-20220922101548539.png" alt="image-20220922101548539"></p><p>微内核中，应用程序与OS内核的通信：系统调用；非内核功能（用户空间的OS）和OS内核的通信：消息传递；非内核功能之间的通信：直接调用。</p><p>用户态切换到内核态的3种方式：系统调用、异常、外围设备的中断</p><p>内核态切换到用户态的方式：特权指令，设置程序状态字为PSW</p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断的类型：内中断（也称为“异常”、例外）；外中断（也称为“中断”）</p><p>内中断的案例：非法指令；应用程序请求操作系统时发出“陷入指令”，该指令会引发一个内部中断指令，意味着应用程序主动将CPU控制权还给OS。“系统调用”就是通过陷入指令完成。</p><p>中断处理程序一定是内核程序，需要运行在“内核态”。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是应用程序获得OS服务的唯一途径。内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。</p><h3 id="系统调用的方式"><a href="#系统调用的方式" class="headerlink" title="系统调用的方式"></a>系统调用的方式</h3><p>用户-&gt;应用程序-&gt;系统调用（系统调用组成了程序接口API，每一个系统调用都是一个完成特定功能的子程序）-&gt;OS内核（裸机）</p><p>用户-&gt;图形窗口-&gt;OS内核（裸机）</p><p>用户-&gt;操作命令-&gt;系统程序（操作接口由一组控制命令和作业控制语句组成）-&gt;OS内核（裸机）</p><h3 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h3><p>应用程序不可以直接调用系统调用，是通过库函数调用系统调用的。</p><p><img src="https://static.pil0txia.com/picgo/image-20220922111334895.png" alt="image-20220922111334895"></p><h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><p><img src="https://static.pil0txia.com/picgo/image-20220922111557735.png" alt="image-20220922111557735"></p><p><strong>冷启动</strong></p><p>（1）开机执行BIOS引导程序，标识和配置所有的即插即用设备，并配置DMA通道</p><p>（2）完成加电自检，测试内存，端口，键盘，视频适配器，磁盘驱动器等基本设备，及CD-ROM驱动器。</p><p>（3）对引导驱动器引导分区定位：在CMOS中，可以自行设置引导顺序，一般顺序是软盘，磁盘，光驱；</p><p>（4）加载主引导记录以及引导驱动器的分区表，执行主引导记录MBR。</p><p>（5）装入操作系统</p><p><strong>热启动</strong></p><p>（1）BOOT被自动执行，指引CPU把操作系统从大容量存储器中传送到主存储器的易失区；</p><p>（2）BOOT要求CPU执行一条转移指令，转到这个存储区域；此时，操作系统接管并且开始控制整个机器的活动。</p><h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><p>为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？</p><p>采用多道程序设计减少了CPU时间的浪费，增加了系统吞吐量，提高了系统的效率。.多道程序并发执行是指有的程序正在CPU上执行，而另一些程序正在I&#x2F;O设备上进行传输，即通过CPU操作与外设传输在时间上的重叠减少CPU时间的浪费，并提高了系统的效率。实现CPU操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：</p><p>（1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立与CPU运行，因而做到了输入输出操作与CPU并行工作。但早期CPU与通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到CPU与I&#x2F;O设备并行工作的。</p><p>（2）在硬件上引入了中断技术。所谓中断，就是在输入输出结束时，或硬件发生某种故障时，由相应硬件（即中断机构）向CPU发出信号。这时CPU立即停下手头的工作而转向处理中断请求，道处理完中断后再继续原来手头的工作。因此，通道技术和中断技术结合起来就可实现CPU与I&#x2F;O设备并行工作，即CPU启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作。这样，就真正做到了CPU与I&#x2F;O设备并行工作。此时，多道程序的概念才变为现实。</p><h2 id="作业2（书面版进行了概括）"><a href="#作业2（书面版进行了概括）" class="headerlink" title="作业2（书面版进行了概括）"></a>作业2（书面版进行了概括）</h2><ol><li><p>设计现代OS的主要目标是什么？</p><p>方便性，有效性，可扩充性，开放性</p></li><li><p>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。</p><p>（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微秒。</p><p>（2）交互性：实时信息处理系统具有交互性，但实时终端设备只是作为执行装置或咨询装置，人与系统的交互仅限于访问系统中某些特定的专用服务程序。分时系统的用户可以与系统进行人机交互，包括在终端上可以直接调试自己的程序，系统能向终端用户提供数据和资源共享等服务。</p><p>（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。</p></li><li><p>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？</p><p>（1）OS 环境下与一般情况下的资源共享间的不同点</p><p>①一般情况下的共享</p><p>一般情况下的共享只是说明某种资源能被大家使用，对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。</p><p>②OS 环境下的共享</p><p>OS 环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。</p><p>（2）独占资源应采取的共享方式</p><p>对独占资源应采用互斥共享方式，该共享方式仅当占有该资源的进程访问并释放资源后，才允许另一进程对该资源进行访问。</p></li><li><p>什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。</p><p>（1）时分复用技术的定义<br>时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。<br>（2）时分复用技术能提高资源利用率的根本原因<br>时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务使设备得到最充分的利用。</p></li><li><p>何谓微内核技术？在基于微内核结构的OS中，应用了哪些新技术？在微内核中通常提供了哪些功能？</p><p>（1）把操作系统中更多的成分和功能放到更高的层次(即用户模式)中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。 </p><p>（2）面向对象的程序设计技术。</p><p>（3）在微内核中通常提供了进程(线程)管理、低级存储器管理、中断和陷入处理等功能。</p></li></ol><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>最近我的操作系统老师和软件工程老师都在上课时讲鸿蒙OS有多么多么划时代，可事实上并非如此。我一问才知道，是华为有人找他们合作，让他们上课时多放入一点鸿蒙的知识。我理解鸿蒙是一个较为优秀的国产定制系统，但是把它等同于目前所有系统、实时操作系统的下一代系统，实在太误人子弟。</p><p>19年鸿蒙说是要完全自主开发内核，22年现在却在用AOSP<code>Andriod Open Source Project</code>；“分布式”有两个，真正意义上的分布式可以同步两台设备上同一版本软件的操作，目前还停留在SDK阶段，大肆宣传的那个分布式不过是投屏罢了。</p><p>要说怪谁，只能怪一开始饼画太大，缺口已经补不上了。其实按照开源协议使用开源代码不丢人，丢人的是欲盖弥彰啊。</p><h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="程序的基本概念"><a href="#程序的基本概念" class="headerlink" title="程序的基本概念"></a>程序的基本概念</h2><p><img src="https://static.pil0txia.com/picgo/image-20220926155011586.png" alt="image-20220926155011586"></p><p>可再现性</p><h3 id="为什么程序不能调度？"><a href="#为什么程序不能调度？" class="headerlink" title="为什么程序不能调度？"></a>为什么程序不能调度？</h3><p>程序具有独立性，结果再现。如果程序执行过程中，出现结果无法再现的情况，则程序肯定有问题。如果要让程序被调度，必须满足Berstein条件（任意两条读写的交集不能为空，很难实现）。</p><h3 id="判断程序是否可以并发"><a href="#判断程序是否可以并发" class="headerlink" title="判断程序是否可以并发"></a>判断程序是否可以并发</h3><p><img src="https://static.pil0txia.com/picgo/image-20220926154724920.png" alt="image-20220926154724920"></p><p><img src="https://static.pil0txia.com/picgo/image-20220926154807286.png" alt="image-20220926154807286"></p><p>（1）程序顺序执行，因为某一时段独占全机，所以结果可再现。</p><p>（2）程序并发执行，若不满足Bernstein条件，则结果不再现。</p><p>总之，程序不可以并发执行。</p><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。</p><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p><img src="https://static.pil0txia.com/picgo/image-20220926164342078.png" alt="image-20220926164342078"></p><p>正是因为有了PCB，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但PCB可以记录此时进程的状态。所以进程是“动态”的。</p><blockquote><p>简答题“程序为什么不能被调度+进程为什么可以并发执行”是捆绑在一起的。</p></blockquote><p>父&#x2F;子标识指向父&#x2F;子进程的PID</p><ul><li>进程调度信息</li></ul><p>进程的状态：三态、五态、七态</p><p>进程的优先级：一个整数</p><p>进程调度需要的信息：如等待CPU的时间、执行CPU的时间等等，是调度的一个参考。</p><p>阻塞原因：执行-&gt;阻塞状态转换发生的事件</p><ul><li>进程的控制信息</li></ul><p>程序和数据在内存、外存的地址</p><p>进程同步和通信机制</p><p>资源清单：列出除了CPU以外进程所需资源和已经拿到的资源。</p><p>链接指针：指出本进程的pcb在pcb队列中下一个进程的pcb首地址</p><h3 id="进程控制块PCB的组织方式"><a href="#进程控制块PCB的组织方式" class="headerlink" title="进程控制块PCB的组织方式"></a>进程控制块PCB的组织方式</h3><p><img src="https://static.pil0txia.com/picgo/image-20220926165848247.png" alt="image-20220926165848247"></p><p><img src="https://static.pil0txia.com/picgo/image-20220926170442110.png" alt="image-20220926170442110"></p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote><p>为什么程序不能被调度？为什么要引入进程？</p></blockquote><p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E8%B0%83%E5%BA%A6%EF%BC%9F">为什么程序不能调度？</a></p><p><a href="#%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%8F%91">为什么程序不能并发？</a></p><p><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB">为什么要引入进程？</a></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制由“<strong>原语</strong>”实现。原语具有“原子性”，要么不被执行，一旦被执行，不可以被中断。</p><p>在<strong>关中断指令</strong>下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在<strong>开中断指令</strong>下，才会去处理中断。</p><p>原语的基本操作包括：</p><ul><li>更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）</li><li>将 PCB 插入到合适的队列</li><li>分配&#x2F;回收资源</li></ul><p>创建原语和撤销原语配对，阻塞原语和唤醒原语配对。</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_104925.jpg" alt="IMG_20221006_104925"></p><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_111051.jpg" alt="IMG_20221006_111051"></p><p>进程的执行是“异步”的，进程的控制是“原子性”的。</p><h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_111447.jpg" alt="IMG_20221006_111447"></p><p>阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在CPU中。</p><h4 id="五态"><a href="#五态" class="headerlink" title="五态"></a>五态</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_153725.jpg" alt="IMG_20221006_153725"></p><p><img src="https://static.pil0txia.com/picgo/image-20221006134335445.png" alt="image-20221006134335445"></p><p>创建进程的过程在内存里完成。</p><h4 id="七态（重要，在后面的章节会有所拓展）"><a href="#七态（重要，在后面的章节会有所拓展）" class="headerlink" title="七态（重要，在后面的章节会有所拓展）"></a>七态（重要，在后面的章节会有所拓展）</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg" alt="IMG_20221006_153249"></p><h5 id="静止阻塞-x2F-就绪队列的理解"><a href="#静止阻塞-x2F-就绪队列的理解" class="headerlink" title="静止阻塞&#x2F;就绪队列的理解"></a>静止阻塞&#x2F;就绪队列的理解</h5><p>当我们把作业从外存拿到内存时，这个过程叫做高级调度。</p><p>进程PCB被创建后，PCB存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。</p><p>如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。</p><p>如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。</p><h5 id="挂起的原因"><a href="#挂起的原因" class="headerlink" title="挂起的原因"></a>挂起的原因</h5><p>负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要</p><h5 id="挂起的特征"><a href="#挂起的特征" class="headerlink" title="挂起的特征"></a>挂起的特征</h5><ul><li>该进程不能立即被执行</li><li>挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>进程进入挂起状态是由于操作系统父进程或进程本身阻止它的运行</li><li>结束进程挂起状态的命令只能通过操作系统或父进程发出</li></ul><h5 id="状态转换的汇总"><a href="#状态转换的汇总" class="headerlink" title="状态转换的汇总"></a>状态转换的汇总</h5><table><thead><tr><th align="center">状态</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">活动就绪态 → 静止就绪态</td><td align="center">操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。<strong>处于静止就绪态的进程不再被调度执行</strong>；</td></tr><tr><td align="center">静止就绪态 → 活动就绪态</td><td align="center">内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行</td></tr><tr><td align="center">活动阻塞态→ 静止阻塞态</td><td align="center">操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。</td></tr><tr><td align="center">静止阻塞态→ 静止就绪态</td><td align="center">常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态</td></tr><tr><td align="center">静止阻塞态→ 活动阻塞态</td><td align="center">但有时候，如果<strong>静止阻塞态进程</strong>的优先级高于<strong>静止就绪队列中的任何进程</strong>、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态</td></tr><tr><td align="center">运行态→ 静止就绪态</td><td align="center">优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态</td></tr><tr><td align="center">创建态→ 静止就绪态</td><td align="center">操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存</td></tr></tbody></table><p>进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。</p><h3 id="进程的创建（创建原语）"><a href="#进程的创建（创建原语）" class="headerlink" title="进程的创建（创建原语）"></a>进程的创建（创建原语）</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221010_143627.jpg" alt="IMG_20221010_143627"></p><ol><li>申请空白PCB</li><li>为新进程分配其运行所需的资源</li><li>初始化PCB</li><li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。</li></ol><h3 id="进程的终止（撤销原语）"><a href="#进程的终止（撤销原语）" class="headerlink" title="进程的终止（撤销原语）"></a>进程的终止（撤销原语）</h3><p>引起进程终止的事件包括正常结束、异常结束和外界干预。</p><p>终止进程的过程包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221006_114004.jpg" alt="IMG_20221006_114004"></p><ol><li>进入终止态的进程不能再执行</li><li>OS中保留其记录（状态码+计时统计数据），供其他进程收集</li><li>一旦其他进程完成了对终止状态进程的信息提取，OS将删除该进程</li></ol><h3 id="进程的阻塞（阻塞原语block）"><a href="#进程的阻塞（阻塞原语block）" class="headerlink" title="进程的阻塞（阻塞原语block）"></a>进程的阻塞（阻塞原语block）</h3><p>阻塞进程的过程包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的阻塞队列（即改变它的链接地址）。</p><p>引起进程阻塞的事件一般是：</p><ul><li>请求系统分配共享资源失败（系统已无足够的资源）</li><li>等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 I&#x2F;O 操作）</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ul><blockquote><p>进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程<strong>自己调用了</strong>阻塞原语。</p></blockquote><h3 id="进程的唤醒（唤醒原语wake-up）"><a href="#进程的唤醒（唤醒原语wake-up）" class="headerlink" title="进程的唤醒（唤醒原语wake up）"></a>进程的唤醒（唤醒原语wake up）</h3><p>唤醒进程的过程包括：在事件阻塞队列中找到 PCB 并将进程移出队列，修改 PCB 的状态信息，再将 PCB 插入到就绪队列。</p><p>一般在等待的事件发生时，进程就会被唤醒。</p><blockquote><p>阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程<strong>自己调用了</strong>唤醒原语，而是“合作”或相关进程进行了调用。</p></blockquote><h3 id="进程的切换（切换原语）"><a href="#进程的切换（切换原语）" class="headerlink" title="进程的切换（切换原语）"></a>进程的切换（切换原语）</h3><p>前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。</p><p>切换原语负责让当前运行的进程从 A 切换为 B，具体包括：</p><ul><li>一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）</li><li>另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）</li></ul><p>引起进程切换的事件一般有四种：</p><ul><li>当前进程的时间片被消耗完</li><li>有更高优先级的进程到达，抢占了当前进程正在使用的 CPU</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="进程的挂起（挂起原语suspend和激活原语active）"><a href="#进程的挂起（挂起原语suspend和激活原语active）" class="headerlink" title="进程的挂起（挂起原语suspend和激活原语active）"></a>进程的挂起（挂起原语suspend和激活原语active）</h3><p><strong>挂起原语：</strong></p><p>将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（活动就绪态 -&gt; 静止就绪态，活动阻塞态 -&gt; 静止阻塞态），之后将该 PCB 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。</p><p>引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。</p><p><strong>激活原语：</strong></p><p>将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态-&gt;活动就绪态，静止阻塞 -&gt; 活动阻塞态）。</p><p>引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。</p><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>结构性：程序块、数据块、进程控制块PCB</p><p>动态性：进程是程序在数据集合上的一次执行过程，有生命周期（由创建而产生、由调度而执行、由事件而等待、由撤销而消亡）</p><p>并发性：多个进程实体同时存在在内存中，能在一段时间内同时运行，是进程的重要特征</p><p>独立性：进程是独立运行、独立获取资源、独立接受调度的基本单位 -&gt; 线程就不独立，它没有资源，依赖于fork的进程的资源</p><p>异步性：进程按各自独立的、不可预知的速度向前推进。OS要根据“进程同步机制”来解决异步问题。</p><p>操作系统的“虚拟性”是进程所没有的。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。然而，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为<strong>临界资源</strong>——也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。我们通过<strong>进程互斥</strong>来解决此类问题。</p></blockquote><p>进程同步：指多个相关进程在执行次序上的协调</p><p>进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问</p><p>临界资源：一次仅供一个进程使用的资源</p><p>临界区：在进程中涉及到临界资源的程序段叫临界区</p><p>相关临界区：多个进程的临界区称为相关临界区</p><h4 id="进程互斥的基本实现逻辑"><a href="#进程互斥的基本实现逻辑" class="headerlink" title="进程互斥的基本实现逻辑"></a>进程互斥的基本实现逻辑</h4><p>为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    extry section;       <span class="comment">// 进入区</span></span><br><span class="line">    critical section;    <span class="comment">// 临界区</span></span><br><span class="line">    exit section;        <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;   <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li>进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；</li><li>临界区：实际访问临界资源的那段代码</li><li>退出区：负责解除之前的 Flag</li><li>剩余区：其它处理</li></ul><p>对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。</p><h4 id="同步机制应遵循的原则"><a href="#同步机制应遵循的原则" class="headerlink" title="同步机制应遵循的原则"></a>同步机制应遵循的原则</h4><p>空闲让进：临界区空闲时，应该让想要进入临界区的进程立刻进来</p><p>忙则等待：同一时刻只允许一个进程进入临界区</p><p>有限等待：要求访问临界资源的进程，应该保证在有限时间内进入临界区</p><p>让权等待：当 A 进程进入临界区而导致 B 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入“忙等”状态。</p><h3 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h3><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制可以让用户通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而方便地实现进程互斥和进程同步。信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语（或者说是 P 操作和 V 操作，即通过和释放），可以看作是两个函数。</p><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int S = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">wait</span>(<span class="params">int S</span>)               </span><br><span class="line">&#123;                       </span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)</span><br><span class="line">    S = S-<span class="number">1</span>              </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">int S</span>)</span><br><span class="line">&#123;</span><br><span class="line">    S = S+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样以进程 P0，P1 为例进行说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">P0</span>：                   <span class="attr">P1</span>:</span><br><span class="line"><span class="title function_">wait</span>(S)                <span class="title function_">wait</span>(S)            <span class="comment">// 进入区</span></span><br><span class="line">critical section       critical section   <span class="comment">// 临界区</span></span><br><span class="line"><span class="title function_">signal</span>(S)              <span class="title function_">signal</span>(S)          <span class="comment">// 退出区 </span></span><br></pre></td></tr></table></figure><p>假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行“检查”和“上锁”，由于 S 一开始是1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S &#x3D; 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。</p><p>整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查”和“上锁”两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是<strong>仍然违背了“让权等待”的原则</strong>。</p><p>于是在此基础上，又出现了记录型信号量</p><h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 <code>value</code>，而且还提供了一个等待队列 <code>L</code>。</p><p>记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，<strong>直接让它自己去阻塞队列</strong>，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。</p><p>记录型信号量的结构如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value</span><br><span class="line">    sturct process *L</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure><p>同时，记录型信号量的 P、V 操作也有所不同，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait (semaphore S)&#123;</span><br><span class="line">    S.<span class="property">value</span>--</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">block</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">semaphore S</span>)&#123;</span><br><span class="line">    S.<span class="property">value</span>++</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="property">value</span> &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">wakeup</span>(S.<span class="property">L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里要注意的第一个地方是，<code>value</code> 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。</li><li>第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿</li><li>执行++或–前，<code>S.value</code>为正值时代表可利用的物理资源数；<code>S.value</code>为负值时，其绝对值代表阻塞队列中等待的进程数。</li></ul><p>下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PO</span>:            <span class="variable constant_">P1</span>              <span class="variable constant_">P2</span>           <span class="variable constant_">P3</span></span><br><span class="line"><span class="title function_">wait</span>(S)        <span class="title function_">wait</span>(S)         <span class="title function_">wait</span>(S)      <span class="title function_">wait</span>(S)</span><br><span class="line">临界区          临界区           临界区        临界区</span><br><span class="line"><span class="title function_">signal</span>(S)      <span class="title function_">signal</span>(S)       <span class="title function_">signal</span>(S)    <span class="title function_">signal</span>(S)</span><br></pre></td></tr></table></figure><p>假设计算机中有两台可用的打印机 A 和 B（也就是说，value &#x3D; 2），有四个进程需要用到打印机资源。</p><p>一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始“干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区“干活”。自此，两个打印机都被占用了。</p><p>在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 &lt; 0，前面我们说过，value &lt; 0 说明无可用资源，所以此时 P2 将自己<strong>主动</strong>送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。</p><p>处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。</p><p>当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。</p><p>显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常“老实”地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法“既方便了别人，也方便了自己”。这就正好与我们多次强调的“让权等待”非常契合了。</p><blockquote><p>记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。</p></blockquote><p>我们通过几道题加深一下印象：</p><ul><li>n 个并发进程，信号量初始值为 1，当 n 个进程都执行 P 操作后，信号量的值为多少？</li><li>信号量初值为 4，多次 PV 操作后变为 -2，那么获得资源的进程数目是多少？</li><li>5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？</li></ul><p>（1）每执行一次 P 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 P 操作，所以此后信号量的值是 1-n</p><p>（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源</p><p>（3）信号量初始值为3，所以最大值为3，如果 5 个进程都执行 P 操作，那么信号量会变成 3-5 &#x3D; -2，即最小值为 -2，所以取值范围 -2 ~ 3。</p><h4 id="信号量机制实现"><a href="#信号量机制实现" class="headerlink" title="信号量机制实现"></a>信号量机制实现</h4><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>其实上面讲的例子就已经很好地实现了进程互斥，但是我们可以简化一下写法，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">P0</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex) <span class="comment">//使用临界资源前需要加锁</span></span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex) <span class="comment">//使用临界资源前需要解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">P</span>(mutex)</span><br><span class="line">    critical section <span class="comment">//临界区代码段</span></span><br><span class="line">    <span class="title function_">V</span>(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们默认已经定义了 semaphore 的结构体，并用<strong>互斥信号量 mutex</strong> 记录可用资源的个数（进入临界区的名额），初始值为1。要实现互斥，关键就是要<strong>在临界区之前使用 P 操作进行上锁，在临界区之后使用 V 操作进行解锁</strong>。</p><p>PV操作要成对出现，但不一定要在同一个进程中。不同的临界资源设置不同的互斥信号量。记录型信号量有时需要自己定义。</p><h5 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h5><p>多个进程（如P1、P2）一起完成某项任务的时候，如何确保它们按照一定的先后顺序（先P1后P2）有秩序地执行呢？信号量机制也可以很好地实现进程同步。它有三个关键步骤：</p><ul><li>设置<strong>同步信号量</strong>初始值为 0</li><li>在“前操作”之后执行 V(S)</li><li>在“后操作”之前执行 P(S)</li></ul><p>首先，<strong>0 是一个非常关键的“分水岭”</strong>，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。</p><p>我们要确保“前操作”在前面，“后操作”在后面，实际上只要做到三件事：V 在“前操作”后面、P 在“后操作”前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而<strong>要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0</strong>，因为一旦初始值为 0，则每当 P 想要“违规”抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：</p><p><strong>P 先于 V 执行 &#x3D;&gt; P 所在进程会被阻塞 &#x3D;&gt; ”后操作“始终无法执行</strong></p><p>所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在“前操作”后面，所以一定是“前操作”执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— <strong>虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞</strong>，所以 P 执行完后就顺序执行“后操作”。由此，我们确保了两个操作一定是严格按照先后顺序执行的。</p><p>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序应该是：code1,code2,code4</span></span><br><span class="line"><span class="variable constant_">P0</span>：                 <span class="attr">P1</span>:</span><br><span class="line">code <span class="number">1</span>               <span class="title function_">P</span>(S)</span><br><span class="line">code <span class="number">2</span>               code <span class="number">4</span></span><br><span class="line"><span class="title function_">V</span>(S)                 code <span class="number">5</span></span><br><span class="line">code <span class="number">3</span>               code <span class="number">6</span></span><br></pre></td></tr></table></figure><p>我们设想比较差的情况 —— P1 想要抢先执行 code 4，看看会发生什么。假设是 P1 首先占用处理机，那么就会执行 P 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 P1 进程阻塞；这之后，处理机来到 P0，执行 code1，code2，V 操作，使得信号量由 -1 变成 0，同时唤醒 P1 进程；P1 进程被唤醒后从 P 操作之后的断点继续执行（P1 被唤醒后不会重新再执行一遍P操作，否则会再次进入阻塞。与七态中进程所需资源得到满足后会从阻塞队列转入就绪队列相同，P1 会接着之前停下的地方继续），来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。</p><h5 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h5><p>前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code 语句仍然是前操作或者后操作，P1 进程有 code1 语句，P2 进程有 code2 语句… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。</p><p><img src="https://static.pil0txia.com/picgo/20221017092030.png"></p><p>其实这种情况就是把多个同步问题结合起来，我们仍然可以用信号量机制来实现：</p><ul><li>每一个前驱关系都是一个同步问题，要保证一前一后的操作</li><li>为每一个前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行V操作</li><li>在“后操作”之前对相应的同步信号量执行P操作</li></ul><p>代码大概如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:          <span class="attr">P3</span>:          <span class="attr">P4</span>:        </span><br><span class="line">code1        <span class="title function_">P</span>(signal1)   <span class="title function_">P</span>(signal2)   <span class="title function_">P</span>(signal3)</span><br><span class="line"><span class="title function_">V</span>(signal1)   code2        code3        code4 </span><br><span class="line"><span class="title function_">V</span>(signal2)   <span class="title function_">V</span>(signal3)   <span class="title function_">V</span>(signal7)   <span class="title function_">V</span>(signal5)</span><br><span class="line">             <span class="title function_">V</span>(signal4)</span><br><span class="line"><span class="attr">P5</span>:          <span class="attr">P6</span>:         </span><br><span class="line"><span class="title function_">P</span>(signal4)   <span class="title function_">P</span>(signal5)   </span><br><span class="line">code5        <span class="title function_">P</span>(signal6) </span><br><span class="line"><span class="title function_">V</span>(signal6)   <span class="title function_">P</span>(signal7)</span><br><span class="line">             code6</span><br></pre></td></tr></table></figure><p>可以观察到，除了 P1 进程之外，其它进程首先执行的都是 P 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——</p><p>假设一开始是 P2 占有处理机，那么由于 signal1 初始为 0，导致了 P2 进队列，此后处理机来到 P3，P3 同样进队列… 以此类推，阻塞队列就会变成：</p><p><img src="https://static.pil0txia.com/picgo/20221017092052.png"></p><p>随后总算来到 P1 进程了，P1 进程作为一切的开始，特殊之处就在于它不是以 P 操作开始的，P1 会首先执行 V(signal1)，这一步把 signal1 加一，同时唤醒 P2 进程，P2 进程进入就绪队列：</p><p><img src="https://static.pil0txia.com/picgo/20221017092059.png"></p><p>再之后，P1 执行 V(signal2)，这一步把 signal2 加一，同时唤醒 P3 进程，P3 进程也进入就绪队列。</p><p><img src="https://static.pil0txia.com/picgo/20221017092212.png"></p><p>P1 执行完之后，就绪队列队头的 P2 进入运行态，执行到 V(signal3) 的时候，signal3 加一，同时唤醒 P4 进程，P4 进程进入就绪队列，</p><p><img src="https://static.pil0txia.com/picgo/20221017092320.png"></p><p>再之后，P2 执行 V(signal4)，这一步把 signal4 加一，同时唤醒 P5 进程，P5 进程也进入就绪队列。</p><p><img src="https://static.pil0txia.com/picgo/20221017092343.png"></p><p>P2 执行完之后，处理机调度就绪队列队头的 P3 开始执行，P3 执行到 V(signal7) 的时候，signal7 加一，<strong>注意这一步没有唤醒任何进程</strong></p><p><img src="https://static.pil0txia.com/picgo/20221017092414.png"></p><p>P3 执行完之后，处理机调度就绪队列队头的 P4 开始执行，P4 执行到 V(signal5) 的时候，signal5 加一，同时唤醒 P6 进程，P6 进程进入就绪队列</p><p><img src="https://static.pil0txia.com/picgo/20221017092431.png"></p><p>P4 执行完之后，处理机调度就绪队列队头的 P5 开始执行，P5 执行到 V(signal6) 的时候，signal6 加一，<strong>注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）</strong></p><p><img src="https://static.pil0txia.com/picgo/20221017092450.png"></p><p>P5 执行完之后，处理机调度就绪队列队头的 P6 开始执行，P6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。</p><p><img src="https://static.pil0txia.com/picgo/20221017092510.png"></p><p>这样基本就把整个流程过了一遍，当然，经过排列组合之后，分析过程都是大同小异的。</p><h3 id="信号量和PV操作解决进程同步问题"><a href="#信号量和PV操作解决进程同步问题" class="headerlink" title="信号量和PV操作解决进程同步问题"></a>信号量和PV操作解决进程同步问题</h3><h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>生产者-消费者问题是系统中并发进程内在关系的一种抽象，是典型的进程同步问题。生产者进程P1可以是计算进程、发送进程；而消费者进程P2可以是打印进程、接收进程等等。</p><blockquote><p>有界缓冲：</p><ul><li>一个生产者一次放入缓冲区一个产品，且无限次循环</li><li>一个消费者一次取出缓冲区一个产品，且无限次循环</li><li>两个进程独立</li></ul><p>要解决的问题：</p><ul><li>缓冲池满生产者不能放产品</li><li>缓冲池空消费者不能取产品</li><li>只能一个生产者或者消费者对缓冲区进行操作</li></ul></blockquote><p>进程个数：2</p><p>关系分析：</p><ul><li>互斥关系 P1、P2互斥访问缓冲区</li><li>同步关系 P1生产后P2才能消费</li></ul><p>信号量设置：</p><ul><li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li><li>同步信号量<code>empty = n</code> ，表示空闲缓冲区的数量</li><li>同步信号量<code>full = 0</code> ，表示非空闲缓冲区的数量，也即产品数量</li></ul><p>产品： <code>P1 V</code> <code>P2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p><p>空间：<code>P1 P</code> <code>P2 V</code></p><p>先考虑对互斥关系的实现。这里的临界资源是缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。P1、P2都各有一对 PV 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 PV 操作之前，必定要先生产产品；而消费者在进行 PV 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                              <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                             从缓冲区中取走产品 </span><br><span class="line">把产品放入缓冲区                       <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">V</span>(mutex)                             使用产品 </span><br><span class="line">    &#125;                                   &#125;</span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>接着考虑第一个同步关系，关注空缓冲区。先释放缓冲区，后使用缓冲区，且缓冲区满不再放入产品，所以这里“前操作”是消费者释放缓冲区，“后操作”是生产者占用缓冲区，根据 “前V后P”，我们需要在“前操作”之后针对 empty 这个信号量进行一次 V 操作，需要在“后操作”之前针对 empty 进行一次 P 操作。生产者执行 P 操作检查是否还有空缓冲区时，若缓冲区已满，将进入阻塞。所以，这时候代码变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                             <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(empty)                            从缓冲区中取走产品 </span><br><span class="line"><span class="title function_">P</span>(mutex)                            <span class="title function_">V</span>(mutex)</span><br><span class="line">        把产品放入缓冲区                      <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(mutex)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>再考虑第二个同步关系，关注产品。先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再安排一对 PV 操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(full)</span><br><span class="line">        <span class="title function_">P</span>(empty)                           <span class="title function_">P</span>(mutex)</span><br><span class="line"><span class="title function_">P</span>(mutex)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>这就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty &#x3D; n，表示所有缓冲区都是空闲的，同时 full &#x3D; 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 <code>P(full)</code> 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 <code>P(empty)</code> 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。</p><blockquote><p>P 操作不可以随意对调位置，V 操作可以。</p></blockquote><p><strong>这里要注意可能会引起“死锁”现象的一种写法。如下所示：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">producer</span>(<span class="params"></span>)&#123;                         <span class="title function_">consumer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(mutex)                           <span class="title function_">P</span>(full)</span><br><span class="line"><span class="title function_">P</span>(empty)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     <span class="title function_">V</span>(mutex) </span><br><span class="line">        <span class="title function_">V</span>(mutex)                           <span class="title function_">V</span>(empty)  </span><br><span class="line">        <span class="title function_">V</span>(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的“上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接“上锁”了，这导致它在 <code>P(full)</code> 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 <code>P(mutex)</code> 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了“死锁”。</p><p>另一种情况，我们也可以设想一开始处理机是在 producer 这里，依然会导致“死锁”。按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 <code>P(empty)</code> 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 <code>P(mutex)</code> 这一步陷入等待。也就是说，这不过是前面那种”死锁“现象的翻版。</p><p><strong>总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。</strong></p><h4 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h4><p>盘子 缓冲区</p><p>2水果 2产品</p><p>爸爸 妈妈 2生产者，P1 P2</p><p>儿子 女儿 2消费者，C1 C2</p><p>进程个数：4</p><p>关系分析：</p><ul><li>互斥关系 P1、P2、C1、C2互斥访问缓冲区</li><li>同步关系 P1生产后C1才能消费，P2生产后C2才能消费</li></ul><p>信号量设置：</p><ul><li>互斥信号量 <code>mutex = 1</code> ，实现对缓冲区这个资源的互斥访问</li><li>同步信号量<code>apple = 0</code> ，表示苹果的数量</li><li>同步信号量<code>orange = 0</code> ，表示橘子的数量</li></ul><p>产品： <code>P1 P2 V</code> <code>C1 C2 P</code>（V增加，P锁定，生产者放入产品，消费者取出产品）</p><p>空间：<code>P1 P2 P</code> <code>C1 C2 V</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">P1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把苹果放入盘子</span><br><span class="line">      <span class="title function_">V</span>(apple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">P2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="title function_">P</span>(mutex)</span><br><span class="line">      把橘子放入盘子</span><br><span class="line">      <span class="title function_">V</span>(orange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">C1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(apple)</span><br><span class="line">       从盘子中取走苹果</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="title function_">C2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="title function_">P</span>(orange)</span><br><span class="line">       从盘子中取走橘子</span><br><span class="line">       <span class="title function_">V</span>(mutex)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="银行问题"><a href="#银行问题" class="headerlink" title="银行问题"></a>银行问题</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221024_140725.jpg" alt="IMG_20221024_140725"></p><p>顾客的 V(full) 与 P(service) 应调换位置，并去除“获取服务”</p><p>service 默认值应为1</p><h4 id="五个哲学家进餐问题"><a href="#五个哲学家进餐问题" class="headerlink" title="五个哲学家进餐问题"></a>五个哲学家进餐问题</h4><p>一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：<strong>保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭</strong>。</p><p><img src="https://static.pil0txia.com/picgo/image-20221118204800390.png" alt="image-20221118204800390"></p><p><img src="https://static.pil0txia.com/picgo/IMG_20221024_145433.jpg"></p><p>如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么 1 号是会被阻塞的，所以这样相邻的哲学家中有一个可以吃饭。但是，如果 0 号拿起左筷子后进程切换到 1 号，1 号也拿起自己的左筷子，以此类推，所有的哲学家都只有左筷子，这导致了所有的哲学家都被阻塞，没有任何哲学家能够吃饭，也没有人可以释放筷子，使这些哲学家都陷入无限的等待中，造成“死锁”的发生。</p><p>解决这个问题有三个方法：</p><h5 id="实现原子操作"><a href="#实现原子操作" class="headerlink" title="实现原子操作"></a>实现原子操作</h5><p>很容易想到，拿起左筷子和拿起右筷子并不是一个原子操作。准备一个互斥信号量 <code>mutex = 1</code> ，并把拿筷子的操作封装在一个 PV 操作里。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(mutex)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(mutex)</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 0 号哲学家拿起左筷子之后，即使发生进程切换，1 号进程也会被卡在 <code>mutex</code> 的 P 操作，被送往阻塞队列，其它进程也同理。所以最后再次来到 0 号进程时便可以顺利拿起右筷子。这种做法保证了有一个哲学家是可以吃饭的。</p><blockquote><p>这里涉及到了<strong>一个进程需要一次性两个资源才能完成任务</strong>的问题，也可以使用 AND 信号量集机制。AND 信号量集机制的 P 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到。一开始筷子数量足够，所以 0 号在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title class_">Swait</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title class_">Ssignal</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="只有四个人参与这个过程"><a href="#只有四个人参与这个过程" class="headerlink" title="只有四个人参与这个过程"></a>只有四个人参与这个过程</h5><p>之前的情况是五个哲学家，五支筷子，所以容易出现谁也无法吃饭的情况，但是如果规定整个过程最多只有四个哲学家参与，即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。</p><p>如何限定“最多四个人可以参与这个过程”呢？准备一个互斥信号量 <code>count</code>，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 <code>count</code> 减少到 -1 的时候，就不能再让哲学家进来了。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_">P</span>(count)</span><br><span class="line">        <span class="title function_">P</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">eat</span>()</span><br><span class="line">        <span class="title function_">V</span>(chopstick[i])</span><br><span class="line">        <span class="title function_">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        <span class="title function_">V</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来演示前面发生“死锁”的过程。假如从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 <code>count</code> 数量充足，所以它不会阻塞，而是同样拿到了左筷子…以此类推，到了 4 号哲学家的时候，由于 <code>count = -1 &lt; 0</code>，所以它此时无法进来。 4 号哲学家左边的筷子在第一轮谁也没拿到，第二轮轮到 3 号哲学家时，就可以拿到这支筷子了。总会存在至少一个进程可以吃到饭。</p><h5 id="奇数拿左边，偶数拿右边"><a href="#奇数拿左边，偶数拿右边" class="headerlink" title="奇数拿左边，偶数拿右边"></a>奇数拿左边，偶数拿右边</h5><p>还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：</p><p><img src="https://static.pil0txia.com/picgo/image-20221118205737280.png" alt="image-20221118205737280"></p><p>伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pi</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line"><span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line"><span class="title function_">eat</span>();</span><br><span class="line"><span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line"><span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>   <span class="comment">//奇数哲学家，先左后右。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">P</span>(chopstick[i]) ;</span><br><span class="line"><span class="title function_">P</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line"><span class="title function_">eat</span>();</span><br><span class="line"><span class="title function_">V</span>(chopstick[i]) ;</span><br><span class="line"><span class="title function_">V</span>(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。</p><p>这只是其中一种情况，但无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，因此这个“被淘汰的”进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子“淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><blockquote><p>信号量机制效率低，且通信对用户不透明</p></blockquote><h4 id="管程的基本思想"><a href="#管程的基本思想" class="headerlink" title="管程的基本思想"></a>管程的基本思想</h4><p>管程&#x3D;共享资源+同步操作</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221024_150901.jpg"></p><p>进入管程无法直接访问临界资源，而是通过管程的方法来访问临界资源：</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221024_151827.jpg"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的概念"><a href="#进程通信的概念" class="headerlink" title="进程通信的概念"></a>进程通信的概念</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_135843.jpg" alt="IMG_20221031_135843"></p><p>任何时候都不能直接访问临界资源</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>共享空间是临界区，P1和P2互斥访问（PV操作）</p><p>共享方式上，共享存储分为基于数据结构的共享（较为低级，速度慢限制多，例如开辟一个数组）和基于存储区的共享（高级通信方式，速度快，在内存中划出一块共享存储区，数据结构和存放位置都由进程控制，而不是OS）</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_140352.jpg" alt="IMG_20221031_140352"></p><p>从P2传回给P1时，必须再开辟一个管道，以实现全双工。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><a href="#%E5%86%85%E6%A0%B8">回顾第一章消息传递等通信方式</a></p><blockquote><h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。</p><h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="引入线程"><a href="#引入线程" class="headerlink" title="引入线程"></a>引入线程</h3><p>首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程<strong>既是一个携带资源的独立单位，也是独立调度的基本单位</strong>，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。</p><p>如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的<strong>线程</strong>了。</p><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p><strong>调度的基本单位</strong></p><p>引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。</p><p><strong>执行的基本单位</strong></p><p>我们可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。但我们不能说“挂起线程”，只能说“挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程”没有意义。</p><p><strong>并发性</strong></p><p>进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。</p><p><strong>资源</strong></p><p>资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。虽然线程不携带资源，但它可以使用fork的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。</p><p><strong>系统开销</strong></p><p>在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。</p><blockquote><p><strong>独立性</strong></p><p>同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。</p><p><strong>支持多处理机系统</strong></p><p>传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。</p></blockquote><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。</p><h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_145313.jpg" alt="IMG_20221031_145313"></p><h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><p>作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是根据某种算法从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。</p><p>这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态</p><blockquote><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_150025.jpg" alt="IMG_20221031_150025"></p></blockquote><h4 id="内存调度"><a href="#内存调度" class="headerlink" title="内存调度"></a>内存调度</h4><p>内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存（虚拟内存）中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。引入中级调度的主要目的是提高内存利用率和系统吞吐量，它实际上就是存储器管理中的对换功能。</p><p>这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态</p><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程（内核级线程），分配处理机给它。进程调度是最基本、次数最频繁的阶段。</p><p>这个阶段进程的状态变化是： 就绪态 –&gt; 活动态</p><blockquote><p>根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：非抢占式和抢占式，为抢占式时，抢占原则有：优先权原则、短作业（进程）优先原则、时间片原则。</p><p>抢占式的缺点在于进程切换频繁发生，系统开销大。优点在于对短作业而言能更及时的得到调度。</p></blockquote><h2 id="队列调度模型"><a href="#队列调度模型" class="headerlink" title="队列调度模型"></a>队列调度模型</h2><h3 id="仅有进程调度的队列模型"><a href="#仅有进程调度的队列模型" class="headerlink" title="仅有进程调度的队列模型"></a>仅有进程调度的队列模型</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_151833.jpg" alt="IMG_20221031_151833"></p><p>分时操作系统没有后备作业队列，所以没有高级调度；又因为此系统的应用范围大多只是查询，分配的任务比较简单，以时间片轮转的方式执行终端的任务，所以没有中级调度。也即分时操作系统只有低级调度。</p><h3 id="具有高级调度和低级调度的调度队列模型"><a href="#具有高级调度和低级调度的调度队列模型" class="headerlink" title="具有高级调度和低级调度的调度队列模型"></a>具有高级调度和低级调度的调度队列模型</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_152200.jpg" alt="IMG_20221031_152200"></p><p>看到这张图，要想到<a href="#%E4%BA%94%E6%80%81">五态转换</a></p><h3 id="具有三级调度的调度队列模型"><a href="#具有三级调度的调度队列模型" class="headerlink" title="具有三级调度的调度队列模型"></a>具有三级调度的调度队列模型</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221031_152456.jpg" alt="IMG_20221031_152456"></p><p>看到这张图，要想到<a href="#%E4%B8%83%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E7%AB%A0%E8%8A%82%E4%BC%9A%E6%9C%89%E6%89%80%E6%8B%93%E5%B1%95%EF%BC%89">七态转换</a></p><h2 id="选择调度算法的原则"><a href="#选择调度算法的原则" class="headerlink" title="选择调度算法的原则"></a>选择调度算法的原则</h2><h3 id="面向用户的准则"><a href="#面向用户的准则" class="headerlink" title="面向用户的准则"></a>面向用户的准则</h3><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>面向批处理OS</p><p><strong>周转时间：</strong><code>作业完成时刻 - 作业提交时刻 = 作业实际运行的时间 + 等待时间</code></p><blockquote><p><strong>等待时间</strong>包括在后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、等待I&#x2F;O操作完成的时间。<strong>作业实际运行的时间</strong>即进程在CPU上执行的时间。<strong>周转时间</strong>是衡量批处理OS性能的重要指标。</p></blockquote><p><strong>平均周转时间：</strong><code>各作业周转时间之和 / 作业数</code></p><p><strong>带权周转时间：</strong><code>周转时间 / 作业实际运行的时间</code>（&gt;&#x3D;1，比周转时间更能衡量一个调度算法的优劣）</p><p><strong>平均带权周转时间：</strong><code>各作业带权周转时间之和 / 作业数</code></p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>面向分时OS</p><p><strong>响应时间：</strong>从用户提交请求到首次产生响应所用的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔。包括从键盘输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间、将所形成的响应时间回送到终端显示器的时间。</p><h4 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h4><p>面向实时OS</p><p><strong>截止时间：</strong>指某任务必须开始执行的最迟时间，或必须完成的最迟时间</p><h4 id="优先权准则"><a href="#优先权准则" class="headerlink" title="优先权准则"></a>优先权准则</h4><h3 id="面向系统的准则"><a href="#面向系统的准则" class="headerlink" title="面向系统的准则"></a>面向系统的准则</h3><p><strong>系统吞吐量：</strong><code>完成作业量 / 总时间</code></p><p><strong>CPU 利用率：</strong><code>忙碌的时间 / 总时间</code></p><p><strong>公平性：</strong>确保每个用户每个进程获得合理的CPU份额，不会出现饿死情况。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS-调度算法（作业调度-进程调度）"><a href="#先来先服务-FCFS-调度算法（作业调度-进程调度）" class="headerlink" title="先来先服务(FCFS)调度算法（作业调度+进程调度）"></a>先来先服务(FCFS)调度算法（作业调度+进程调度）</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221107_142009.jpg" alt="IMG_20221107_142009"></p><blockquote><p>周转时间&#x3D;完成时间-到达时间</p><p>带权周转时间&#x3D;周转时间&#x2F;服务时间</p></blockquote><p><img src="https://static.pil0txia.com/picgo/IMG_20221107_143022.jpg" alt="IMG_20221107_143022"></p><p>FCFS算法对长作业（CPU时间长的作业）有利，对短作业不利。</p><h3 id="最短作业-SJF-调度算法（作业调度-进程调度）"><a href="#最短作业-SJF-调度算法（作业调度-进程调度）" class="headerlink" title="最短作业(SJF)调度算法（作业调度+进程调度）"></a>最短作业(SJF)调度算法（作业调度+进程调度）</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221107_144647.jpg" alt="IMG_20221107_144647"></p><p>对这个情况而言，SJF比FCFS更好，尤其是C。</p><p>SJF调度算法也存在不容忽视的缺点：</p><ul><li>该算法对长作业不利，更严重的是，如果有一长作业（进程）进入系统的后备队列（就绪队列），由于调度程序总是优先调度那些（即使是后进来的）短作业（进程），将导致长作业（进程）长期不被调度。</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理。</li><li>由于作业（进程）的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li></ul><h3 id="高响应比优先-HRRN-调度算法（作业调度-进程调度）"><a href="#高响应比优先-HRRN-调度算法（作业调度-进程调度）" class="headerlink" title="高响应比优先(HRRN)调度算法（作业调度+进程调度）"></a>高响应比优先(HRRN)调度算法（作业调度+进程调度）</h3><blockquote><p>HRRN (Highest Response Ratio Next) &#x3D; HRRF (Highest Response Ratio First)</p><p>NUIST老师习惯用HRRF，我觉得HRRN更合适</p></blockquote><p>FCFS与SJF是片面的调度算法。FCFS只考虑作业等候时间而忽视了作业的计算时间问题；SJF只考虑用户估计的作业计算时间而忽视了作业等待时间。</p><p>HRRN是介乎这两者之间的非剥夺式算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。</p><p><strong>响应比</strong>（带权周转时间） &#x3D; 作业周转时间 &#x2F; 作业处理时间 &#x3D; （作业等待时间+作业处理时间） &#x2F; 作业处理时间 &#x3D; <strong>1 + 作业等待时间 &#x2F; 作业处理时间</strong></p><ul><li>短作业容易得到较高响应比（分母小）</li><li>长作业等待时间足够长后，也将获得足够高的响应比（分子足够大）</li><li>饥饿现象不会发生</li></ul><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221107_150432.jpg" alt="IMG_20221107_150432"></p><p>首先调度J1，然后计算响应比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">J2 1+15/15=2</span><br><span class="line">J3 1+10/5=3</span><br><span class="line">J4 1+5/10=1.5</span><br></pre></td></tr></table></figure><p>J3的响应比最大，调度J3。随后计算J3完成后的响应比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=20+5</span><br><span class="line">J2 1+20/15=2.3</span><br><span class="line">J4 1+10/10=2</span><br></pre></td></tr></table></figure><p>所以调用J2，最后调用J4。</p><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221107_152959.jpg" alt="IMG_20221107_152959"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FCFS J1 2 3 4</span><br><span class="line">8 10 2 1</span><br><span class="line">10 10.5 1.5+1/6 (1.5+1/6)/0.5=3.3</span><br><span class="line">10.5 10.6 1.6 1.6/0.1=16</span><br><span class="line">10.6 10.8 0.8+2/3 (0.8+2/3)/0.2=7.3</span><br><span class="line">(2+1.5+1/6+1.6+0.8+2/3)/4=1.68</span><br><span class="line">(1+(1.5+1/6)/0.5+1.6/0.1+(0.8+2/3)/0.2)/4=6.92</span><br><span class="line">SJF J1 3 4 2</span><br><span class="line">8 10 2 1</span><br><span class="line">10.3 10.8 1.8+1/6 (1.8+1/6)/0.5=3.93</span><br><span class="line">10 10.1 1.1 1.1/0.1=11</span><br><span class="line">10.1 10.3 0.3+2/3 (0.3+2/3)/0.2=4.83</span><br><span class="line">(2+1.8+1/6+1.1+0.3+2/3)/4=1.51</span><br><span class="line">(1+(1.8+1/6)/0.5+1.1/0.1+(0.3+2/3)/0.2)/4=5.19</span><br><span class="line">HRRF J1 </span><br><span class="line">8 10 2 1</span><br><span class="line">(10) J2 未完成</span><br></pre></td></tr></table></figure><h3 id="高优先权-FPF-调度算法（作业调度-进程调度）"><a href="#高优先权-FPF-调度算法（作业调度-进程调度）" class="headerlink" title="高优先权(FPF)调度算法（作业调度+进程调度）"></a>高优先权(FPF)调度算法（作业调度+进程调度）</h3><h4 id="非抢占式优先权算法"><a href="#非抢占式优先权算法" class="headerlink" title="非抢占式优先权算法"></a>非抢占式优先权算法</h4><p>和 HRRN 算法很像，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。</p><h4 id="抢占式优先权算法"><a href="#抢占式优先权算法" class="headerlink" title="抢占式优先权算法"></a>抢占式优先权算法</h4><p>除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。</p><h4 id="静态优先权"><a href="#静态优先权" class="headerlink" title="静态优先权"></a>静态优先权</h4><p>静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变。一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；I&#x2F;O 型进程优先级会比较高。</p><h4 id="动态优先权"><a href="#动态优先权" class="headerlink" title="动态优先权"></a>动态优先权</h4><p>动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直“霸占”处理机了。另外，之前说过 I&#x2F;O 型进程的优先级会很高，所以如果某个进程频繁进行 I&#x2F;O 操作，也可以考虑提高它的优先级。</p><p>优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 HRRN 算法也是很像的。（其实也可以把 HRRN 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）</p><h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221114_141012.jpg" alt="IMG_20221114_141012"></p><p>可剥夺：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间:进程 0:P1 3:P2 5:P3 10:P4 20:P3 21:P1 23:DONE</span><br><span class="line">进程 周转时间 带权周转时间</span><br><span class="line">P1 23-0=23 23/5=4.6</span><br><span class="line">P2 5-3=2 2/2=1</span><br><span class="line">P3 21-5=16 16/6=2.67</span><br><span class="line">P4 20-10=10 10/10=1</span><br><span class="line">平均周转时间：12.75</span><br><span class="line">带权周转时间：2.32</span><br></pre></td></tr></table></figure><h3 id="时间片轮转-RR-调度算法（进程调度）"><a href="#时间片轮转-RR-调度算法（进程调度）" class="headerlink" title="时间片轮转(RR)调度算法（进程调度）"></a>时间片轮转(RR)调度算法（进程调度）</h3><p>RR 算法的特点则在于“公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出“交替”的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。</p><blockquote><p>答题需表格+执行顺序时间线</p></blockquote><h4 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221114_151836.jpg" alt="IMG_20221114_151836"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间:进程(剩余时间)：0:P1(33) 20:P2(0) 37:P3(48) 57:P4(4) 77:P1(13) 97:P3(28) 117:P4(0) 121:P1(0)  134:P3(8) 154:P3(0) 162:DONE</span><br><span class="line">P1 134 134/50</span><br><span class="line">P2 17 17/17</span><br><span class="line">P3 162 162/68</span><br><span class="line">P4 121 121/24</span><br><span class="line">平均周转时间：108.5</span><br><span class="line">带权平均周转时间：2.78</span><br></pre></td></tr></table></figure><h3 id="多级反馈调度算法（进程调度）"><a href="#多级反馈调度算法（进程调度）" class="headerlink" title="多级反馈调度算法（进程调度）"></a>多级反馈调度算法（进程调度）</h3><p><img src="https://static.pil0txia.com/picgo/IMG_20221114_142817.jpg" alt="IMG_20221114_142817"></p><ul><li>有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾</li><li>当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度</li><li>关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾</li></ul><p><strong>优点：</strong></p><ul><li>对各类型进程相对公平（FCFS 的优点）：谁先进来，谁就会处于高级队列，优先得到服务</li><li>每个新到达的进程都可以很快就得到响应（RR 的优点）：新到达的进程首先在高级队列，可以很快得到响应</li><li>短进程只用较少的时间就可完成（SPF 的优点）：不需要经历过多的队列</li><li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I&#x2F;O 密集型进程（拓展：可以将因 I&#x2F;O 而阻塞的进程重新放回原队列，这样 I&#x2F;O 型进程就可以保持较高优先级）</li><li>对各类型用户友好。对于<strong>终端型用户</strong>来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对<strong>短批处理作业用户</strong>来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对<strong>长批处理作业用户</strong>来说，只要让作业依次在第 1, 2，… n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li></ul><p><strong>缺点：</strong></p><ul><li>可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。</li></ul><h4 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1"></a>例题1</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221114_145035.jpg" alt="IMG_20221114_145035"></p><blockquote><p>D就绪队列2有误</p></blockquote><h4 id="例题2（只有3个就绪队列的例题1）"><a href="#例题2（只有3个就绪队列的例题1）" class="headerlink" title="例题2（只有3个就绪队列的例题1）"></a>例题2（只有3个就绪队列的例题1）</h4><p><img src="https://static.pil0txia.com/picgo/image-20221114150810280.png" alt="image-20221114150810280"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A 2-0=2 2/2</span><br><span class="line">B 22-2=20 20/6</span><br><span class="line">C 58-4=54 54/10</span><br><span class="line">D 66-6=60 60/14</span><br><span class="line">E 110-8=102 102/18</span><br><span class="line">F 118-10=108 108/22</span><br><span class="line">G 146-12=134 134/26</span><br><span class="line">H 154-14=140 140/30</span><br><span class="line">I 166-16=150 150/34</span><br><span class="line">平均周转时间：85.56</span><br><span class="line">带权平均周转时间：4.31</span><br></pre></td></tr></table></figure><p>平均周转时间&#x3D;结束时间-开始时间 ×，平均周转时间&#x3D;结束时间-到达时间 √。若没有给到达时间，则默认所有任务一开始就同时到达。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="出现死锁的场景"><a href="#出现死锁的场景" class="headerlink" title="出现死锁的场景"></a>出现死锁的场景</h3><h4 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_102117.jpg" alt="IMG_20221117_102117"></p><h4 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h4><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_102345.jpg" alt="IMG_20221117_102345"></p><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。</p><h4 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h4><p>一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。</p><h4 id="请求和占有"><a href="#请求和占有" class="headerlink" title="请求和占有"></a>请求和占有</h4><p>申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure><p>如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。</p><p>换一种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure><p>如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是<strong>是在不占有资源的情况下阻塞的</strong>，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。</p><h4 id="环路循环等待"><a href="#环路循环等待" class="headerlink" title="环路循环等待"></a>环路循环等待</h4><p>要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。</p><p>[P0，P1，P2，…Pn]中的P0正在等待P1占用的资源，P1正在等待P2占用的资源……Pn正在等待P0占用的资源。</p><p>发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。</p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低</p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。</p><h4 id="破坏非抢占条件"><a href="#破坏非抢占条件" class="headerlink" title="破坏非抢占条件"></a>破坏非抢占条件</h4><p>如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：</p><ul><li>从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请</li><li>从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。</li></ul><p>这种做法的问题在于：</p><ul><li>实现起来复杂</li><li>某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失</li><li>反复的申请和释放资源会增加系统开销</li><li>可能导致饥饿</li></ul><h4 id="破坏“请求和占有”条件"><a href="#破坏“请求和占有”条件" class="headerlink" title="破坏“请求和占有”条件"></a>破坏“请求和占有”条件</h4><p>所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。</p><p>该方法可能导致饥饿现象。若有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，如果 AB 源源不断进入就绪队列，那么 C 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。</p><h4 id="破坏“环路循环等待”条件"><a href="#破坏“环路循环等待”条件" class="headerlink" title="破坏“环路循环等待”条件"></a>破坏“环路循环等待”条件</h4><p>将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。</p><p>优点：和前两种相比，资源利用率和吞吐量利用率高</p><p>缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。</p><p>以之前的例子讲解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>) </span><br></pre></td></tr></table></figure><p>这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">P1</span>:          <span class="attr">P2</span>:</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R1</span>)  <span class="title function_">request</span>(<span class="variable constant_">R1</span>)</span><br><span class="line"><span class="title function_">request</span>(<span class="variable constant_">R2</span>)  <span class="title function_">request</span>(<span class="variable constant_">R2</span>) </span><br></pre></td></tr></table></figure><p>实际上，这里除了破坏“占有和请求条件”之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。</p><p>也可以拿之前的<a href="#%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98">哲学家进餐问题</a>解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。</p><p>还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。</p><blockquote><p>但这种预防死锁的方法，问题在于：</p><ul><li>如何进行编号，从什么角度考虑？</li><li>如果增加资源或设备，怎么重新编号？</li><li>虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。</li></ul></blockquote><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全状态：指系统按某种顺序(P1,P2,…,Pn)(称&lt;P1,P2,…,Pn&gt;为安全序列)来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p><p>安全状态之例：假定系统中有三个进程P1、P2和P3,共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3分别获得5台、2台和2台，尚有3台未分配，如下表所示：</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_111227.jpg" alt="IMG_20221117_111227"></p><h4 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h4><p>当各类资源都<strong>只有一个</strong>的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。</p><p><img src="https://static.pil0txia.com/picgo/image-20221118230915805.png" alt="image-20221118230915805"></p><ul><li>如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。</li><li>如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。</li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul><li>银行家拥有一笔周转资金</li><li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷</li><li>银行家应谨慎的贷款，防止出现坏帐</li></ul><h5 id="银行家算法案例"><a href="#银行家算法案例" class="headerlink" title="银行家算法案例"></a>银行家算法案例</h5><p>设银行家有10万贷款，P,Q,R分别需要8,3,9万元搞项目（假设任何人满足资金总额后都会归还所有贷款)</p><p>如果P已申请到了4万：</p><ul><li>Q要申请2万，显然，如果满足Q的申请，有安全序列&lt;P,Q,R&gt;&#x2F;&lt;Q,P,R&gt;</li><li>R要申请4万，显然，如果满足R的申请，则不存在安全序列。</li></ul><p><strong>基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。</strong></p><h5 id="银行家算法过程"><a href="#银行家算法过程" class="headerlink" title="银行家算法过程"></a>银行家算法过程</h5><p><img src="https://static.pil0txia.com/picgo/image-20221118233726331.png" alt="image-20221118233726331"></p><p>假设系统中有 n 个进程，m 种资源，规定：</p><ul><li>每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 <code>Max</code> 表示各个进程的需求情况，比如 <code>Max[i][j]= K</code> 就表示进程 i 需要 K 个 j 类型资源</li><li>用一个 n*m 的分配矩阵 <code>Allocation</code> 表示各个进程的已分配资源情况</li><li>用一个 n*m 的需求矩阵 <code>Need</code> 表示各个进程的最多还需要资源情况，<code>Need = Max - Allocation</code></li><li>用一个 m 长度的一维数组 <code>Avaliable</code> 表示剩余资源数目</li><li>用一个 m 长度的申请矩阵 <code>Request[i][j]</code> 表示某个进程 i 某次申请的 j 类型资源数目</li></ul><p>按照之前说过的流程图，银行家算法的工作过程是：</p><ul><li>请求资源数是否超过最大资源数？<code>Request[i][j]&lt;=Need[i][j]</code>，则到下一步；否则出错</li><li>请求资源数是否超过剩余资源数？<code>Request[i][j]&lt;=Available[j]</code>，则到下一步；否则说明资源不够，进程等待</li><li>尝试进行资源分配。<ul><li>剩余资源减少：<code>Available = Available - Request</code></li><li>已分配资源增加：<code>Allocation[i][j] = Allocation[i][j] + Request[i][j]</code></li><li>需求资源减少：<code>Need[i][j] = Need[i][j] - Request[i][j]</code></li></ul></li><li>对分配后的状态通过安全性算法进行预判：<ul><li>安全状态：不会发生死锁，可以分配资源</li><li>不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态</li></ul></li></ul><h5 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1"></a>例题1</h5><p>假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p><p><img src="https://static.pil0txia.com/picgo/image-20221118232822744.png" alt="image-20221118232822744"></p><p>如何检测当前是否处于安全状态呢？尝试寻找安全序列：</p><ul><li>当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。</li><li>P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）&#x3D;（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列。</li><li>所以存在安全序列 <code>P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4</code> ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。</li></ul><p>看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p><p><img src="https://static.pil0txia.com/picgo/image-20221118232808706.png" alt="image-20221118232808706"></p><p>当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。</p><h5 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h5><p>t0时刻安全状态检查。如果t0时刻都不安全，则后面的部分都不用做了。但是考试时t0都是安全的。</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_114149.jpg" alt="IMG_20221117_114149"></p><p>安全序列之一：&lt;p1,p3,p4,p2,p0&gt;</p><h5 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h5><p>在银行家算法中，若出现下述资源分配情况，试问：</p><table><thead><tr><th align="center">Process</th><th align="center">Allocation</th><th align="center">Need</th><th align="center">Available</th></tr></thead><tbody><tr><td align="center">P0</td><td align="center">0032</td><td align="center">0012</td><td align="center">1622</td></tr><tr><td align="center">P1</td><td align="center">1000</td><td align="center">1750</td><td align="center"></td></tr><tr><td align="center">P2</td><td align="center">1354</td><td align="center">2356</td><td align="center"></td></tr><tr><td align="center">P3</td><td align="center">0332</td><td align="center">0652</td><td align="center"></td></tr><tr><td align="center">P4</td><td align="center">0014</td><td align="center">0656</td><td align="center"></td></tr></tbody></table><p>(1) 该状态是否安全？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P0 1622+0032=1654</span><br><span class="line">P3 1654+0332=1986</span><br><span class="line">P1 1986+1000=2986</span><br><span class="line">P4 2986+0014=299 10</span><br><span class="line">P2 299 10+1354=3 12 14 14</span><br><span class="line">故存在安全序列P0 P3 P1 P4 P2</span><br></pre></td></tr></table></figure><p>(2) 若进程P2提出请求 Request(1,2,2,2) 后，系统能否将资源分配给它？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P2的Allocation加上1 2 2 2为2 5 7 6，Need变为1 1 3 4， Available变为0 4 0 0</span><br><span class="line">由(1)可知，此时系统资源无法满足任何一个进程，安全性检查不通过，无法分配资源</span><br></pre></td></tr></table></figure><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><h4 id="简化进程-资源分配图"><a href="#简化进程-资源分配图" class="headerlink" title="简化进程-资源分配图"></a>简化进程-资源分配图</h4><h5 id="各类资源只有一个"><a href="#各类资源只有一个" class="headerlink" title="各类资源只有一个"></a>各类资源只有一个</h5><p>当各类资源只有一个的时候，可以把<a href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE">资源分配图</a>化简为一个等待图（wait-for graph），比如说 A 进程请求 X 资源、X 资源被 B 进程占有，这个过程可以被简化为 A 进程等待 B 进程。比如说下面，左图被转化为对应的右图：</p><p><img src="https://static.pil0txia.com/picgo/image-20221119185911023.png" alt="image-20221119185911023"></p><p><strong>死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。</strong></p><ul><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。</li></ul><h5 id="各类资源有多个"><a href="#各类资源有多个" class="headerlink" title="各类资源有多个"></a>各类资源有多个</h5><p>各类资源有多个的时候，我们可能需要根据给定表或给定图检测是否有死锁。对于前者，可以沿用<a href="#%E4%BE%8B%E9%A2%981-5">之前的安全性算法</a>进行检测；对于后者，可以尝试简化资源分配图。</p><p>给定一个资源分配图为例：</p><p><img src="https://static.pil0txia.com/picgo/image-20221119205915983.png" alt="image-20221119205915983"></p><p>约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 P1 占有两个 R1 资源，请求一个 R2 资源；P2 占有一个 R2 资源，一个 R1 资源，请求一个 R1 资源。</p><ul><li>首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是<strong>进程请求的资源数量足够</strong>，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，有多余资源，P1 是非阻塞的。这样就找到了符合条件的进程点 P1</li><li>去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点</li><li>重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除</li><li>由于图中所有的边都能被消除，所以称该图<strong>可以被简化</strong>，因此它不存在死锁（如果不可简化，则存在死锁）</li></ul><blockquote><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_105216.jpg" alt="IMG_20221117_105216"></p></blockquote><p>又比如下面这种情况：</p><p><img src="https://static.pil0txia.com/picgo/image-20221119225907074.png" alt="image-20221119225907074"></p><p>首先还是找一个非孤立非阻塞的点，很显然只有 P3 符合要求。之后把 P3 的分配边去掉，会发现 P1 和 P2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><h4 id="资源剥夺法"><a href="#资源剥夺法" class="headerlink" title="资源剥夺法"></a>资源剥夺法</h4><p>将部分死锁的进程挂起并抢占它的资源，将这些资源分配给其它的死锁进程。但应防止被挂起的进程长时间得不到资源而饥饿。</p><blockquote><p>注意不是抢占非死锁进程的资源。</p></blockquote><h4 id="终止进程法"><a href="#终止进程法" class="headerlink" title="终止进程法"></a>终止进程法</h4><p>强制终止部分或全部死锁进程，并剥夺它们的资源。这种方式的优点是实现简单，但可能付出很大的代价。因为有些进程可能已经运行了很长时间，一旦被终止就功亏一篑了。</p><h4 id="进程回退法"><a href="#进程回退法" class="headerlink" title="进程回退法"></a>进程回退法</h4><p>让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。</p><blockquote><p>无论是哪种方法，都可以从以下角度考虑需要做出牺牲的进程：</p><ul><li>优先级比较低的进程做出牺牲</li><li>占用过多资源的进程做出牺牲</li><li>执行时间长的进程不做出牺牲</li><li>快要完成的进程不做出牺牲</li><li>交互式进程不做出牺牲</li></ul></blockquote><h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="多级存储器结构"><a href="#多级存储器结构" class="headerlink" title="多级存储器结构"></a>多级存储器结构</h2><p><img src="https://static.pil0txia.com/picgo/IMG_20221121_145003.jpg" alt="IMG_20221121_145003"></p><h2 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h2><p><img src="https://static.pil0txia.com/picgo/IMG_20221121_145937.jpg" alt="IMG_20221121_145937"></p><p>用户程序在执行前必须先进入内存，具体来说包括以下步骤：</p><ul><li>编译：由编译程序将用户源程序编译成多个目标模块</li><li>链接：由链接程序将编译后的多个目标模块和所需的库函数链接在一起，形成一个总的装入模块</li><li>装入：由装入程序将装入模块装入内存运行</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>根据链接的时间不同进行区分</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>直接将编译后的多个目标模块和所需的库函数链接在一起，形成一个不再拆开的装入模块，该模块整体装入内存。</p><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>不事先进行链接，而是一边装入内存，一边进行链接，即在装入一个目标模块时，若发生一个外部模块调用事件，装入程序就去找出相应的外部目标模块。这种方式便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221121_151005.jpg" alt="IMG_20221121_151005"></p><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>不事先进行链接，而是一边执行程序，一边进行模块的装入和链接，这种方式可以确保只装入和链接那些在执行时需要用到的模块，而不会引入多余的、实际根本用不到的模块，因此拥有装入时动态链接的优点，还加快了程序的装入过程，有利于节省内存空间。</p><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>装入模块中指令所涉及的地址是逻辑地址（相对地址），往往并不是装入内存后的物理地址，因此在装入模块装入内存后，需要将原先的逻辑地址转换成物理地址（绝对地址）。在下面三种装入方式中，对逻辑地址的处理是不同的。</p><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>程序员如果事先知道程序最终装入内存时的物理地址（如在单道程序运行环境中），那么编译程序产生的目标模块中可以直接使用物理地址，此时的逻辑地址与物理地址一样，模块在装入到内存的时候也无需进行地址转换的工作。</p><h4 id="静态重定位装入方式"><a href="#静态重定位装入方式" class="headerlink" title="静态重定位装入方式"></a>静态重定位装入方式</h4><p>在多道程序运行环境中，无法事先知道程序最终装入内存时的物理地址，所以目标模块中只能使用逻辑地址，所有指令中涉及到的逻辑地址都是从 0 开始的。装入模块可以装入到内存的合适位置，并且<strong>在装入的时候</strong>会进行地址转换（重定位）的工作。例如将程序中起始于 0 的逻辑地址都转换为起始于 10000 的物理地址。</p><p>“静态”主要体现在程序装入内存后，在运行期间就不能再移动了，因为一旦移动就意味着需要再次更改物理地址，而地址是无法修改的，否则会发生错误。</p><h4 id="动态重定位装入方式"><a href="#动态重定位装入方式" class="headerlink" title="动态重定位装入方式"></a>动态重定位装入方式</h4><p>很多时候，程序在内存中的位置会经常发生改变，比如在外存和内存之间对换。位置不会是一成不变的，这时候就要采用动态重定位装入方式。这种方式并不急于在装入的时候就进行地址转换，而是在程序真正执行的时候才去进行地址转换的工作。</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221121_152806.jpg" alt="IMG_20221121_152806"></p><p>这意味着程序在装入内存后，在运行期间是可以移动的。因为不管移动到哪个内存位置，始终会有一个重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地址。</p><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="外部碎片和内部碎片"><a href="#外部碎片和内部碎片" class="headerlink" title="外部碎片和内部碎片"></a>外部碎片和内部碎片</h3><ul><li>外部碎片指的是尚未分配出去、由于太小而无法分配出去的内存空间（化整为零）</li><li>内部碎片指的是已经分配出去、但没有完全得到利用的内存空间</li></ul><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>单一连续分配只适用于单用户、单任务的操作系统中，它会把整个内存区划分为系统区和用户区，一道用户程序就会独占整个用户区，因此存储器的利用率非常低、内部碎片很大（分配了整个用户区，但实际用到的空间并不多）。</p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区分配是最简单的多道程序的存储管理方式，依然是将整个内存区划分为系统区和用户区，但是用户区进一步细分：划分为<strong>多个固定大小</strong>的分区，系统启动后就已经分好了分区，一个分区放一个进程。</p><p>每个分区的大小可以相等也可以不等：</p><ul><li><p>如果每个分区大小相等，缺乏灵活性：对于小进程，无法利用全部空间而产生内部碎片；对于大进程，找不到大小足够的分区。</p></li><li><p>如果每个分区的大小不等，提高了灵活度，可以将用户区划分为大量的小分区、适量的中分区、少量的大分区，并维护一张记录了分区号、分区大小、分区起始地址、分区分配状态的分区使用表。每次需要为进程分配内存空间的时候，先在这张表上进行检索，找到一个合适的分区分配给它。</p><p>这种划分方式可以认为不存在过小的、分配不出去的内存空间，不会产生外部碎片；但是，由于提前划分了分区，不能保证一个进程完全利用完某个分区，分区会产生内部碎片：</p><p><img src="https://static.pil0txia.com/picgo/IMG_20221128_140141.jpg" alt="IMG_20221128_140141"></p><blockquote><p>浪费了7+23+87+211K&#x3D;328K的空间</p></blockquote></li></ul><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><p>动态分区分配方式比前面的分配方式要灵活很多，类似于按需分配，不是预先划分好，而是进程需要多少内存空间，就给它多少内存空间。</p><p>但这种分配方式需要考虑的问题是，当一个进程有多个空闲的内存分区可供选择的时候，它应该使用哪个空间呢？比如进程 2 运行完释放了 20K 的内存空间，此时进程 4 进来，也需要用到 20K 的内存空间，它既可以选择占用进程 2 释放的空间，也可以选择占用后面没被用到的一大片空间。</p><p>因此，我们需要一种算法来决定进程 4 的选择，而且为了更好地描述内存使用情况，我们同样要像固定分区分配一样维护一张空闲分区表或者一个空闲分区链。</p><h4 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h4><p>假设进程 X 需要用到 x 大小的内存空间，在某种算法下，系统会检索空闲分区表或者空闲分区链，决定将某个空闲分区分配给这个进程。假设这个空闲分区大小为 y（y&gt;x），若 <code>y-x</code> 的值小于预先设定的一个阈值，说明进程可以充分利用这个空闲分区，可以将整个分区直接分配给进程；若 <code>y-x</code> 的值大于这个阈值，说明空闲分区无法得到完全的利用，可以将整个分区能够被充分利用的那部分（也即 x）划分给进程，而剩下的 <code>y-x</code> 则继续留在空闲分区表（因为只记录空闲分区，所以没有“状态”项）或者空闲分区链（不讲不考察）中。</p><h4 id="基于顺序搜索的算法"><a href="#基于顺序搜索的算法" class="headerlink" title="基于顺序搜索的算法"></a>基于顺序搜索的算法</h4><h5 id="首次适应（FF）"><a href="#首次适应（FF）" class="headerlink" title="首次适应（FF）"></a>首次适应（FF）</h5><p>将多个空闲分区按照地址递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p><ul><li>由于地址一开始就是确定下来的，能够保证顺序始终是递增的，因此这种算法无需频繁地变更空闲分区的顺序，而且每次优先利用低地址空间，保证了高地址空间有足够大的空闲区域可供大进程使用。</li><li>但是，因为每次优先利用低地址空间，所以低地址空间被不断分割，产生了大量的外部碎片；而且，每次都是从头开始寻找空闲空间，效率并不高。</li></ul><h5 id="邻近适应（NF）"><a href="#邻近适应（NF）" class="headerlink" title="邻近适应（NF）"></a>邻近适应（NF）</h5><p>邻近适应算法（循环首次适应算法）克服了首次适应算法的缺点，它同样是将多个空闲分区按照地址递增的顺序排列，不同的是，每次查找都是从上次查找结束的位置开始查找的</p><ul><li><p>不会从头开始一个个找，一定程度上提高了效率；而且，它会更趋向于往后推进，避免了对低地址空间重复地进行分割，进而避免了大量外部碎片的产生。</p></li><li><p>优点同时也是缺点，由于邻近适应算法更趋向于往后推进，所以更可能分割高地址空间，这就破坏了首次适应算法的初衷，导致大进程可能没有足够的空闲空间可利用。</p></li></ul><h5 id="最佳适应（BF）"><a href="#最佳适应（BF）" class="headerlink" title="最佳适应（BF）"></a>最佳适应（BF）</h5><p>连续分配的方式规定，为各个进程分配的必须是一块连续的空间，因此对于一块内存空间来说，若它不断被分割，则意味着它能容纳下大进程的可能性越低。为了保证有足够的内存空间可以容纳大进程，基本思想应该是优先利用小的空闲分区，而保留大的空闲分区。</p><p>最佳适应算法将空闲分区按照容量递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p><ul><li>分配操作主要集中在小的空闲分区那里进行，保证了有大的空闲分区可以用来容纳大进程。</li><li>因为要按照容量递增的顺序排列，而每次内存的分配和回收都会改变某一块空间的大小，每次在进行分配和回收的时候，基本都要重新进行排序，算法开销大。而且，由于分配操作集中在小的空闲分区进行，导致它们不断被分割，容易产生大量外部碎片。</li></ul><h5 id="最坏适应-（WF）"><a href="#最坏适应-（WF）" class="headerlink" title="最坏适应 （WF）"></a>最坏适应 （WF）</h5><p>为了克服最佳适应算法的缺点，最坏适应算法规定，将空闲分区按照容量递减的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。</p><ul><li>最坏适应算法优先使用大的空闲分区，而大的空闲分区由于容量充足，即使被不断分割，也可以保证剩余空间不至于太小，依然能够被新的进程利用，大幅度减少了外部碎片的产生。</li><li>但是，这又破坏了最佳适应算法的初衷，因为优先使用大的空闲分区，很容易导致后续的大进程没有足够大小的空闲分区可以利用。并且，这种算法也无法避免分配和回收之后的重新排序。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://static.pil0txia.com/picgo/image-20221128135433747.png" alt="image-20221128135433747"></p><p>由于动态分区分配不是事先划分好区域，而是“按需分配”，所以不会出现区域划分出去后无法完全得到利用的情况，也即不会产生内部碎片；但是可能出现内存空间太小而无法被分配出去的情况，也即可能产生外部碎片。</p><h4 id="基于索引搜索的算法"><a href="#基于索引搜索的算法" class="headerlink" title="基于索引搜索的算法"></a>基于索引搜索的算法</h4><p>当系统很大的时候，内存分区会很多，这时候还采取基于顺序搜索的动态分区分配算法的话，效率并不高。因此出现了基于索引搜索的动态分区分配算法。</p><h5 id="快速适应"><a href="#快速适应" class="headerlink" title="快速适应"></a>快速适应</h5><p>快速适应算法（分类搜索算法）将空闲分区按照进程常用的空间大小进行分类，比如 2KB 为一类，4KB 为一类，6KB 为一类等，对于每一类空闲分区，会有一个单独的空闲分区链表。此外，还会有一张总的管理索引表，索引表的每一个表项对应了一类空闲分区。</p><p>在为进程分配分区的时候，首先会根据进程长度，从索引表中找到能容纳它的最小空闲区链表，接着将该链表的第一块分配给进程。</p><ul><li>因为前面已经进行了合理的分类，因此这种方法不会对任何分区产生分割，也不会产生外部或者内部碎片，并且查找效率很高</li><li>但是，回收、合并分区时的算法复杂，系统开销比较大</li></ul><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><blockquote><p>接下来的伙伴关系和哈希算法为自学内容</p></blockquote><p><img src="https://static.pil0txia.com/picgo/image-20221128144121955.png" alt="image-20221128144121955"></p><p>举个例子</p><p>假设系统总的内存为 512KB，现有进程活动如下：</p><ul><li>进程 A 请求 100KB，进程 B 请求 50KB，进程 C 请求 100KB</li><li>进程 A 释放 100KB</li><li>进程 D 请求 20KB</li><li>进程 D 释放 20KB</li><li>进程 B 释放 50KB</li></ul><p>按照伙伴系统的算法，内存的分配和回收是怎么进行的呢？</p><p>首先，一开始肯定是整片空的内存空间，进程 A 请求 100KB，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^&#x3D;128 的空闲分区，当然是没有的（目前只有 512KB)，所以寻找是否有 2^8^&#x3D;256 的空闲分区，也没有，所以寻找是否有 2^9^&#x3D;512 的空闲分区，找到了，此时就把 512KB 一分为二：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128145950590.png" alt="image-20221128145950590"></p><p>一半的 256KB 加入到对应的空闲分区链表，一半的 256KB 用于分配，对这一半继续一分为二：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128145955549.png" alt="image-20221128145955549"></p><p>一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 A 来说足够了，于是占用它：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150408463.png" alt="image-20221128150408463"></p><p>进程 B 请求 50KB，因为 32&lt;50&lt;64，即 2^5^&lt;100&lt;2^6^，所以寻找是否有 2^6^&#x3D;64 的空闲分区，没有，所以寻找是否有 2^7^&#x3D;128，找到了，此时就把 128KB 一分为二：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150443884.png" alt="image-20221128150443884"></p><p>一半的 64KB 加入到对应的空闲分区链表，一半的 64KB 用于分配，这一半对进程 B 来说足够了，于是占用它：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150503276.png" alt="image-20221128150503276"></p><p>进程 C 请求 100KB，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^&#x3D;128 的空闲分区，没有，所以寻找是否有 2^8^&#x3D;256 的空闲分区，找到了，此时就把 256KB 一分为二：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150518634.png" alt="image-20221128150518634"></p><p>一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 C 来说足够了，于是占用它：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150534743.png" alt="image-20221128150534743"></p><p>进程 A 释放 100KB：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150557810.png" alt="image-20221128150557810"></p><p>进程 D 请求 20KB，因为 16&lt;20&lt;32，即 2^4^&lt;100&lt;2^5^，所以寻找是否有 2^5^&#x3D;32 的空闲分区，没有，所以寻找是否有 2^6^&#x3D;64 的空闲分区，找到了，此时就把 64KB 一分为二：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150616809.png" alt="image-20221128150616809"></p><p>一半的 32KB 加入到对应的空闲分区链表，一半的 32KB 用于分配，这一半对进程 D 来说足够了，于是占用它：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150637464.png" alt="image-20221128150637464"></p><p>进程 D 释放 20KB，回收 32KB，由于事先已经有一个 32KB，所以此时两个互为伙伴的 32KB 进行合并：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150655001.png" alt="image-20221128150655001"></p><p>进程 B 释放 50KB，回收 64KB，由于事先已经有一个 64KB，所以此时两个互为伙伴的 64KB 进行合并，形成 128KB，由于事先已经有一个 128KB，所以此时两个互为伙伴的 128KB 进行合并，形成 256KB：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150726683.png" alt="image-20221128150726683"></p><p><strong>计算伙伴地址的方法</strong>：对于给定的内存块，若它的大小为 2^k^，起始地址为 x，</p><ul><li>如果 <code>x/2^k</code> 为奇数，则伙伴地址为 <code>x - 2^k</code></li><li>如果 <code>x/2^k</code> 为偶数，则伙伴地址为 <code>x + 2^k</code></li></ul><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>快速适应和伙伴系统都是将空闲分区按照大小进行分类，并为每一类建立一个独立的空闲分区链表，再用一个总的索引表进行记录。不过，如果分类过多，则索引表的表项也会过多，这时候搜索索引表的<strong>时间开销</strong>就会比较大。</p><p>因此，哈希算法选择建立一张哈希表（而不是普通的索引表），这张哈希表以空闲分区大小作为关键字，每次需要进行分配的时候，会根据所需空闲分区的大小，通过哈希函数<strong>快速计算得到</strong>该空闲分区在表中的位置，从而得到对应的空闲分区链表。</p><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><p><strong>动态可重定位分区分配算法</strong>与<strong>动态分区分配算法</strong>基本一致，仅仅增加了<strong>紧凑</strong>功能。</p><p>连续分配为某个进程分配的必须是一块连续的空间，若多个空闲分区不是相邻的，即便它们的大小总和已经满足进程的需求，也无法进行分配。采用紧凑技术解决这个问题。紧凑技术把内存中各个进程进行移动并使其相邻，从而化零为整，带来了更大的空闲分区：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128150124939.png" alt="image-20221128150124939"></p><p>在这里会发现，每次发生紧凑，各个程序和数据的物理地址就要发生改变。</p><ul><li>假定我们先前采用的是静态重定位装入方式，那么在模块装入内存的时候，就已经把逻辑地址转换为物理地址了，每次发生紧凑，都要在程序上重新修改一次物理地址。</li><li>如果我们采用动态重定位装入方式，各个程序和数据的地址全部都是逻辑地址，当程序需要访问地址时，无需修改程序上的地址，只需要<strong>将该逻辑地址与当前重定位寄存器里存放的物理起始地址进行相加</strong>。每次发生紧凑时，也只需要用紧凑后的新起始地址去替换重定位寄存器里的旧起始地址。</li></ul><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><p>固定分区分配容易产生内部碎片，动态分区分配容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。</p><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小 <code>X</code> 分割为多个部分，同时把内存也按照固定大小 <code>X</code> 分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于 <code>X</code>，这部分若放到内存的某个 <code>X</code> 空间中，仍然会产生碎片（这种碎片称为页内碎片）。</p><h4 id="页面、页框"><a href="#页面、页框" class="headerlink" title="页面、页框"></a>页面、页框</h4><ul><li><p>页框(Page Frame)：具体来说，把内存分割为多个固定大小 <code>X</code> 的部分，这些部分就叫做页框 &#x2F; 页帧 &#x2F; 物理块 &#x2F; 内存块，每个页框会有一个数字编号，第一个页框就从 0 开始</p></li><li><p>页面(Page)：同样，进程被分割为多个固定大小 <code>X</code> 的部分，这些部分就叫做页面 &#x2F; 页，每个页面会有一个数字编号，第一个页面就从 0 开始</p></li></ul><p><img src="https://static.pil0txia.com/picgo/image-20221128191916596.png" alt="image-20221128191916596"></p><p>若页面太小，虽然可使页内碎片减小、提高内存利用率，但是会使页表过长、降低页面换进换出的效率；若页面太大，则相反。因此页面的大小应是2的整数幂，通常为1KB~8KB。</p><p>系统以页框为单位为各个进程分配内存空间，一个页面就对应一个页框，它具体放到哪个页框是随意的，无需顾虑是否连续和先后顺序。</p><h4 id="地址转换的思路"><a href="#地址转换的思路" class="headerlink" title="地址转换的思路"></a>地址转换的思路</h4><p>假设我们采用动态重定位方式进行模块装入，程序中是逻辑地址，但在程序执行到需要访问地址的时候，需要进行逻辑地址到物理地址的转换。</p><h5 id="十进制地址"><a href="#十进制地址" class="headerlink" title="十进制地址"></a>十进制地址</h5><p>左边进程按照 50B 的大小分为 4 个页面，右边内存按照 50B 的大小分为若干个页框：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192409450.png" alt="image-20221128192409450"></p><p>在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：</p><ul><li>计算逻辑地址的页号</li><li>根据页号找到页号对应页面在内存中的<strong>起始地址</strong></li><li>计算逻辑地址在当前页面内的偏移量（<strong>页内偏移量</strong>）</li><li><code>物理地址 = 起始地址 + 页内偏移量</code></li></ul><p>从左图可以看出，逻辑地址 80 在 1 号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 <strong>在 1 号页面内的偏移量</strong>为 30；所以<code>物理地址 = 450 + 30 = 480</code></p><p>也可以用计算的方法，在已知逻辑地址的情况下：</p><ul><li><code>页号 = 逻辑地址 / 页面大小</code>，即<code>80/50 = 1</code>（取整数部分）</li><li><code>页内偏移量 = 逻辑地址 % 页面大小</code>，即<code>80%50 = 30</code></li></ul><h5 id="二进制地址"><a href="#二进制地址" class="headerlink" title="二进制地址"></a>二进制地址</h5><p>地址实际上是用 32 位二进制数表示的。这时候计算页号 P 和页内偏移量 W 实际上更加简单，因为地址本身已经包含了这两者的信息。</p><p>以页面&#x2F;页框大小 4KB 为例，用地址的前 20 位（红色部分，也叫高 20 位）表示页号 P，用地址的后 12 位（黑色部分，也叫低 12 位）表示页内偏移量 W。页内偏移量的位数可以表明每个页面的大小，即 2^12^ &#x3D; 4KB。0 号页、1 号页、2 号页的表示如下：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192830159.png" alt="image-20221128192830159"></p><p>若页面&#x2F;页框大小为 1KB，也即 2^10^B &#x3D; 1024B，那么地址的前 22 位表示页号，剩余的 10 位表示页内偏移量：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192842511.png" alt="image-20221128192842511"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://static.pil0txia.com/picgo/IMG_20221201_110859.jpg" alt="IMG_20221201_110859"></p><p><img src="https://static.pil0txia.com/picgo/IMG_20221201_111601.jpg" alt="IMG_20221201_111601"></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>根据地址，就已经可以知道页号和页内偏移量，还有一个工作是<strong>根据页号找到对应页面在内存中的物理地址</strong>。</p><p>每一个进程都有一张页表来记录页面号（页号）与页框号（块号）的映射关系，可以根据页号找到内存中对应页框的编号。其中页号是隐含的，相当于从0开始的下标，不占存储空间，页表实际只保存了块号。</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192853911.png" alt="image-20221128192853911"></p><p>根据地址知道页号后，从页表中找出页号对应的块号，再用<code>块号 * 页框大小</code>，即可算出块的<strong>起始地址</strong>。用<code>起始地址 + 偏移量</code>，即可算出物理地址。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><p>上述的地址转换是通过<strong>基本地址变换机构</strong>这个硬件实现的，它借助页表将逻辑地址转换为物理地址。转换过程如下：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192904519.png" alt="image-20221128192904519"></p><p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：</p><ul><li>首先将逻辑地址 A 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，因为页号从 0 开始计算）页表长度的，如果页号越界就会发生越界中断。</li><li>由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表在内存中连续分配的起始地址（假设为 X），所以页号 P 对应的页表项的存放地址等于 <code>X + P*size</code>，在这个地址保存着页号对应的块号</li><li>将块号与偏移量的二进制数<strong>拼接</strong>，就得到了物理地址，得以访问目标</li></ul><p>例子中涉及到的都是二进制数，要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可。如果例子给出的是十进制数，则应用 <code>块起始地址 + 页内偏移量</code> 进行<strong>相加</strong>，计算结果再转化为二进制数。</p><h5 id="例题1-5"><a href="#例题1-5" class="headerlink" title="例题1"></a>例题1</h5><p>若给定的是十进制：</p><blockquote><p>页面大小 1KB，块号 2，偏移量 1023。</p></blockquote><p>块起始地址等于 <code>2 * 1KB = 2 * 1024B = 2048B</code>，又偏移量 1023，所以物理地址等于 <code>2048 + 1023 = 3071</code>，转化为 32 位二进制数，就是 <code>0000000000000000000010,1111111111</code></p><p>若给定的是二进制：</p><blockquote><p>页面大小 1KB，块号 2，偏移量 1111111111。</p></blockquote><p>块号 2 转化为 22 位二进制数就是 <code>0000000000000000000010</code>，与偏移量拼接，就得到 <code>0000000000000000000010,1111111111</code>，与十进制的结果是一样的。</p><h5 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><p>在前面的基本地址变换机构中，存在两个问题：</p><ul><li>每次存取数据都需要<strong>访问内存两次</strong>：第一次访问内存中的页表，找到块号，并将块号与偏移量拼接得到物理地址；第二次根据物理地址访问内存中存放的数据。第二次访存肯定是不能避免的，但是第一次访存可以想办法避免</li><li>若多条指令涉及到的逻辑地址的页号都相同，就都必须经历第一次访存，找到该页号对应的块号</li></ul><p>这两个问题可以通过引入快表来解决。</p><p>快表（联想寄存器）是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程。引入快表后，地址转换大概率<strong>不需要经历第一次访存</strong>，而是直接从快表中拿到需要的页表项。于是内存中原本的页表被称为慢表。</p><p>此时的地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192914850.png" alt="image-20221128192914850"></p><p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：</p><ul><li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li><li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为这里我们是第一次查询，所以是没有的，即<strong>未命中</strong>，页号被送往慢表。</li><li>第一次访存，在慢表中找到页号对应的页表项的地址，意味着找到了页号对应的块号</li><li>将该页表项拷贝一份副本放到快表中</li><li>将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标</li></ul><p>我们需要继续访问某个地址，并且与上次访问的地址的页号一样：</p><ul><li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li><li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为快表中已经存放了一份页表项的副本，所以找到了匹配的页号，即<strong>命中</strong>。</li><li>从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址，得以访问目标</li></ul><h5 id="例题2-2"><a href="#例题2-2" class="headerlink" title="例题2"></a>例题2</h5><blockquote><p>某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。</p></blockquote><ul><li><p>若未引入快表，则访问一个逻辑地址耗时 <code>100 + 100 = 200us</code></p></li><li><p>若引入快表，则访问一个逻辑地址耗时 <code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code></p></li><li><p>若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时 <code>(1+100) * 0.9 + (100+100) * 0.1 = 110.9us</code></p></li></ul><p><img src="https://static.pil0txia.com/picgo/IMG_20221201_112527.jpg" alt="IMG_20221201_112527"></p><h4 id="页表项的大小"><a href="#页表项的大小" class="headerlink" title="页表项的大小"></a>页表项的大小</h4><blockquote><p>假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p></blockquote><p>一条页表项的大小取决于块号的位数。的4GB&#x3D;2^32^B， 4KB&#x3D;2^12^B，因此 4GB 的内存总共会被分为 2^32^&#x2F;2^12^ &#x3D; 2^20^ 个内存块，因此内存块号的范围应该是 0～2^20^-1。因此对于单个页表项，它要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要 3B 才可以表示这样的一个内存块号。</p><p>但是一个页表项用 3 个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面&#x2F;页框大小为 4KB，也即 4096B，由于一个页表项 3B，所以一个页框至多可以放 4096&#x2F;3&#x3D;1365 个页表项，并且这个页框剩余 1B 的空间。由于 1B 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。</p><p>这就会导致，前面 1365 个页表项的地址依然可以采用 <code>X + 3*P</code> 的方式计算，但是第 1366 个页表项，它的地址却应该是 <code>X + 3*P + 1</code>，也就是说，我们无法以一个通用的式子去计算页表项的存放地址。</p><p>因此，一个页表项的大小通常应选取 2 的整数幂。如果页表项大小为 4B，那么一个页框就刚好可以放 4096&#x2F;4&#x3D;1024 个页表项，余下的页表项可以依次放在下一个页框中。这样，涉及到页表项地址的计算都可以用通用的式子 <code>X + 4*P</code>，就无需考虑<strong>由于页框无法得到完全利用</strong>而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该<strong>连续地存放在内存块</strong>中，中间不出现断节。</p><blockquote><p><strong>Q:</strong> 首先，在 <a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">页表项的大小</a> 中，按照您的讲述，第 1366 个页表项的地址应为 <code>X + 3*(P+1)</code>。另外，我对“一个页表项的大小应同样选取 2 的整数幂”的说法抱有疑问，因为“一个页框能否在没有剩余空间的情况下装入足够多的页表项”并不会影响到“利用页号在页表中找到对应的块号”。即使页表项大小为 3B 时，第 1366 个页表项会被装入下一个页框，但是当页表项大小为 4B 时，第 4097 个页表项也同样会被装入下一个页框，不是吗？请问您是怎么理解的呢？</p><p><strong>A:</strong> 页表项的地址≠块号，页表项的存放地址的数据内容才是块号。同样的，块号≠内存块的物理地址，块号是内存块在内存中组织顺序的索引，<code>块号 * 页框大小</code>才等于内存块的起始物理地址。</p><p>问题不在于“如何从已经找到地址的页表项中读取块号”，而在于“如何根据隐含的页号找到页表项的存放地址”。<strong>页号是隐含的</strong>，页表中并没有储存页号，我们无法根据页号直接读取到页表项存储的块号，必须先根据<code>X + P*size</code>这个式子来<a href="#%E9%A1%B5%E8%A1%A8">确定页表项的存放地址</a>。页表项大小为 3B 时，第 1365 个页表项和第 1366 个页表项之间间隔了未分配的 1B，先前<code>X + 3*P</code>的寻址规律就被打破了。<code>X + 3*P + 1</code>中的<code>+1</code>是前一个页框剩余的 1B，而不是“下一个页框”的意思。</p></blockquote><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><h5 id="单级页表占用过大的连续内存空间的问题"><a href="#单级页表占用过大的连续内存空间的问题" class="headerlink" title="单级页表占用过大的连续内存空间的问题"></a>单级页表占用过大的连续内存空间的问题</h5><p>假设页面&#x2F;页框大小 4KB，页表项大小 4B，一个页表占用的空间：</p><ul><li>计算页表一共有多少个页表项：4KB &#x3D; 2^12^B，所以 32 位逻辑地址中，后 12 位表示偏移量，前 20 位表示页号。总共有 2^20^ 个页面，也就是有 2^20^ 个页表项需要存放。</li><li>计算一个页框可以放多少个页表项：一个页框 4KB，一个页表项 4B，所以一个页框可以放 4096&#x2F;4 &#x3D; 1024 个页表项</li><li>计算存放所有页表项需要多少个页框：2^20^&#x2F;1024 &#x3D; 1024</li></ul><p>需要 1024 个页框才能放下整个页表，而且为了以通用的式子计算页表项地址，页表必须是连续存放的，这违背了分页存储的初衷。</p><h5 id="引入两级页表"><a href="#引入两级页表" class="headerlink" title="引入两级页表"></a>引入两级页表</h5><p>就像进程拆分为多个页面一样，页表也可以进行拆分：将长的单级页表分为多个子页表，再将每每个子页表离散地存放到各个内存块中。在<a href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98">之前的例子</a>中，一个页框可以放 1024 个页表项，那么每 1024 个页表项就拆分出一个子页表，因为页表一共有 2^20^ 个页表项，所以一共可以拆分出 1024 个子页表，这些子页表再各自存放到内存块中。</p><p>于是，我们需要一张<strong>页目录表</strong>（<strong>一级页表</strong>&#x2F;顶层页表&#x2F;外层页表）来记录页目录表和<strong>子页表</strong>（<strong>二级页表</strong>）之间的映射关系，如下图：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192925065.png" alt="image-20221128192925065"></p><p>同时，之前的逻辑地址的含义也发生了改变。在单级页表中，前 20 位表示页号；而在两级页表中，前 10 位表示<strong>一级页号</strong>（一级页表的页号），紧跟着的 10 位表示<strong>二级页号</strong>（二级页表的页号）。这么划分之后，一级页号共有 2^10^&#x3D;1024 种可能的取值，即页目录表的 1024 个页表项；二级页号也有 2^10^&#x3D;1024 种可能的取值，即子页表的 1024 个页表项。</p><p>在需要进行地址转换时：</p><ul><li>首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量</li><li>然后从 PCB 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即读取到了一级页号对应的块号</li><li>根据块号到内存中找到对应的二级页表</li><li>在二级页表中，根据二级页号找到对应的块号</li><li><code>块号 * 页框大小 + 偏移量</code>得到物理地址</li></ul><p>上面的过程也可以直接看这幅图理解：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192933032.png" alt="image-20221128192933032"></p><h5 id="单级页表常驻内存的问题"><a href="#单级页表常驻内存的问题" class="headerlink" title="单级页表常驻内存的问题"></a>单级页表常驻内存的问题</h5><p>执行程序时，往往只需要访问特定的几个页面，但整个单级页表是常驻在内存中的。[虚拟存储技术](#第五章 虚拟存储器)可以在需要访问页面的时候才把对应的页表项调入内存。</p><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><blockquote><p>某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用多少级页表？页内偏移量为多少位？</p></blockquote><p>4KB &#x3D; 4*1024B &#x3D; 2^12^B，根据之前讲过的，页面偏移量应该是 12 位。40 - 12 &#x3D; 28，所以前面 28 位用来表示页号。</p><p>因为<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>，而一个页面最多只能放 1024 个页表项，所以应该限制页表最多只能包含 1024 个页表项（否则就放不下多余的页表项，导致页表超过一个页面），即逻辑地址中的 10 位二进制数。</p><p>在逻辑地址的前 28 位中，可以选择 10 位用于表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用 10 位表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用剩下的 8 位表示某一级的页号（这一级的页表假设页表项远远少于 1024 个）。</p><p>也可以考虑前面 8 位作为一级页号，紧接着的 10 位作为二级页号，再紧接着的 10 位作为三级页号，这样刚好就用完了逻辑地址前 28 位。所以题目需要采用三级页表。</p><p>那如果这里不采用三级页表，强行使用二级页表，则必定有某一级的页号位数超过了 10，说明页表的页表项个数超过了 2^10^&#x3D;1024 个，很显然就会导致一个页框放不下这一级的页表，需要跨页，这与规定“<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>”是相悖的。</p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><blockquote><ol><li>若系统采用两级分页存储方式，物理内存 64MB，页面大小 1KB，页表项大小 2B，则顶级页表有多少个页表项？</li></ol></blockquote><p>这里我们可以参考之前<a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">求页表项大小</a>的思路。物理内存 64MB &#x3D; 2^26^B，表示这么多内存需要 26 位逻辑地址。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。</p><p>因为页面大小 1KB &#x3D; 2^10^B，所以页内偏移量需要 10 位来表示，余下 16 位供一、二级页号使用。一个页面大小 2^10^B，一个页表项 2B，所以一个页框可以最多可以放 2^10^&#x2F;2 &#x3D; 2^9^ 个页表项，又由于<strong>各级页表不能超过一个页面</strong>，所以各级页表都不能超过 2^9^ 个页表项。在余下的 16 位中，用 9 位表示二级页表的页号（此时该页表的页表项个数取满）。剩下的 7 位表示一级页表的页号，可以包含 2^7^ &#x3D; 128 个页表项。</p><blockquote><ol start="2"><li>若系统采用分页存储方式，物理内存 256MB，页面大小 1KB，页表如下：</li></ol><p>页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39</p><p>则逻辑地址 1A68（16 进制）对应的物理地址是多少？</p></blockquote><p>为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。</p><p>1A68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：</p><ul><li>页号 &#x3D; 6760&#x2F;1024 &#x3D; 6（取整数部分）</li><li>页内偏移量 &#x3D; 6760%1024 &#x3D; 616</li></ul><p>根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 &#x3D; 31744，偏移量和初始地址相加得到的物理地址为 31744+616 &#x3D; 32360。32360 是十进制的物理地址，短除法转化为对应的十六进制物理地址就是 7E68。</p><blockquote><p>若统一使用二进制计算：</p><p>256MB &#x3D; 2^28^B 逻辑地址共28位</p><p>1A68 转换为二进制：0001 1010 0110 1000</p><p>页内偏移量 10位</p><p>28-10&#x3D;18 页号位数</p><p>补齐位数0000 0000 0000 0001 1010 0110 1000</p><p>即000000000000000110,1001101000</p><p>页号为6，起始地址 31*1024&#x3D;31744</p><p>出题者想让你用十进制做，因为给的是十进制的页表</p></blockquote><blockquote><ol start="3"><li>若系统采用分页存储方式，物理内存 1MB，共有 32 个页面，一个页面 2KB，则逻辑地址一共多少位？</li></ol></blockquote><p><del>因为物理内存 1MB &#x3D; 2^20^B，所以逻辑地址 20 位。</del></p><p>根据上面的经验，我们可能会这么做，但是<strong>这是错误的做法</strong>。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位，逻辑地址也需要多少位。但是这道题已经告诉了我们程序具体被划分为32个页面——显然，仅仅 32 个页面是不需要 20 这么多位的逻辑地址的。</p><p>逻辑地址包括两部分，页号和页内偏移量：</p><ul><li>考虑页内偏移量位数。由于一个页面 2KB，也即 2^11^B，所以页内偏移量占 11 位（注意这点是不变的）</li><li>考虑页号位数。<strong>由于页面仅仅被划分为 32 &#x3D; 2^5^ 个</strong>，所以页号只需要 5 位</li></ul><p>11 + 5 &#x3D; 16，所以逻辑地址一共 16 位。</p><p><strong>当题目明确给出分页个数的时候，按照页号位数 + 偏移量位数计算逻辑地址总位数。</strong></p><h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p>在基本分页存储管理中，我们将程序分为多个大小相等的物理单元（页面）。而在基本分段存储管理中，我们倾向于从逻辑功能的角度去考虑，将程序<strong>分为多个逻辑功能段</strong>，每个段都有自己的段名，并且都从 0 开始编址。分配内存时以段为单位进行分配，段内所占内存空间是连续的，但是各个段之间可以不相邻，如下图：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192944911.png" alt="image-20221128192944911"></p><p>编写程序时可以将程序按照逻辑功能模块进行划分，会更加方便，可读性会更高，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[D]|&lt;A&gt;</span><br><span class="line">STORE 1，[X]|&lt;B&gt;</span><br></pre></td></tr></table></figure><p>分别表示：将分段 D 中 A 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 X 的 B 单元中。这里的分段 D 和 X 都是段名，程序员在编程的时候只需要使用段名，编译时段名会转化为对应的段号。同理，A、B 单元编译时也会转化为寄存器地址。</p><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>分段存储管理中逻辑地址的含义与分页存储管理不同。假设仍然是用 32 位二进制数表示逻辑地址，地址的前 16 位表示<strong>段号</strong>，后 16 位表示段内<strong>偏移量</strong>：</p><ul><li>段号是 16 位二进制数，有 2^16^ 种取值，即每个进程最多可以被分为 2^16^ 个段</li><li>段内偏移量也是 16 位二进制数，在一个段内，段内地址可能有 2^16^ 种取值，所以一个段的最大长度为 2^16^</li></ul><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>类似的，我们需要用<strong>段表</strong>来记录某个编号段与实际物理存放位置之间的映射关系。在分段存储管理中，程序被分为大小不等的多个段，且不连续，没法像之前一样只凭借块号来推导块的初始地址。为了准确地找出段存放在内存中的位置，我们要将<strong>段号、段长、基址</strong> 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的基址（即起始地址，不是块号），再结合段长，可以知道这个段具体占用了哪里的空间。</p><p>如下图所示：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128192954137.png" alt="image-20221128192954137"></p><h4 id="段表项的大小"><a href="#段表项的大小" class="headerlink" title="段表项的大小"></a>段表项的大小</h4><p>每个段表项由段号、段长、基址构成，我们可以依次考虑每一列可能占用的空间（假设物理内存 4GB，按字节寻址）：</p><ul><li>基址：因为物理内存 4GB，也就是 2^32^B，那么内存中的地址最多可能取到 2^32^ 种值。为了让基址列<strong>足够</strong>表示这些值，基址列占用了 32 位。</li><li>段长：前面讲过，在逻辑地址中，段号和段内偏移量都是 16 位，所以段内偏移量最多可能取到 2^16^ 种值，为了让段长列<strong>足够</strong>表示这些值，段长列占用了 16 位</li><li>段号：和页表一样，在<strong>段表中同样隐含段号</strong>，因为段表也是连续的，我们只需要知道<strong>段表的起始地址</strong>和<strong>每个段表项的大小</strong>就能定位一个<strong>段表项的地址</strong>，而无需去维护一个从段号到段表项的映射。</li></ul><p>因此，每个段表项占用了 16+32&#x3D;48 位，一个字节 8 位，占用了 6 个字节， 即 6B。</p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>转换过程我们可以直接看下图理解：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128193010730.png" alt="image-20221128193010730"></p><p>可以联系分页存储的地址转换过程。在需要将逻辑地址转换为物理地址的时候：</p><ul><li>首先将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度保存了程序总共被分为了多少段，因此段号不应该超过段表长度，若超过则发生越界中断。</li><li>根据段号、段表初始地址和段表项的大小，找到段号对应的段表项。比较段表项中的段长 C 和逻辑地址中的段内偏移量 W，若 W &gt;&#x3D; C 则发生越界中断（此处比分页存储多一次越界判断，因为页表的页框大小固定，且受页内偏移量位数限制不会越界，而段长可变）</li><li>在段表项中找到段号对应的基址，将该基址与段内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li></ul><h4 id="分页和分段的对比"><a href="#分页和分段的对比" class="headerlink" title="分页和分段的对比"></a>分页和分段的对比</h4><h5 id="划分的角度和维度"><a href="#划分的角度和维度" class="headerlink" title="划分的角度和维度"></a>划分的角度和维度</h5><p><img src="https://static.pil0txia.com/picgo/image-20221128193022033.png" alt="image-20221128193022033"></p><h5 id="信息的共享和保护"><a href="#信息的共享和保护" class="headerlink" title="信息的共享和保护"></a>信息的共享和保护</h5><p>在分段存储方式中，更容易实现信息共享和保护：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128193032194.png" alt="image-20221128193032194"></p><p>可重入代码(Reentry code)也叫纯代码(Pure code)是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。</p><p>在分页存储方式中，则很难：</p><p><img src="https://static.pil0txia.com/picgo/image-20221128193042146.png" alt="image-20221128193042146"></p><h5 id="访存次数"><a href="#访存次数" class="headerlink" title="访存次数"></a>访存次数</h5><p>两者的访存次数是一样的：</p><ul><li>若不引入快表，两者的第一次访存都是访问内存中的页&#x2F;段表，第二次是访问内存中的目标。</li><li>若引入快表，则两者的第一次访存有可能因为命中而省去。</li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><ul><li>采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护</li><li>采用分段存储管理，可以按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片</li></ul><p>所以结合二者之长，出现了段页式存储管理方式。</p><p>如下图，段页存储管理会首先将进程按照逻辑模块划分为多个段，针对每个段再划分为多个页；同时也把内存划分为多个页框。分配内存的时候，一个页面就对应了一个页框。</p><p><img src="https://static.pil0txia.com/picgo/image-20221128193050234.png" alt="image-20221128193050234"></p><h4 id="逻辑地址-1"><a href="#逻辑地址-1" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>在分段存储管理中，给出一个逻辑地址，可以划分为段号和段内地址两个部分；而在段页存储管理中，段内地址还要继续细分成页号和页内偏移量两个部分。所以逻辑地址由<strong>段号、页号和页内偏移量</strong>三个部分组成。</p><p>段号的位数仍然决定了一个进程可以被划分为多少个段，而页号的位数则决定了一个段可以被划分为多少个页面，页内偏移量则决定了一个页面可以有多大，即页面&#x2F;页框大小。</p><p>和分段存储管理一样，段页存储管理的地址结构也是二维的。</p><h4 id="段表-1"><a href="#段表-1" class="headerlink" title="段表"></a>段表</h4><p>段页存储管理中的段表不同于分段存储管理中的段表。程序被划分为多个段，每个段都会再被划分为多个页面，因此每一个段都维护着属于自己的一张页表。段表需要记录的是段号与段号对应段的页表之间的映射关系，包括<strong>段号</strong>、<strong>页表长度</strong>和<strong>存放页表的块号</strong>（块号 * 页框大小 &#x3D; 页表所在块的起始地址）。<strong>段号是隐含的</strong>。</p><p><img src="https://static.pil0txia.com/picgo/image-20221128193058929.png" alt="image-20221128193058929"></p><h4 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="https://static.pil0txia.com/picgo/image-20221128193131085.png" alt="image-20221128192331085"></p><p>段页式存储的地址转换机构结合了分页存储和分段存储的方式，在需要将逻辑地址转换为物理地址的时候：</p><ul><li>首先将逻辑地址分为<strong>段号、页号和页内偏移量</strong>三个部分，段表寄存器中的段表长度仍代表程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则越界中断（同段式存储第一次越界检查）</li><li>根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。可以从这个段表项读取到该段号对应的页表的位置和大小。这里同样要比较段表项中的页表长度和逻辑地址中的页号 P，若页号大于等于页表长度则越界中断（同页式存储唯一一次越界检查，不同于段式存储第二次越界检查）</li><li>找到了段表项就是找到了该段的页表所在块的块号。根据块号，在内存中找到这个块，再从块中找到页表</li><li>根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li></ul><h4 id="访存次数-1"><a href="#访存次数-1" class="headerlink" title="访存次数"></a>访存次数</h4><p>不采用快表时，段页式存储管理需要经历三次访存：第一次访存，访问内存中的段表，找到段表中记录的页表信息；第二次访存，访问内存中的页表，找到目标所在的块；第三次访存，访问内存中的目标。</p><p>如果采用快表，会利用段号和页号去寄存器中检索，若命中，则无需经历第一次和第二次访存，可以直接拿到块号并和偏移量进行拼接，得到物理地址。同样只需要一次访存。</p><h1 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h1><h1 id="期末考试备考"><a href="#期末考试备考" class="headerlink" title="期末考试备考"></a>期末考试备考</h1><p>选择题 15分</p><p>判断题 10分</p><p>简答题 30分</p><p>综合应用题 45分</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大三上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能重点题目整理</title>
      <link href="/post/2022-06-20_ai-introductory-theory-notes/"/>
      <url>/post/2022-06-20_ai-introductory-theory-notes/</url>
      
        <content type="html"><![CDATA[<ul><li><p><input checked="" disabled="" type="checkbox"> p99 UCB1算法公式两项的含义</p><p><img src="https://static.pil0txia.com/picgo/image-20220620222856389.png" alt="image-20220620222856389"></p><p><img src="https://static.pil0txia.com/picgo/image-20220620222610471.png" alt="image-20220620222610471"></p><p><img src="https://static.pil0txia.com/picgo/image-20220620223211284.png" alt="image-20220620223211284"></p></li><li><p><input checked="" disabled="" type="checkbox"> A*</p><p><img src="https://static.pil0txia.com/picgo/image-20220621103752077.png" alt="image-20220621103752077"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621103832037.png" alt="image-20220621103832037"></p></li><li><p><input checked="" disabled="" type="checkbox"> 3.4.3 蒙特卡洛树搜索算法 p103图3.24, 3.25, 3.26</p><p><img src="https://static.pil0txia.com/picgo/image-20220621124955132.png" alt="image-20220621124955132"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621125025580.png" alt="image-20220621125025580"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621125404271.png" alt="image-20220621125404271"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621130016095.png" alt="image-20220621130016095"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621130226727.png" alt="image-20220621130226727"></p><blockquote><p><strong>UCB值的分母都为当前结点的被访问次数（右），开方外的分子为收益分数，开方内ln后的为父节点的被访问次数</strong></p></blockquote><p><img src="https://static.pil0txia.com/picgo/image-20220621130723401.png" alt="image-20220621130723401"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621130754727.png" alt="image-20220621130754727"></p></li><li><p><input checked="" disabled="" type="checkbox"> Alpha-Beta剪枝算法 p102图3.16例题：MIN更新上界，MAX更新下界</p><p><img src="https://static.pil0txia.com/picgo/image-20220621111558025.png" alt="image-20220621111558025"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621112355664.png" alt="image-20220621112355664"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621112953625.png" alt="image-20220621112953625"></p></li><li><p><input checked="" disabled="" type="checkbox"> p269 Q学习算法 图7.10例题</p><p><img src="https://static.pil0txia.com/picgo/image-20220621131654623.png" alt="image-20220621131654623"></p></li><li><p><input checked="" disabled="" type="checkbox"> P43 内生变量, 外生变量</p><p><img src="https://static.pil0txia.com/picgo/image-20220620225820304.png" alt="image-20220620225820304"></p><p><img src="https://static.pil0txia.com/picgo/image-20220620225823514.png" alt="image-20220620225823514"></p><p><img src="https://static.pil0txia.com/picgo/image-20220620230159874.png" alt="image-20220620230159874"></p></li><li><p><input checked="" disabled="" type="checkbox"> P45 乘积分解规则 例2.20</p><p><img src="https://static.pil0txia.com/picgo/image-20220620232813240.png" alt="image-20220620232813240"></p><p><img src="https://static.pil0txia.com/picgo/image-20220620233200681.png" alt="image-20220620233200681"><br><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220621001526.png"></p></li><li><p><input checked="" disabled="" type="checkbox"> p50 D-分离 例2.25</p></li></ul><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220621001833.png"></p><p><img src="https://static.pil0txia.com/picgo/image-20220621002520991.png" alt="image-20220621002520991"></p><ul><li><p><input checked="" disabled="" type="checkbox"> 什么是深度学习中的梯度爆炸和梯度消失？产生的原因分别是什么？分别有哪些方法可以缓解？</p><blockquote><p>我们最优的权值就是为了寻找下图中的最小值点，对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。因此，对于神经网络这种参数式的方法，使用梯度更新可以用来寻找最优的参数。</p><p>梯度爆炸一般出现在深层网络和权值初始化值太大的情况下</p></blockquote><p><img src="https://static.pil0txia.com/picgo/image-20220621114703950.png" alt="image-20220621114703950"></p><blockquote><p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p><p> relu等激活函数</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> 什么是SVM分类器的核函数，为什么要使用核函数？</p><blockquote><p>1.在实际数据上经常遇到线性不可分的情况 而解决方法是将特征映射到更高维的空间去<br>2.凡是遇到线性不可分的情况 一律映射到高维度空间 会出现维度爆炸的情况<br>3.核函数虽然也是将特征进行从低维到高维的转化 但是是在低维上进行计算 而实际的效果表现在高维上 解决了维度爆炸的问题</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> SVM 初始优化问题为什么要引入软间隔，并解释等价的hinge损失函数。</p><blockquote><p>有些时候，有噪声点数据是线性不可分的，这样的话就无法以用硬间隔去做，只能用软间隔SVM。（目的：为了去解决一些线性不可分的数据集）</p><ol><li>实现了软间隔分类（这个Loss函数都可以做到）</li><li><strong>保持了支持向量机解的稀疏性</strong></li><li><strong>HingeLoss的零区域对应的正是非支持向量的普通样本，从而所有的普通样本都不参与最终超平面的决定，这才是支持向量机最大的优势所在，对训练样本数目的依赖大大减少，而且提高了训练效率。</strong></li></ol></blockquote><p><img src="https://static.pil0txia.com/picgo/image-20220621123208279.png" alt="image-20220621123208279"></p></li><li><p><input checked="" disabled="" type="checkbox"> 6.6.1 词向量模型</p></li><li><p><input checked="" disabled="" type="checkbox"> 第二章 人工智能的Agent-Environment模型</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表逆置有多少种写法？</title>
      <link href="/post/2022-05-17_linked-list-reverse/"/>
      <url>/post/2022-05-17_linked-list-reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="链表逆置-C-语言"><a href="#链表逆置-C-语言" class="headerlink" title="链表逆置 C 语言"></a>链表逆置 C 语言</h1><p><strong>创建所需的相关结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先我们创建一个函数用于创建链表的。</p><p><strong>建立创建链表的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* <span class="built_in">writeList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* head = <span class="literal">NULL</span>, * current = <span class="literal">NULL</span>, * prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data) &amp;&amp; data != <span class="number">0</span>)<span class="comment">//0为标记输入结束</span></span><br><span class="line">&#123;</span><br><span class="line">current = (<span class="keyword">struct</span> List*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> List*));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">head = current;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">prev-&gt;next = current;</span><br><span class="line">current-&gt;date = data;</span><br><span class="line">current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">prev = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有了链表当然也得有个输出链表内部数据的函数，来验证查看我们链表内的内容。</p><p><strong>建立打印链表内容的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">struct</span> List* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* p = L;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;date);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然链表申请了内存空间我们就得释放内存空间</p><p><strong>建立释放内存空间的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeList</span><span class="params">(<span class="keyword">struct</span> List* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* freeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != head)</span><br><span class="line">&#123;</span><br><span class="line">freeNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(freeNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始正题。</p><p><strong>链表逆置</strong></p><p>首先我们要明白什么是链表逆置，链表逆置顾名思义，链表的表头和表位改变，打个比方如果链表就是一列火车的话链表逆置以后火车头变成火车尾, 第二节车厢会变成倒数第二节车厢，第三节车厢变成倒数第三节车厢以此类推最后火车尾变成火车头。如图所示：</p><p><img src="https://static.pil0txia.com/picgo/20210410172325544.png"></p><p><strong>实现逆置的方法</strong></p><p><em>1. 迭代实现逆置</em></p><p>链表迭代逆置的时候需要借助三个指针，这里我们把三个指针定义为 bigin,mid,end 这三个并让他们分别指向如图所示。</p><p><img src="https://static.pil0txia.com/picgo/20210410174700397.png"></p><p>begin 指针指向初始化为空 null，mid 指针指向初始化为链表头 head，end 指针指向初始化为第二节点。</p><p>准备工作做好了现在就可以开始一个节点一个节点的逆置了。</p><p><strong>第一步</strong>：mid 指针指向的节点的指针域要与 begin 相同。也就是 mid 指针指向的节点的指针域变成与 begin 相同的值 null。这样子链表第一节点也就是链表头会和其他节点分离出来。</p><p><strong>第二步</strong>：每个指针都向后移动一个节点准备逆置下一个节点，也就是说 begin 指针指向原链表第一节点也就是头节点，mid 指针指向原链表第二节点，end 指针指向原链表第三节点。<br>上述步骤可以看下面的解析图。</p><p><img src="https://static.pil0txia.com/picgo/20210410181716197.png"></p><p>继续上述操作。</p><p><strong>第一步</strong>：mid 指针指向的节点的指针域要与 begin 相同也就是指向原链表第一节点原链表的链表头。</p><p><strong>第二步</strong>：每个指针都向后移动一个节点准备逆置下一个节点。这个时候 begin 指针指向原链表第二节点，mid 指针指向原链表第三节点，end 指针指向原链表第四节点。</p><p>如图所示：</p><p><img src="https://static.pil0txia.com/picgo/20210410183143749.png"></p><p>继续。</p><p><strong>第一步</strong>：mid 指针指向的节点的指针域要与 begin 相同也就是指向原链表第二节点。</p><p><strong>第二步</strong>：每个指针都向后移动一个节点准备逆置下一个节点。这个时候 begin 指针指向原链表第三节点，mid 指针指向原链表第四节点，end 指针指向原链表第四节点的指针域也就是 null。因为原链表已经没有了第五节点所以第四节点就是链表的表尾。</p><p>具体步骤解析如图所示。</p><p><img src="https://static.pil0txia.com/picgo/20210410184101350.png"></p><p>到了这一步不难发现现在离完成逆置很接近了。接下来我们只需要改变 mid 指针的指向和 head 头指针的指向就好了。</p><p><strong>第一步</strong>：mid 指针指向的节点的指针域要与 begin 相同也就是指向原链表第三节点。</p><p><strong>第二步</strong>：这一次我们不需要移动 begin，mid，end 三个指针了，现在我们只需要改变 head 头指针的指向就好了，head 头指针的指向改为和 mid 指针相同。</p><p>以下为解析图：</p><p><img src="https://static.pil0txia.com/picgo/20210410185045110.png"></p><p>到了这里我们的链表就已经逆置完毕了，这就是用迭代方法逆置链表。</p><p>代码实现如下（C 语言）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代逆置法，head 为无头节点链表的头指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* <span class="built_in">iteration_reverseList</span>(<span class="keyword">struct</span> List* head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> List* beg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* mid = head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* end = head-&gt;next;</span><br><span class="line"><span class="comment">//一直遍历</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//mid指针指向节点的指针域要与beg指针指向一样</span></span><br><span class="line">mid-&gt;next = beg;</span><br><span class="line"><span class="comment">//判断 end 是否为 NULL，如果成立则已经找到原链表尾，退出循环</span></span><br><span class="line"><span class="keyword">if</span> (end == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// beg，mid，end三个指针都向后移动一个节点准备逆置下一个节点</span></span><br><span class="line">beg = mid;</span><br><span class="line">mid = end;</span><br><span class="line">end = end-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后head头指针的指向改为和mid指针相同。</span></span><br><span class="line">head = mid;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>2. 递归逆置链表</em></p><p>递归逆置法和迭代逆置法的思想恰好相反，递归逆置法的实现思想是从链表的尾节点开始，依次向前遍历，遍历过程依次改变各节点的指向，即另其指向前一个节点。</p><p>递归理解起来要比迭代难一点，我们先附上实现代码，然后一一讲解。</p><p>样例代码（C 语言）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* <span class="built_in">recursion_reverseList</span>(<span class="keyword">struct</span> List* head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//空链表或者只有一个节点的时候直接返回头指针就好了，因为逆置没有意义。</span></span><br><span class="line"><span class="comment">/*当然这个也是我们递归的出口，</span></span><br><span class="line"><span class="comment">如果找到最后一个节点的时候开始向外层层退出*/</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//递归内入，原链表被分成多个子链表，直到最后一个节点。最后一个节点也会被分成只有一个链表头的子链表</span></span><br><span class="line"><span class="keyword">struct</span> List* new_head = <span class="built_in">recursion_reverseList</span>(head-&gt;next);</span><br><span class="line"><span class="comment">/*在每一层递归中head指针指向的节点的下一个节点的指针域要与head指针指向要相同,</span></span><br><span class="line"><span class="comment">这也就是在从子链表拆卸一个节点，接到正在逆置的链表后面。，例如head指向原链表的第二节点，</span></span><br><span class="line"><span class="comment">此时第二节点接在原链表的第一节点，经过上面操作以后，原链表第二节点会被接在原链表第三节点后面，实现部分逆置。*/</span></span><br><span class="line"><span class="comment">//做完上述操作后把当前head指针指向节点的指针域改为null，因为这个是当前我们已经逆置完的节点组成的子链表的链表尾。</span></span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> new_head;</span><br><span class="line"><span class="comment">/*new_head指针保存最后一个节点，也就是原链表尾，并一直向上一层返回，</span></span><br><span class="line"><span class="comment">逆置后我们的原链表尾会变成逆置后的链表头，这个就是逆置后的链表头，一直向上返回能保证链表逆置完还能找到新的链表头*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们用图去一一分析递归逆置链表的过程。</p><p>刚开始函数向内递归链表被切成很多子链表。</p><p><img src="https://static.pil0txia.com/picgo/2021041114075133.png"></p><p>现在开始递归向外层，一层一层退出。并进行子链表的逆置衔接。完成逆置。</p><p><img src="https://static.pil0txia.com/picgo/20210411141751246.png"></p><p><em>3 头插法逆置链表</em></p><p>头插法比较好理解。在原有链表的基础上，依次将位于链表头部的节点摘下，然后采用从头部插入的方式生成一个新链表，则此链表即为原链表的逆置版。</p><p>具体操作如图</p><p><img src="https://static.pil0txia.com/picgo/20210411141925960.png"></p><p>代码实现（C 语言）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* <span class="built_in">head_reverse</span>(<span class="keyword">struct</span> List* head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* new_head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* temp = <span class="literal">NULL</span>;<span class="comment">//用于临时存储节点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="comment">//将 temp 从 head 中摘除</span></span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="comment">//将 temp 插入到 new_head 的头部</span></span><br><span class="line">temp-&gt;next = new_head;</span><br><span class="line">new_head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>4 就地逆置法逆置链表</em></p><p>就地逆置法和头插法的实现思想类似，唯一的区别在于，头插法是通过建立一个新链表实现的，而就地逆置法则是直接对原链表做修改，从而实现将原链表反转。在原链表的基础上做修改，需要额外借助 2 个指针（假设分别为 beg 和 end）。</p><p>初始状态下， beg 指针 指向第一个节点，end 指针指向 beg-&gt;next，也就是原链表的第二节点。如下图：</p><p><img src="https://static.pil0txia.com/picgo/20210411142501438.png"></p><p>接下来将 end 所指节点 2 从链表上摘除，然后再添加至当前链表的头部。如图所示。</p><p><img src="https://static.pil0txia.com/picgo/20210411143408724.png"></p><p>我们继续上面的操作。</p><p><img src="https://static.pil0txia.com/picgo/2021041114405421.png"></p><p>再来一次我们就完成逆置了。</p><p><img src="https://static.pil0txia.com/picgo/20210411144457175.png"></p><p>最后我们就完成了链表的逆置。</p><p><img src="https://static.pil0txia.com/picgo/20210411144759593.png"></p><p>代码实现（C 语言)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* <span class="built_in">local_reverse</span>(<span class="keyword">struct</span> List* head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* beg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>* end = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">beg = head;</span><br><span class="line">end = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (end != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将 end 从链表中摘除</span></span><br><span class="line">beg-&gt;next = end-&gt;next;</span><br><span class="line"><span class="comment">//将 end 移动至链表头</span></span><br><span class="line">end-&gt;next = head;</span><br><span class="line">head = end;</span><br><span class="line"><span class="comment">//调整 end 的指向，另其指向 beg 后的一个节点，为反转下一个节点做准备</span></span><br><span class="line">end = beg-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原文地址 <a href="https://blog.csdn.net/m0_52072919/article/details/115566960">blog.csdn.net</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 链表 </tag>
            
            <tag> 逆置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23年春招实习准备</title>
      <link href="/post/2022-03-18_23-spring-internship/"/>
      <url>/post/2022-03-18_23-spring-internship/</url>
      
        <content type="html"><![CDATA[<h2 id="形势"><a href="#形势" class="headerlink" title="形势"></a>形势</h2><p>校招(含实习生春招)指南 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/30178304">https://zhuanlan.zhihu.com/p/30178304</a></p><p>春招实习，暑期实习和日常实习有哪些区别？ - 知乎<br><a href="https://www.zhihu.com/question/380709386">https://www.zhihu.com/question/380709386</a></p><p>现在计算机大厂985本科是不是难进了? - 知乎<br><a href="https://www.zhihu.com/question/446863957">https://www.zhihu.com/question/446863957</a></p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>可能是一份没什么用的互联网校招指南… - 知乎<br><a href="https://zhuanlan.zhihu.com/p/24887478">https://zhuanlan.zhihu.com/p/24887478</a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>如果一定要在C++和JAVA中选择，是C++还是java？ - 知乎<br><a href="https://www.zhihu.com/question/20736151">https://www.zhihu.com/question/20736151</a></p><p>计算机专业大学生应该在大学四年踏实学哪些东西? - 知乎<br><a href="https://www.zhihu.com/question/27368268/answer/1912558542">https://www.zhihu.com/question/27368268/answer/1912558542</a></p><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>剑指Offer_在线编程+题解_牛客题霸_牛客网<br><a href="https://www.nowcoder.com/ta/coding-interviews">https://www.nowcoder.com/ta/coding-interviews</a></p><h2 id="找实习网站"><a href="#找实习网站" class="headerlink" title="找实习网站"></a>找实习网站</h2><p>实习僧_大学生实习、校招求职招聘网站_实习_校园招聘丨萌想科技<br><a href="https://www.shixiseng.com/">https://www.shixiseng.com/</a></p><p>「南京招聘网」海量南京人才招聘信息 - BOSS直聘<br><a href="https://www.zhipin.com/nanjing/">https://www.zhipin.com/nanjing/</a></p><p>互联网求职招聘找工作-上拉勾招聘-专业的互联网求职招聘网站<br><a href="https://www.lagou.com/">https://www.lagou.com/</a></p><p>高薪职位列表_名企职位推荐_热门行业推荐-大街网<br><a href="https://www.dajie.com/">https://www.dajie.com/</a></p><h2 id="阿里云云原生Serverless技术实践营南京站"><a href="#阿里云云原生Serverless技术实践营南京站" class="headerlink" title="阿里云云原生Serverless技术实践营南京站"></a>阿里云云原生Serverless技术实践营南京站</h2><p>与微信<code>阿里云Serverless团队负责人花名弈川</code>一番交谈得：</p><ul><li>有关考研，若大三时得到大厂实习机会，大四可以进入大厂，就无需再考研</li><li>腾讯的实习机会较多，从日常实习开始，再暑期实习</li><li>大部分985学生无法进入大厂，比例不到30%</li></ul><p>与钉钉<code>阿里云Serverless团队运营姜曦</code>一番交谈得：</p><ul><li>关注 <code>阿里巴巴招聘官网-学生板块</code> 获得实习信息</li><li>关注 <code>阿里云开发者社区</code>关注比赛信息</li><li>此次实践营全场最快做出全部五个实操对他们团队而言认可度较高，可以直接投简历给真人，包括钉钉<code>阿里云Serverless负责人望宸</code></li></ul><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><h3 id="BV1ME411K71g"><a href="#BV1ME411K71g" class="headerlink" title="BV1ME411K71g"></a>BV1ME411K71g</h3><p>面试常见问题：</p><ol><li>你的缺点是什么</li></ol><ul><li>避开会影响工作的缺点，避开性格方面的缺点。</li><li>以专业知识为切入点。</li></ul><ol start="2"><li>你的职业规划是什么</li></ol><ul><li>表达出稳定性和目标感。</li><li>对行业和岗位，逻辑表达清晰。</li></ul><ol start="3"><li>为什么想来我们公司、投这个岗位</li></ol><ul><li>了解这个公司的背景，对前景的看法、机遇和挑战。</li><li>你的求职目标和投递岗位的匹配度，个人发展空间。</li></ul><ol start="4"><li>你有什么问题要问我的</li></ol><ul><li>可以问：岗位业务流程、学习、推荐、入职培训机制等。</li><li>避免问：薪资、私人问题、和岗位无关的问题等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 春招 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记</title>
      <link href="/post/2022-03-18_computer-networks-notes/"/>
      <url>/post/2022-03-18_computer-networks-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="波特率-amp-码元"><a href="#波特率-amp-码元" class="headerlink" title="波特率&amp;码元"></a>波特率&amp;码元</h2><ol><li>在无噪声情况下，若某通信链路的带宽为3khz 。采用4个相位。每个相位具有4种振幅的QAM调制技术，则该通信链路的最大数据传输速率是？</li></ol><ul><li>24kbit&#x2F;s</li><li>48kbit&#x2F;s</li><li>96kbit&#x2F;s</li><li>12kbit&#x2F;s</li></ul><p>考查对奈氏准则和香农定理，这是通信工程的理论。软件可忽略。</p><p>奈奎斯特：在无噪声情况下，码元速率极限值B与信道带宽的关系：B&#x3D;2*W(Baud) ，一个数字脉冲的波形就是一个码元，波特就是单位时间传送的码元个数（码元&#x2F;秒），一个码元可以表示多位信息</p><p>奈奎斯特公式—-无噪信道传输能力公式：</p><p>C&#x3D;2 * W * log2N(bit&#x2F;s)</p><p>C是数据传输速率，W为信道的带宽，本题中W&#x3D;3KHz；</p><p>N为一个码元所取得离散值个数，本题中N&#x3D;16(4个相位，每个相位4中振幅)。</p><p>C&#x3D;2 * W * log2N&#x3D;2 * 3kHz * log216&#x3D;2 * 3k * 4&#x3D;24kbps;</p><p>香农公式是在带噪信道容量计算时使用的公式：</p><p>C&#x3D;W * log2(1+S&#x2F;N)(bit&#x2F;s)</p><p>S为信号功率，N为噪声功率，S&#x2F;N为信噪比；</p><p>信噪比(dB) &#x3D; 10 * log10(S&#x2F;N) (dB)</p><ol start="2"><li>若某通信链路的数据传输速率为2400bit&#x2F;s，采用 4 相位调制，则该链路的波特率是（ ）。</li></ol><ul><li>600 波特</li><li>1200 波特</li><li>4800 波特</li><li>9600 波特</li></ul><p>选B。<br>数据传送速率R，与波特率B之间的关系是：</p><p>                        <strong>R &#x3D; B*log</strong> <strong>2</strong> <strong>N</strong> <strong>，其中，N为进制数。</strong>  </p><p><strong>本题中，N &#x3D; 4，R &#x3D; 2400，所以B &#x3D; 1200</strong></p><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220402120729.png"></p><ol start="3"><li>若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传输速率，则信号状态数至少是</li></ol><ul><li>4</li><li>8</li><li>16</li><li>32</li></ul><p>2log2N&gt;&#x3D;log2(1001)</p><p>可用奈奎斯特采样定理计算无噪声情况下的极限数据传输速率，用香农第二定理计算有噪信道极限数据传输速率。2Wlog2N≥Wlog2(1+S&#x2F;N)，W是信道带宽，N是信号状态数，S&#x2F;N是信噪比，将数据带入计算可得N≥32，选D。分贝数&#x3D;10log10S&#x2F;N。</p><h2 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h2><p>568B线序：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕</p><p>568A线序：将568B中1&lt;-&gt;3、2&lt;-&gt;6互换</p><p>交叉线：一头568A一头568B</p><p>直通线：两头都是568B</p><p>反转线：一端568A，另一端将568A线序反过来</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/CaoRuiChen/p/12716598.html">www.cnblogs.com</a></p></blockquote><p><strong>数据链路层</strong>：</p><p>　　在物理层的传输过程中，会使数据出现一定的误差。引入了数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，来检测差错，从而向网络层提供高质量的数据传输服务。</p><p>　　<strong>数据链路层包含两个子层</strong></p><p>　　1.LLC 作为数据链路层的一个子层，使用 MAC 子层为其提供的服务，通过与对等实体 LLC 子层的交互为它的上层网络层提供服务。</p><p>　　LLC 包含可靠传输的方式，以及解决封装成帧，透明传送，差错控制。</p><p>　　2.MAC 子层是用来实现介质访问控制的网络实体。MAC 子层主要功能包括数据帧的封装 &#x2F; 拆封、帧的寻址与识别、帧的接收与发送、链路的管理、帧的差错控制及 MAC 协议的维护等。</p><p>　　MAC 子层包含：二层交换设备，以太网，CSMA&#x2F;CD。</p><p>数据在每次经过路由器的时候都会在数据链路层检测是否有差错。</p><p><img src="https://static.pil0txia.com/picgo/1996208-20200416224258894-1241589285.jpg" alt="1996208-20200416224258894-1241589285"></p><p>R 为路由器。</p><p>数据链路层解决的三个问题：<strong>封装成帧，透明传送，差错控制</strong></p><p><strong>概念：</strong></p><p><strong>1. 数据链路层的信道类型：</strong></p><p>　　1. 点对点信道：（一对一）两个设备一根线，从其中一个设备到另一个设备发送信息。</p><p>　　2. 广播信道：（一对多）一根信道上连有多个主机，每个主机都有可能收到信息，需要协议来协调发送。</p><p><strong>2. 链路与数据链路：</strong></p><p>　　1. 链路: 一条点到点的物理段，中间没有任何其他交换节点。</p><p>　　2. 数据链路：在链路上添加一定协议来传输数据，为数据链路。</p><p><strong>3. 帧：</strong></p><p>　　数据链路层在获得网络的发送来的数据包时，将数据封装，封装过后的新数据称为帧，其中封装了帧头，帧尾，来标记一个帧的开始和结尾，其中还含有物理层地址和校验和等信息。</p><p><img src="https://static.pil0txia.com/picgo/1996208-20200417214326173-1992069084.png"></p><p><strong>4. 解决封装成帧</strong></p><p>  封装成帧的目的是标记一个帧的开始与结束。其中有几种方法：</p><ol><li>字节计数法：每个帧头都添加一个字段，字段写当前这帧的长度是多少，很好理解，但是容易出错，一旦其中一个数据出错往后的数据全部出错。</li><li>字节填充的标志字节法：在帧头帧尾添加一个字节的标记（FLAG），从标记中就可以知道一个帧的长度，还解决了字节计数法的问题，当然这种方法也存在问题，当发送的数据里面存在我们的标记的时候，即这个表示是我们发送的数据在帧的中间，我们就会误认为帧在这里结束，解决方法类似与C语言的转移字符，如果是在数据中包含了标记（FLAG），就会在FLAG前面加上一个字节的转义符（ESC），当检测到FLAG的时候只用看见前面是否有ESC就可以了，同样若数据中出现了ESC就会在前面加ESC转义符。在数据被接收的时候就会去掉ESC来恢复原数据。里面还有很多情况比如数据中出现 ESC FLAG 的字段就转换成 ESC ESC ESC FLAG，第一个和第三个ESC便是加上的转义符。（缺点只适用与8比特（1字节）整数倍的数据，也就是只能在字节级别更改）</li><li>比特填充的标志比特法：在帧头帧尾添加一个特殊的比特串01111110作为帧标记来表示一个帧的开始与结束，当然数据中也会出现这样的比特串，解决的方法就是在数据中只要连续的出现了5个1就自动的在后面添加一个0，保证了不会有6个1连续的出现，举个例子当一个帧为01111110（头）011111000 （数据）01111110（尾），那么接收之后就会变为01111110（头）01111100 （数据）01111110（尾），去掉了在数据部分的5个连续的1后面的一个0。（优点是可以适用与任意比特的传输）。</li><li>物理层编码违禁法：将物理层中不会出现的编码（由编码规则而定）来作为帧界。（有点不会出现帧界的混淆）</li></ol><p><strong>5. 解决透明传输</strong></p><p>　　透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。也就是上面的出现了和标记信息一样的信息就采用填充法来解决和标记信息一样的比特流数据传输会出错的问题。</p><p><strong>6. 解决差错控制</strong></p><p>　　在传输过程中可能会出现比特差错即 0 变 1，1 变 0，差错控制使接收放只接收正确的数据，若数据不正确则不接收（只检错不纠错）。</p><p>　　<strong>常见的检错码</strong></p><p>　　1. 奇偶校验码：是一种通过增加冗余位使得码字中 “1” 的个数恒为奇数或偶数的编码方法，分为奇校验和偶校验。</p><p>　　　　　奇校验：当前比特串中含有奇数个 1，将冗余位置为 0，否则置为 1。</p><p>　　　　　偶校验：当前比特串中含有偶数个 1，将冗余位置为 0，否则置为 1。</p><p>　　　　　局限：检测到的出错的信息是可靠的，但并不能保证检测正确的是可靠的（多个突变，校验仍然可能是正确的）</p><p>　　2. 校验和：对数据中数据位进行计算求出来的放置在消息的末尾。</p><ol start="3"><li><p>循环冗余校验码（CRC 校验码)：CRC 校验也是在数据后放上校验码，校验码的个数会根据数据的个数大小变化。</p><p><strong>如何生成计算CRC校验码：</strong></p><p>　　　　　　1.几个概念</p><p>　　　　　　　　1.多项式：生成多项式也就是一个01串 设多项式G（x）&#x3D;X^3+X^2+1,我们可以看作G（x）&#x3D;1 *（X^3）+1 *（X^2）+0 *（X^1）+1 *（X^0），只保留X前系数得二进制码1101。</p><p>　　　　　　　　2.模二运算：可以理解为异或运算，其中0+0&#x3D;0，0+1&#x3D;1，1+0&#x3D;1，1+1&#x3D;0，记住的模二运算中加法没有进位，减法没有借位，也就是说1+1&#x3D;0不往后进位。</p><p>　　　　　　2.如何计算</p><p>　　　　　　　　1.约定共同的生成多项式：收发的双方首先在事前约定一个相同的多项式。（生成多项式是规定好的不需要我们去关心）</p><p>　　　　　　　　2.取生成多项式的二进制码位数r，在原数据位后添加r-1个零，得到新的数据n。</p><p>　　　　　　　　3.对新的数据n作为被除数，生成多项式作为除数，做模二除法，得到余数为y。</p><p>　　　　　　　　4.将新数据n和得到的余数y做模二减法，得到最终数据p（就是将末尾添加的r-1位零替换成余数y），发送数据p。</p><p>　　　　　　　3.接收检错</p><p>　　　　　　　　1.接收到的数据作为除数，生成多项式作为除数，做模二除法。</p><p>　　　　　　　　2.若余数为0，则数据无错，若有余数，则数据出错。</p></li></ol><p><strong>7. 流量控制与可靠传输</strong></p><p>　　<strong>1. 滑动窗口协议：</strong></p><p>　　　　<strong>1. 停止-等待协议（一位滑动窗口）</strong>：在接收方维护这一个希望接收的帧的一个窗口，每次发送方发送一个帧到接收方后，接收方会检测是不是自己需要的帧，若是则发送一个确认回去，若接收方没收到，一段时间以后（定时器超时），发送方没收到确认帧，则发送方重新发送刚刚发送的那个帧。这是一个停 - 等协议，发送方接收方需要等到上一个帧确认接收后才能发送下一个帧。在确认回传过程中，若定时器设置不合理会导致，发送方没有接收到确认时就定时器超时，这回导致一个信道中含有多个重复的帧，浪费资源。发送窗口的值 Ws&#x3D;1，接收窗口的值 Wr&#x3D;1。</p><p>　　　　<strong>2. 连续ARQ（go-back-N 回退N帧）</strong>：为了避免一位滑动窗口的问题，回退 N 帧协议可以一次性传多个帧也就是将滑动窗口从一位扩大到 n 位，我们在选取到合适的 n 的情况下，可以实现在发送完当前窗口的最后一帧时接收到当前窗口发送的第一帧的确认，这样窗口第一帧就确保了接收方的接收，滑动窗口向后滑动，继续发送新的帧。而回退 N 帧，则是代表在发送过程中发现其中一帧出问题了，但是已经发送了这个问题帧的后面的帧，那么要做的是就是从问题帧开始重新发送往后的所有帧。发送方要做的是在发送一个帧后启动这个帧的定时器，并且缓存这个帧待帧出现错误后重传，接收到确认之后滑动窗口，在接收方要做的是，一旦发现接收到的某一帧有问题或并未接受到，则后面接收到的数据帧全部丢弃。累积确认：如果接收端发送了对第n帧的确认，则代表从0到n-1号帧都已经正确收到。<code>后退N帧协议</code>的接收窗口为1，可以保证按序接收数据帧。若采用n个比特对帧编号，则期发送窗口的尺寸 Wt 应满足：**<code>1 &lt;= Wt &lt;= 2^n - 1</code>**。若发送窗口的尺寸大于2^n - 1，则会造成接收方无法分辨新帧和旧帧。若信道的传输质量很差导致误码率较大时，<code>后退N帧协议</code><strong>不一定优于</strong><code>停止等待协议</code>。</p><p>　　　　<strong>3. 选择性重传ARQ</strong>：回退 N 帧是重新发送问题帧以后的所有帧，而选择性重传则是只重新发送问题帧，在接收方，如果是没问题的帧就直接上交，如果是有问题的帧，便把之后收到的帧缓存取来直到接收到重传的那一帧，在完成排序后一起上交。这个协议中发送窗口需要进行约束，<code>选择重传协议</code>的接收窗口尺寸 Wr 和发送窗口尺寸 Wt 都大于1，一次可以发送或接收多个帧。若采用 n 比特对帧编号，为了保证接收方向向前移动窗口后，新窗口序号与旧窗口序号没有重叠部分，需要满足条件：<strong>接收窗口Wr + 发送窗口Wt &lt;&#x3D; 2^n</strong>。假定仍然采用累计确认的方法，并且接收窗口 Wr 显然不应超过发送窗口 Wt(否则无意义)，那么接收窗口尺寸不应超过序号范围的一半 **<code>Wr &lt;= 2^(n-1)</code><strong>。当接收窗口为最大值时，</strong><code>Wtmax = Wrmax = 2^(n-1)</code>**。<code>选择重传协议</code>可以避免重复传送那些本已正确到达接收端的数据帧，但在接收端要设置具有相当容量的缓冲区来暂存那些未按序正确收到的帧。接收端不能接收窗口以下或窗口上界以上的序号的帧，因此所需缓冲区的数目等于窗口的大小，而不是序号数目。</p><p><strong>8. 几个协议</strong></p><p>　　<strong>1.ppp 协议</strong>：在使用点对点数据通信（点对点通信就是两设备之间没有其他设备），PPP 协议拥有数据链路的基本功能即封装成帧，透明传送和差错控制，但不具备流量控制功能和可靠传输机制。</p><p><img src="https://static.pil0txia.com/picgo/image-20220914094106465.png" alt="image-20220914094106465"></p><p>其中首尾的 F（7E）是帧的开始和结束，首部的 A（FF）是地址（一般是固定的 因为点到点目的地址只有一个），C（03）控制字段，选择是没用的字段，都是一个字节长度。</p><p>协议字段（两个字节长）是</p><p>(1) 当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。 </p><p>(2) 当协议字段为 0xC021 时，PPP 帧的信息字段就是 PPP 链路控制协议 LCP 的数据。 </p><p>(3) 当协议字段为 0x8021 时，PPP 帧的信息字段就是网络层的控制数据。</p><p>尾部的 FCS 是帧检验序列。（1 个字节长）</p><p>解决透明传输：头尾的标记字段是 7E，若在数据出现 7E 则替换为 7D 5E(俩字节)，出现了 7D 则替换为 7D 5D. 也可以使用零比特填充的方法。</p><p> PPP 协议一般用于广域网。</p><p>　　<strong>2.ALOHA 协议</strong>（用于局域网，一条线路上链接有多个计算机）</p><p>   　　　　1. 纯 ALOHA 协议：每个站点可以在任意时间发送自己数据，极其的任性，很容易发送冲突，信道利用率最高达到 18.4% 很低。<br>            　　　　2. 分隙 ALOHA 协议：将时间分片，每一个时间片为分隙，每个发送方只能在时隙的开始发送，所以冲突只在时隙开始的发生，一旦一个帧占用了这个时隙，在这个时隙内就不会发生冲突了，计算出的信道利用率为可以达到 36.8%。</p><p>　　<strong>3. 带冲突检测的载波侦听多路访问协议（CSMA&#x2F;CD 协议）（同样用于局域网）：为了解决冲突问题（先听后发，边发边听）</strong></p><p>   　　　　1. 多点接入：一条线路上连接有多个计算机，如果同时发送数据就会发生冲突。<br>            　　　　2. 载波监听：会监听信道，如果信道是空闲的就会立马发送数据，如果是不是就会等待（先听后发）。<br>                        　　　　3. 碰撞检测：如果成功发送了数据除了被接收方完好无损的接收还会出现两种情况<br>           1. 两台计算机同时发送了数据，一定会碰撞。<br>           2. 一台计算机先发送了数据，由于传播时延，另一台计算机还没有监听到，于是也发送了数据，也会碰撞。那么在出现碰撞的情况下，发送方也会监听到（边发边听）（在自己发送过程中接收到了其他信号，就是碰撞），那么发送方会停止发送数据，并且发送一个拥塞信号并广播，告诉这条信道上的所有计算机出现了碰撞，等信道空闲之后，设定一个随机时间，等经过了这个随机时间之后在开始监听信道发送。</p><p>碰撞检测的检测时隙宽度要求等于两个最远计算机之间的传输时间（来回时间），可以在一个时隙内可以检测到最远距离的冲突。</p><p>发送有效帧的时间大于两个最远计算机之间的传输时间（来回时间），也就是说发送的时间要大于一个来回时间用来保证在能够发送时监听到最远距离发生的碰撞。</p><p>基本退避时间为争用期 2τ具体的争用期时间是 51.2μs（就是最远一来一回的时间）</p><p>最小帧长为 64 字节</p><p><img src="https://static.pil0txia.com/picgo/image-20220914094155675.png" alt="image-20220914094155675"></p><p><strong>9. 以太网概述</strong></p><p>　　以太网是当今现有局域网采用的最通用的通信协议标准。以太网提供的服务是不可靠服务，最大努力的交付，和无差错接收（只接受无差错的数据）。经典以太网中使用 CSMA&#x2F;CD 协议来保证使数据。以太网包含着 OSI 参考模型的最后两层。以太网处理的帧叫做以太帧。</p><p>　　IEEE802.3 协议规定了运行在各种介质上的 1M-10M 速度的 CSMA&#x2F;CD 协议的标准</p><p>　　　<strong>以太网帧格式</strong></p><p><img src="https://static.pil0txia.com/picgo/image-20220914094219602.png" alt="image-20220914094219602"></p><p>　　从左到右分别是前导码（7 Bytes）、帧起始定界符（1 Bytes）、目的 MAC 地址（6 Bytes）、源 MAC 地址（6 Bytes）、类型 &#x2F; 长度（2 Bytes）、数据和填充字段（48~1500 Bytes）、帧校验序列（4 Bytes）</p><p>　　<strong>MAC 地址：</strong>也称为局域网地址，物理地址，MAC 地址用于在网络中唯一标示一个网卡，每一个网卡都有一个 MAC 地址，并且是全球唯一的。</p><p>　　以太帧有很多种类型，常见的有<strong>以太 II 帧和 IEEE802.3 帧</strong>。其中如果是 IEEE802.3 帧帧起始定界符为 1 表示一个帧的开始，如果是以太 II 帧则是 0。第五个字段（长度 &#x2F; 类型字段）中 IEEE802.3 帧这个字段代表长度，而以太 II 帧代表数据的类型。</p><p> 以下是抓到的数据包。</p><p><img src="https://static.pil0txia.com/picgo/image-20220914094237036.png" alt="image-20220914094237036"></p><p> 其中 Frame 就是这个数据包的概述</p><p>而 Ethernet II 就是就是我们抓到的以太网 II 帧 查看一下</p><p><img src="https://static.pil0txia.com/picgo/image-20220914094252570.png" alt="image-20220914094252570"> </p><p>里面包含了目的 MAC 地址，源 MAC 地址，和数据类型是 IPV4。</p><p>而我们上面所看的帧头部（前 8 字节）和尾部校验和，在计算机收到这个数据包的时候就已经去掉了，剩下的数据部分就是下面的 Internet protocol 的网络层的内容了。</p><p><strong>10. 数据链路层设备</strong></p><p>　　<strong>1. 交换机，网桥：</strong>网桥用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p><p>　　　　网桥和交换机将两个相似的网络连接起来，并对网络数据的流通进行管理。设备将两个局域网连接在一起时，若两个网络的帧格式不同，网桥可以对他们重新封装变成合适的帧，也可以对帧进行缓存来适应不同的发送接收速度。</p><p>　　　　当帧到达网桥时，网桥都需要做出决策，是转发还是广播这个帧，在网桥中有个 MAC 表支持学习的功能，当某一帧到达网桥，他会解封帧，提取里面的数据首先记录这个帧的源 MAC 地址来自哪个端口将这一信息记录到 MAC 表中，在查找 MAC 表中是否含有对应的目的地址对应了端口，如果有则直接将帧转发到对应的端口，否则就广播这个帧，发送到已经连接的端口，还有一种情况在查找的表后发现数据送来的端口就是要转发的端口，那么网桥将会丢弃这个帧，因为这两计算机位于同一条信道上，源主机发送帧时，一条信道的上的所有计算机都可以接收到这个帧，网桥没必要转发一次了。</p><p>　　<strong>2. 网卡</strong></p><p>　　网卡提供 MAC 地址，数据的封装与解封，链路管理。网卡既是物理层的设备也是数据链路层的 MAC 子层的 d 设备。</p><p><strong>11. 生成树协议</strong></p><p>　　在连接多个局域网的时候，经常用不止一条线来连接，来保证可靠性，但是这样就很容易形成环结构，很有可能会让数据帧无线的在环上无限传输，形成网络风暴。也会让交换机在 MAC 地址表学习的时候会让学习的端口不稳定。为了避免这个问题，用生成树协议来使从一点到另一点的路径只有一条，将图转换为树。</p><p>　　原理：生成树协议工作原理: 任意一交换机中如果到达根网桥有两条或者两条以上的链路. 生成树协议都根据算法把其中一条切断, 仅保留一条. 从而保证任意两个交换机之间只有一条单一的活动链路. 因为这种生成的这种拓扑结构. 很像是以根交换机为树干的树形结构. 故为生成树协议。</p><p>　　当生成树中某些端口失效了 ，生成新的生成树。</p><p><strong>12. 虚拟局域网（VLAN）</strong></p><p>　　虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。</p><p>　　基于端口的 VLAN，在交换机内部有一个 VLAN 表，来标定哪些是虚拟局域网端口。</p><p>　　假如一台交换机上有一个 VLAN vlan 内包含 AB 两个主机 而 CD 两个主机是连在普通端口上。那么 C 发送的帧交换机要交付给 A 的时候是无法做到的，AB 是无法转发到的。只有 AB 是相互连通。他们在物理上是连通的但是在逻辑上是不通的。</p><p><strong>13. CSMA&#x2F;CA 协议</strong></p><p>接收信号强度往往会远远小于发送信号强度，如要在无线局域网的适配器上实现碰撞检测，对硬件的要求非常高。<br>即使够实现碰撞检测的功能，并且当发送数据时检测到信道是空闲的，在接收端仍然有可能发生碰撞（隐蔽站问题）<br>屏蔽站问题：<br>未能检测出媒体上已存在的信号的问题</p><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220506190919.png"><br>当 A 和 C 检测不到无线信号时，都以为信道是空闲的，因而都向 B 发送数据，结果发生碰撞。</p><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220506190902.png"></p><p>为了更好地解决隐蔽站带来的碰撞问题，802.11允许要发送数据的站对信道进行预约。具体的做法是这样的。A在向B发送数据帧之前，先发送一个短的控制帧，叫做请求发送RTS(Request To Send)，它包括源地址、目的地址和这次通信（包括相应的确认帧）所需的持续时间。当然，A在发送RTS帧之前，必须先监听信道。若信道空闲，则等待一段时间DIFS后，才能够发送RTS帧。若B正确收到A发来的RTS帧，且媒体空闲，则等待一段时间SIFS后，就向A发送一个叫做允许发送CTS(Clear To Send)的控制帧，它也包括这次通信所需的持续时间。A收到CTS帧后，再等待一段时间SIFS后，就可发送数据帧。若B正确收到了A发来的数据帧，在等待时间SIFS后，就向A发送确认帧ACK。</p><p>SIFS（短帧间间隔）：<br>最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站应当能够在这段时间内从发送方式切换到接收方式。<br>使用 SIFS 的帧类型有：<br>ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧，以及所有回答 AP 探询的帧和在 PCF 方式中接入点 AP 发送出的任何帧。</p><p>PIFS（点协调功能帧间间隔）：<br>比 SIFS 长，是为了在开始使用 PCF 方式时（在 PCF 方式下使用，没有争用）优先获得接入到媒体中。PIFS 的长度是 SIFS 加一个时隙(slot)长度。<br>时隙的长度的确定：<br>在一个基本服务集 BSS 内当某个站在一个时隙开始时接入到媒体时，那么在下一个时隙开始时，其他站就都能检测出信道已转变为忙态。</p><p>DIFS（分布协调功能帧间间隔（最长的 IFS））：<br>在 DCF 方式中用来发送数据帧和管理帧。DIFS 的长度比 PIFS 再增加一个时隙长度。</p><p>退避算法：<br><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220506190855.png"></p><p>为什么信道空闲还要再等待一段时间DIFS呢?就是考虑到可能有其他的站有一高优先级的帧要发送。如有，就要让高优先级帧先发送。    </p><p>现在假定没有高优先级帧要发送，因而源站发送了自己的数据帧。目的站若正确收到此帧，则经过时间间隔SIFS后，向源站发送确认帧ACK。若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间)，就必须重传此帧，直到收到确认为止，或者经过若千次的重传失败后放弃发送。    </p><p>由此可见，802.11无线局域网采用的停止等待协议，是一种可靠传输协议。发送力一必须等待对力一的确认帧。但802.3有线局域网的传输是不可靠的，发送方把数据发送出去就不管了(当然若检测到碰撞是必须重传的)，如果需要可靠传输则由高层负责。</p><p><strong>14. 信道划分的MAC协议：</strong></p><p>时间（TDMA）、频带（FDMA）、码片（CDMA）划分</p><p>随机访问MAC协议：</p><p>ALOHA,S-ALOHA,CSMA,CSMA&#x2F;CD（带冲突检测的载波监听多路访问），其中CSMA&#x2F;CD应用于以太网，CSMA&#x2F;CA应用于802.11无线局域网</p><p>轮转访问MAC协议：</p><p>主节点轮询；令牌传递</p><p>蓝牙、FDDI、令牌环网</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220512141553.png"></p><h2 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h2><ul><li><p><input checked="" disabled="" type="checkbox"> 选择题（30分），简答题（15分），计算题（25分），分析题（15分），应用题（15分）</p></li><li><p><input checked="" disabled="" type="checkbox"> 重要内容的梳理结合计算机网络课程大纲</p></li></ul><h3 id="课程目标1-1"><a href="#课程目标1-1" class="headerlink" title="课程目标1.1"></a>课程目标1.1</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 网络的概念和特点</p></li><li><p><input checked="" disabled="" type="checkbox"> 计算机网络的性能</p></li><li><p><input checked="" disabled="" type="checkbox"> 网络的结构：5层7层</p><p><a href="https://zhuanlan.zhihu.com/p/37384429">OSI七层模型与TCP&#x2F;IP五层模型 - 知乎</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 物理层，数据通信</p></li></ul><h3 id="课程目标1-2"><a href="#课程目标1-2" class="headerlink" title="课程目标1.2"></a>课程目标1.2</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 四种信道复用技术，码分多址，0、1</p><p><img src="https://img-blog.csdnimg.cn/20200908201951227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2thaV9sb2N1c3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p></li><li><p><input checked="" disabled="" type="checkbox"> 数据链路层，CRC</p><p><a href="https://blog.csdn.net/dwj_daiwenjie/article/details/108904665">数据链路层和传输层提供的可靠传输的区别_WenjieDai的博客-CSDN博客_数据链路层是可靠传输吗</a></p><p><a href="http://www.4k8k.xyz/article/weixin_43762820/108931357">关于数据链路层提供的可靠传输和传输层提供的可靠传输的区别_陈朔怡的博客-程序员资料_可靠传输和不可靠传输的区别 - 程序员资料</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 停止等待协议，ARQ</p></li><li><p><input checked="" disabled="" type="checkbox"> 滑动窗口协议，选择重传ARQ，3种ARQ，窗口大小，2^n，2^(n-1)</p></li><li><p><input checked="" disabled="" type="checkbox"> 802.11，CSMA&#x2F;CD</p></li><li><p><input checked="" disabled="" type="checkbox"> 网际层（重中之重，大题都在这），IP，字段的含义，重组</p></li><li><p><input checked="" disabled="" type="checkbox"> 互联网的两个路由选择协议，RIP</p><p>计算机网络基础（七）网络层——路由选择协议之RIP协议、OSPF协议和BGP协议-张柏沛IT博客<br><a href="https://www.zbpblog.com/blog-355.html">https://www.zbpblog.com/blog-355.html</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 第五章运输层，TCP的可靠传输协议、可靠传输控制（重中之重）、差错控制（检错码上面有），UDP</p><p><strong>TCP的可靠传输</strong></p><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p><p><strong>校验和：</strong>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p><p>TCP 的接收端会丢弃重复的数据。</p><p><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p><p><strong>拥塞控制：</strong>当网络拥塞时，减少数据的发送。</p><p><strong>ARQ协议：</strong>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p><strong>超时重传：</strong>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p><strong>产生确认的情况</strong></p><p>   1、当A端向B端发送数据报文段时，必须包含（捎带）一个确认，它给出A端期望接收的下一个序号。</p><p>​    2、当接收方没有数据要发送，但是收到了按序到达（序号是所期望的）的报文段，同时前一个报文段也已经确认过了，那么接收方就推迟发送确认报文段，直到另一个报文段到达，或经过了一段时间（通常是500ms）。</p><p>​    3、当具有所期望的序号的报文段到达，而前一个按序到达的报文段还没有被确认，那么接收方就要立即发送ACK报文段。</p><p>​    4、当序号比期望的序号还大的失序报文段到达时，接收方立即发送ACK报文段，并宣布下一个期望的报文段序号。这将导致对丢失报文段的快重传。</p><p>​    5、当一个丢失的报文段到达时，接收方要发送ACK报文段，并宣布下一个所期望的序号。</p><p>   6、如果到达一个重复的报文段，接收方丢弃该报文段，但是应当立即发送确认，指出下一个期望的报文段。 </p></li><li><p><input disabled="" type="checkbox"> 应用层不是很重要，域名系统DNS，FTP，WWW，SMTP&#x2F;POP3，对应课程目标1.2、2.1</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成与系统结构笔记</title>
      <link href="/post/2022-03-17_Computer-Organization-and-Architecture-notes/"/>
      <url>/post/2022-03-17_Computer-Organization-and-Architecture-notes/</url>
      
        <content type="html"><![CDATA[<p>原反补：</p><h3 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h3><ul><li><p>原码&#x3D;反码&#x3D;补码</p></li><li><p>移码&#x3D;补码符号位取反，数值位不变</p></li></ul><h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><ul><li><p>反码&#x3D;原码符号位不变，数值位取反</p></li><li><p>补码&#x3D;反码末位加1</p></li><li><p>移码&#x3D;补码符号位取反，数值位不变</p></li></ul><h2 id="考试重点："><a href="#考试重点：" class="headerlink" title="考试重点："></a>考试重点：</h2><h3 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a>第二章：</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 原反补、浮点的表示方式</p><p><a href="https://blog.csdn.net/LEoe_/article/details/79096568">计算机组成原理-原码, 反码和补码_leoe_的博客-CSDN博客_计算机组成原理补码怎么算</a></p><p><a href="https://blog.csdn.net/swadian2008/article/details/111225215">计算机组成原理12-数的定点表示和浮点表示_swadian2008的博客-CSDN博客_数的定点表示和浮点表示</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 补码、浮点的加法运算</p><p><a href="https://blog.csdn.net/weixin_43217942/article/details/104855040">【计算机组成原理】补码加减法和溢出检测_Elltor的博客-CSDN博客_变形补码相加结果溢出后怎么计算 </a></p><p><a href="https://blog.csdn.net/superzhang6666/article/details/122199436">计算机中的取模运算与补码_senda66的博客-CSDN博客_0的取模运算</a></p></li></ul><h3 id="第三章-存储器："><a href="#第三章-存储器：" class="headerlink" title="第三章 存储器："></a>第三章 存储器：</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 材料不同、级别不同-&gt;存储器的分类、分级-&gt;级别一般按存取速度分类</p></li><li><p><input checked="" disabled="" type="checkbox"> 主存的技术指标（哪个好哪个坏）</p></li><li><p><input checked="" disabled="" type="checkbox"> 虚拟存储器-&gt;统一编址-&gt;页式段式段页式</p><p><a href="http://kaito-kidd.com/2018/09/06/computer-system-virtual-memory/">计算机系统基础（八）虚拟存储器 | Kaito’s Blog</a></p></li><li><p><input checked="" disabled="" type="checkbox"> cache高速缓冲存储器-&gt;数据的替换-&gt;命中率</p></li><li><p><input checked="" disabled="" type="checkbox"> cache和虚拟存储器的共同点：都弥补了一个速度差</p><p><a href="https://blog.csdn.net/bigbaojian/article/details/104070202">简单描述虚拟存储器和cache的异同。_cccrick的博客-CSDN博客_cache和虚拟存储器的异同</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 虚地址、实地址</p></li></ul><h3 id="第四章-指令系统："><a href="#第四章-指令系统：" class="headerlink" title="第四章 指令系统："></a>第四章 指令系统：</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 指令的类型</p></li><li><p><input checked="" disabled="" type="checkbox"> 指令系统是机器指令的集合</p></li><li><p><input checked="" disabled="" type="checkbox"> 一条机器指令包含多条微指令</p></li><li><p><input checked="" disabled="" type="checkbox"> 指令的格式：操作码+地址码</p></li><li><p><input checked="" disabled="" type="checkbox"> 操作数的九种寻址：立即寻址、直接寻址、间接寻址等</p><p><a href="https://zhuanlan.zhihu.com/p/266763376">计算机组成原理学习笔记：四 指令系统 - 知乎</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 指令周期、机器周期&#x2F;CPU周期（定义：访问一次内存）、时钟周期</p></li><li><p><input checked="" disabled="" type="checkbox"> 指令的分类：非访问内存的指令（包含两个机器周期，第一个周期内取址、译码）、一次访问内存的指令等</p></li><li><p><input checked="" disabled="" type="checkbox"> 对指令系统的要求：完备性、规整性、有效性、兼容性、可拓展性</p></li><li><p><input checked="" disabled="" type="checkbox"> 根据存放操作数的物理类型来划分：存储器、寄存器等</p></li></ul><h3 id="第五章-CPU（运算器、控制器）："><a href="#第五章-CPU（运算器、控制器）：" class="headerlink" title="第五章 CPU（运算器、控制器）："></a>第五章 CPU（运算器、控制器）：</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 运算器、控制器分别包含哪些寄存器及其作用-&gt;工作流程</p></li><li><p><input checked="" disabled="" type="checkbox"> 程序计数器是寄存器</p></li><li><p><input checked="" disabled="" type="checkbox"> 数据通路：寄存器与寄存器之间的（用的时候临时铺设，与用不用都在那的IO总线&#x2F;系统总线不同）</p></li><li><p><input checked="" disabled="" type="checkbox"> 微程序设计技术的基本概念：微操作、微命令、微指令、微程序、如何减小长度、如何缩小容量、如何提高执行速度</p><p><a href="https://blog.csdn.net/Aloneingchild/article/details/108182060">【计算机组成原理】微命令 微指令 微操作 微程序_Anadem的博客-CSDN博客_微指令微命令微操作微程序</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 时序产生器的作用：指令的执行按照严格的时序信号进行</p></li><li><p><input checked="" disabled="" type="checkbox"> 怎么判断CPU取过来的是指令还是操作数：时间上，从整个指令周期的第一个机器周期取过来的是指令本身，不是操作数；空间上，如果取过来的是指令本身，会放到指令寄存器，如果是操作数，会放到数据寄存器。</p></li><li><p><input checked="" disabled="" type="checkbox"> 8088并行的工作方式、串行的工作方式和流水线的工作方式的比较</p><p><a href="https://zhuanlan.zhihu.com/p/72755052">挑战408——组成原理（26）——指令流水线 - 知乎</a></p></li></ul><h3 id="第六章-总线系统"><a href="#第六章-总线系统" class="headerlink" title="第六章 总线系统"></a>第六章 总线系统</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 分类：<strong>内部总线</strong>（同一计算机内）、<strong>系统总线</strong>（同一计算机内各部件）、<em>多机系统总线（多计算机）、片内总线（同一部件内）</em>、IO总线</p></li><li><p><input checked="" disabled="" type="checkbox"> 按传输数据分类：数据总线、地址总线、控制总线</p></li><li><p><input checked="" disabled="" type="checkbox"> 按连接方式分类：单总线、双总线、三总线</p><p><a href="https://blog.csdn.net/starter_____/article/details/99444549">总线 —— 总线的分类和系统总线结构_starter_zheng的博客-CSDN博客_双总线结构</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 把外部设备和内存统一编址。单总线的缺点：外部设备和内存挂到同一系统总线上进行统一编址，外部设备会占用一部分内存；双总线在单总线基础上增加了一条内存总线，连接CPU和内存，内存的容量不受外部设备影响；三总线增加了一条IO总线，连接系统总线和IO设备的接口</p></li></ul><h3 id="第七章-中断"><a href="#第七章-中断" class="headerlink" title="第七章 中断"></a>第七章 中断</h3><ul><li><input checked="" disabled="" type="checkbox"> 背景：如果没有中断，CPU以<strong>程序查询的方式</strong>等待外部设备准备好才能进行数据传输</li><li><input checked="" disabled="" type="checkbox"> CPU处理中断的不同方式：单级中断请求、多级中断请求（嵌套）</li><li><input checked="" disabled="" type="checkbox"> DMA：IO设备和内存直接进行数据传输，不经过CPU，但CPU需要让出一个或多个机器周期给他们进行数据传输</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phigros 存档跨版本转移</title>
      <link href="/post/2022-03-12_phigros-merge-save/"/>
      <url>/post/2022-03-12_phigros-merge-save/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://www.bilibili.com/read/cv13597100">www.bilibili.com</a></p></blockquote><blockquote><p>2021&#x2F;10&#x2F;28 更新：截至 2021&#x2F;10&#x2F;27，Phigros 已在 Google Play Store 重新上架且已经更新至 v2.0.0，故删除原标题中的 “从 GooglePlay 到 TapTap”；但此教程依然适用于需要跨版本转移存档的玩家 (共存版亦可转移存档，但需要改成对应的共存版包名)。</p></blockquote><p><img src="https://static.pil0txia.com/picgo/image-20221018112727852.png"></p><p>Phigros 官方：Phigros 2.0.0 版本将于 2021.10.22 更新！</p><p>lchzh：我用的还是 GooglePlay 版的 1.6.9 版本怎么办？</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113031187.png"></p><p>GooglePlay 似乎无法更新…</p><p>然后 lchzh 试图直接安装 TapTap 的 1.6.11，结果如图：</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113128915.png"></p><p>但如果重新安装，我存档就没了啊啊啊</p><p>于是 lchzh 在官群找到了一篇来自 b 站专栏的教程：</p><p><img src="https://static.pil0txia.com/picgo/image-20221018115303791.png" alt="image-20221018115303791">万能的群友们</p><p>于是照做，但由于<strong>前后版本不一致</strong>在最后的恢复阶段以失败告终…</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113208862.png" alt="image-20221018113208862"></p><p>&#x2F;&#x2F; 话说我转移存档的需求是<strong>在相同手机的不同版本之间</strong>转移，并不是<strong>在不同手机之间</strong>转移，原来一开始就用不了 qwq  </p><p><img src="https://static.pil0txia.com/picgo/image-20221018113240219.png"></p><p>望着生成的 ab 文件陷入了思考</p><p>然而经过一个下午加半个晚上的搜索，lchzh 最终找到了跨版本还原 ab 文件的方法！</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113301731.png" alt="Phigros 1.6.9 Google Play 版 个人页截图留念"></p><p>&#x2F;&#x2F; 适用于大部分 Android 手机以及 Win10 系统的电脑</p><p>&#x2F;&#x2F; 包含的一些链接在部分地区可能需要科学上网</p><p>首先在手机上操作：</p><p>进入 “设置 | 关于手机”，多次点击“软件版本号” 直至进入开发者模式</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113321413.png" alt="image-20221018113321413"></p><p>不同手机的文案可能存在差异，下同</p><p>此时 “设置” 界面应该会多出来“开发者选项”，找到并打开“USB 调试”</p><p><img src="https://static.pil0txia.com/picgo/image-20221018115326077.png"></p><p><strong>将手机用数据线连接至电脑：</strong></p><p>下拉通知栏，若出现选择 “仅充电 | 传输照片 | 管理文件”，请选择 “管理文件”</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113336259.png">  </p><p>若弹出消息框 “允许 USB 调试吗？”，请选择 “确定”  </p><p><img src="https://static.pil0txia.com/picgo/image-20221018113348220.png"></p><p><strong>接下来在电脑上操作：</strong></p><p>下载 <a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a> 并解压其中的 platform-tools 文件夹</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113400993.png"></p><p>在 platform-tools 文件夹的资源管理器界面地址栏输入 cmd 然后按 Enter(回车)</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113410995.png"></p><p>在弹出的窗口输入以下命令然后回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>若出现：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">[设备序列号] device</span><br></pre></td></tr></table></figure><p>即为成功连接手机 (若啥也没有或出现 unauthorized 则需在手机端重新允许 USB 调试)</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113422242.png"></p><p>在手机上运行 Phigros，输入以下命令然后回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb backup -f phi.ab -noapk -noshared -nosystem com.PigeonGames.Phigros</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/image-20221018113435047.png"></p><p>然后在手机端确认 (不要输入密码)  </p><p><img src="https://static.pil0txia.com/picgo/image-20221018113447425.png"></p><p>备份完成后当前文件夹应该会多一个名为 phi.ab 的文件 (大小约 7-9MB)</p><p>&#x2F;&#x2F; 部分手机可能需要<strong>在备份时运行 Phigros</strong> 才能备份成功，否则会产生 0-1KB 的无效文件</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113458091.png">这就是你的 Phigros 存档了!</p><p>在确认备份文件大小无误后就能卸载 Phigros 旧版本并且安装新版本了！</p><p>&#x2F;&#x2F; 原教程的分歧点</p><p>我们打开新安装的 Phigros 并游玩一遍新手教程 (使本地存档更新)</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113511128.png" alt="lchzh 菜"></p><p>然后电脑端输入以下命令然后回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb backup -f phi-.ab -noapk -noshared -nosystem com.PigeonGames.Phigros</span><br></pre></td></tr></table></figure><p><img src="https://static.pil0txia.com/picgo/image-20221018113523970.png"></p><p>在手机端确认 (不要输入密码)</p><p>于是我们获得了新旧两个版本的 ab 文件，其中 phi.ab 包含旧存档，phi-.ab 为新版本存档</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113541120.png"></p><p>注意到 ab 文件其实是经过处理的 tar 压缩文件，我们使用 abe 工具来解压并修改存档：  </p><p>&#x2F;&#x2F; 该工具依赖 Java11 + 环境，请自行安装 Java</p><p>访问 <a href="https://github.com/nelenkov/android-backup-extractor/releases/latest">https://github.com/nelenkov/android-backup-extractor/releases/latest</a></p><p><img src="https://static.pil0txia.com/picgo/image-20221018113552877.png"></p><p>点击页面内的 abe.jar 并下载到 platform-tools 文件夹</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113616094.png"></p><p><strong>逐行输入以下代码并回车：</strong></p><ol><li>调用 abe.jar，将 ab 文件转换成计算机能直接读写的 tar 文件：</li></ol><p>（效果：生成了 phi.tar 和 phi-.tar 两个文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abe.jar unpack phi.ab phi.tar</span><br><span class="line">abe.jar unpack phi-.ab phi-.tar</span><br></pre></td></tr></table></figure><p>如果在建構ab檔的時候輸入了密碼的話，在轉換tar檔的時候要輸入以下指令：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar abe.jar unpack phi.ab phi.tar PASSWD</span><br></pre></td></tr></table></figure><ol start="2"><li>解压 phi.tar，生成 apps 目录，释放其中的存档文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf phi.tar</span><br></pre></td></tr></table></figure><ol start="3"><li>用 apps 目录里的存档文件覆写 phi-.tar，实现存档从旧版本到新版本转移</li></ol><p>（存档文件即 apps&#x2F;com.PigeonGames.Phigros&#x2F;sp&#x2F;<strong>com.PigeonGames.Phigros.v2.playerprefs.xml</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rf phi-.tar apps/com.PigeonGames.Phigros/sp/com.PigeonGames.Phigros.v2.playerprefs.xml</span><br></pre></td></tr></table></figure><p>4. 调用 abe.jar，将 phi-.tar 转换成 phi–.ab：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abe.jar pack phi-.tar phi--.ab</span><br></pre></td></tr></table></figure><ol start="5"><li>最后将 phi–.ab 恢复到手机上：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore phi--.ab</span><br></pre></td></tr></table></figure><p>在手机上确认：</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113630566.png"><br><img src="https://static.pil0txia.com/picgo/image-20221018113644341.png"></p><p>恢复结束，成功实现了 Phigros 存档跨版本转移！</p><p><img src="https://static.pil0txia.com/picgo/image-20221018113656659.png" alt="Phigros 1.6.11 TapTap 版 个人页截图"></p><p><img src="https://static.pil0txia.com/picgo/image-20221018112727852.png"></p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迁移 </tag>
            
            <tag> phigros </tag>
            
            <tag> 音游 </tag>
            
            <tag> 存档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统笔记</title>
      <link href="/post/2022-02-21_DBMS-notes/"/>
      <url>/post/2022-02-21_DBMS-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h2><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.51cto.com/article/279952.html">www.51cto.com</a></p></blockquote><blockquote><p>本文我们主要介绍数据库的三级模式：外模式、模式和内模式的一些知识，希望能够对您有所帮助。</p></blockquote><p>对于<strong>数据库</strong>的三级模式和两级映射，可能我们并不陌生。三级模式指的是<strong>外模式</strong>、<strong>模式</strong>和<strong>内模式</strong>。两级映射指的是外模式 - 模式和模式 - 内模式。本文我们主要介绍一下数据库的三级模式的一些知识，希望能够对您有所帮助。</p><p> <strong>一、模式（Schema）</strong></p><p>定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><p>理解： ① 一个数据库只有一个模式； ② 是数据库数据在逻辑级上的视图； ③ 数据库模式以某一种数据模型为基础； ④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p><p> <strong>二、外模式（External Schema）</strong></p><p>定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p><p>理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。</p><p> <strong>三、内模式（Internal Schema）</strong></p><p>定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照 B 树结构存储还是按 hash 方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。</p><p>理解： ① 一个数据库只有一个内模式； ② 一个表可能由多个文件组成，如：数据文件、索引文件。 它是数据库管理系统 (DBMS) 对数据库中数据进行有效组织和管理的方法 其目的有： ① 为了减少数据冗余，实现数据共享； ② 为了提高存取效率，改善性能。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.zhihu.com/question/38737183">www.zhihu.com</a></p></blockquote><blockquote><p>这张图表示数据库管理系统（DBMS）从三个层次来管理数据：外部层次（External Level）、<a href="https://www.zhihu.com/search?q=%E6%A6%82%E5%BF%B5%E5%B1%82%E6%AC%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">概念层次</a>（Conceptual Level）和<a href="https://www.zhihu.com/search?q=%E5%86%85%E9%83%A8%E5%B1%82%E6%AC%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">内部层次</a>（Internal Level）。其中外部层次的数据是用户所看到的数据，所以又叫『用户』层次；概念层次的数据是 DBMS 中全局管理（可以简单地理解为所有的）数据，及数据之间的约束，所以又叫『逻辑』层次；内部层次的数据是存储在介质上的数据，包括存储路径、存储方式、索引方式等，所以又叫『物理』层次。</p><p>而『模式』，就是『对于数据的结构性描述』，所以对于不同层次的数据，就对应着不同层次的模式，分别是：外模式（<a href="https://www.zhihu.com/search?q=%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">用户模式</a>）、模式（概念模式 &#x2F; <a href="https://www.zhihu.com/search?q=%E9%80%BB%E8%BE%91%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">逻辑模式</a>）与内模式（物理模式）。</p><p>在一个数据库系统中，『模式』与『内模式』都只能有一个，但『外模式』可以有很多个。原因是『模式』是对 DBMS 中所有数据的全局性的结构描述，所以只能有一种形式。举个例子：一个学校的数据库中要存放所有学生、课程与选课记录的信息。我们可以用三张表：学生信息表、课程信息表与选课记录表来存放所有的数据。但是存放学生的数据的时候，我们只能够选取某一种特定的结构对学生的信息进行描述，而不能多种不同的结构共存（比如两张不同结构的学生表，存放的都是所有学生的信息）。所以『模式』只能有一个。同样，我们在介质上存放数据的时候，也只能选取某一种特定的存储路径（数据文件在哪个文件夹下）、存储方式（二进制 &#x2F; 文本）、索引方式（聚簇索引，普通索引）等等，可以理解为一种数据结构，和具体的计算机语言没什么关系，也不能够像程序一样执行。</p><p>至于『外模式』，是以『视图』的形式展现给用户的，所以我猜你对于外模式理解错误的原因，就是理解错误了『视图』的概念。这里的『视图』不是我们平时说的 UI ，而是指数据库中的视图，又叫『虚表』，是相对于『基本表』来说的。这里的『基本表』指的就是我们在建立数据库的时候需要创建的那些数据表（用 CREATE TABLE 创建出来的），而视图，是对这些基本表中的数据的某种展现形式，是这些数据的一个子集，但不限于某张表中的数据的子集，也可以是多张表联合起来进行显示的一组数据。比如在一个学校的<a href="https://www.zhihu.com/search?q=%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">教务系统</a>中，我们希望每个学生只能够看到自己的成绩，普通老师可以看到他 &#x2F; 她教的学生的成绩，系主任可以看到这个系中所有学生的成绩，校长可以看到学校中每个学生的成绩。那么我们可以基于所有学生的成绩数据，针对于不同权限的用户选取不同的子集，这个子集就是所谓的『视图』。但需要注意的是，『视图』本身并不『实际』存放数据，而只是对于如何选取数据的一种描述，这也是所谓的『虚』。当<a href="https://www.zhihu.com/search?q=%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:93294527%7D">全局数据</a>改变的时候，视图中的数据也会随之改变。通过外模式，可以让不同的用户（包括应用程序）看到他们希望看到的（比如可以同时看到学生本人的信息及他 &#x2F; 她的所有成绩与对应的课程的信息，而这些数据实际上是分别存在于不同的数据表中的），或是我们希望他们看到的数据（通过不同的子集来实现）。</p><p>总而言之，三种层次的模式都是对于数据的描述，只不过描述的层次不同。</p></blockquote><h2 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h2><h3 id="简明总结1"><a href="#简明总结1" class="headerlink" title="简明总结1"></a>简明总结1</h3><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/zhydream77/article/details/80381898">blog.csdn.net</a></p></blockquote><p><strong>数据库系统的三级模式</strong>：外模式、模式、内模式。</p><p><strong>模式（逻辑模式、概念模式）：</strong>实际上是数据库数据在逻辑级上的视图。描述的是全局逻辑结构。一个数据库只要一个模式。模式是数据库的中心与关键，它独立与其他层次。设计数据库模式结构时应首先确定数据库的逻辑模式。DBMS 提供模式描述性语言来严格定义模式。</p><p><strong>外模式（子模式、用户模式）：</strong>数据库用户能够看见和使用的局部数据的逻辑结构和特征，是数据库用户的数据视图。描述的是局部逻辑结构。是模式的一个子集。一个数据库可以有多个数据库内模式。每个用户只能看见和访问对应的外模式中的数据，数据库中的其余数据是不可见的。是保证数据库安全性的有力措施。同一外模式也可以为用户的多个应用程序使用，但一个应用程序只能使用一个外模式。它定义在逻辑模式之上，但独立于存储模式和存储设备。当应用需求发生较大变化，相应外模式不能满足其视图要求，该外模式就应该做出相应的改变。设计外模式的时候应充分考虑到应用的扩展性。DBMS 提供子模式描述性语言来严格定义子模式。</p><p><strong>内模式（存储模式）：</strong>一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据库内部的表示方法。比如记录什么存储方法存储，索引按照什么方式组织。数据是否压缩存储，是否加密。数据库存储记录结构有何规定。它依赖于全局逻辑结构，但独立于数据库的用户视图和存储设备。它将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以实现达到较好的时间与空间效率的目的。DBMS 提供内模式描述性语言来严格定义内模式。</p><p><img src="https://img-blog.csdn.net/2018052013580056"></p><p><strong>二级映像：</strong></p><p><strong>外模式 &#x2F; 模式映像：</strong></p><p>数据库系统都有一个外模式 &#x2F; 模式映像。它定义了该外模式与模式之间的对应关系。这些映像通常包含在各自外模式的描述中。当模式改变时（增加新的关系、新的属性、改变属性的数据类型），需要数据库管理员对各个外模式 &#x2F; 模式的映像做相应改变，也可以是外模式保持不变。应用程式是依据数据的外模式编写的。因此应用程序也不必修改，这保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p><p><strong>模式 &#x2F; 内模式映像：</strong></p><p>模式 &#x2F; 内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。比如说明逻辑记录和字段在内部是如何表示。该映像定义通常包含在模式描述中。当数据库的存储结构改变时，由数据库管理员对模式 &#x2F; 内模式映像做相应改变。可以使模式保持不变，因此应用程序也不必改变，这就保证了数据与程序的物理独立性，简称数据的物理独立性。</p><h3 id="简明总结2"><a href="#简明总结2" class="headerlink" title="简明总结2"></a>简明总结2</h3><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://cloud.tencent.com/developer/article/1815235">cloud.tencent.com</a></p></blockquote><p>　<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>的模式（Schema）是对现实世界的抽象，是对数据库中全部数据的逻辑结构和特征的描述。模式反映的是数据的结果及其联系，数据库系统在其内部具有三级模式和二级映像。三级模式分别是外模式、模式和内模式，二级映像则是外模式 &#x2F; 模式映像、模式 &#x2F; 内模式映像。</p><p>　　#### 三级模式</p><p>　　（1）<strong>模式</strong></p><p>　　模式对应着<strong>概念级</strong>，它是由数据库设计者总和所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图。它是由数据库管理系统提供的数据模式描述语言（Date Description Language，DDL）来描述、定义的，体现并反映了数据库系统的整体观。</p><p>　　（2）<strong>外模式</strong></p><p>　　外模式对应于用户级，它是某个或某几个用户看到的数据库的数据视图，是与某一应用有关的数据逻辑的表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、、定义对应于用户的数据记录（外模式），也可以利用数据操纵语言（DML）对这些数据记录进行操作。</p><p>　　（3）<strong>内模式</strong></p><p>　　内模式对应于<strong>物理级</strong>，它是数据库中全部数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上存储方式的物理结构，对应着实际存储在外存储介质上的数据库。</p><p>　　#### 二级映像</p><p>　　数据库系统的三级模式是对数据的 3 个抽象，它把数据的具体组织留给 DBMS 管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示和存储。为了能够在内部实现着 3 个抽象层次的练习和转换，DBMS 在这 3 个级别之间提供了两层映像：外模式 &#x2F; 模式映像 和 模式 &#x2F; 内模式映像。</p><p>　　外模式 &#x2F; 模式映像 使数据具有较高的逻辑独立性。它定义了外模式和模式之间的对应关系。这些映像定义通常包含在各自外模式的描述。当模式改变时，DBA 要求相关的外模式 &#x2F; 模式映像做相应的改变，以使外模式保持不变。应用程序是依据实际的外模式编写的，外模式不变应用程序就没必要修改。所以，外模式 &#x2F; 模式映像 功能保证了数据与程序的逻辑独立性。</p><p>　　模式 &#x2F; 内模式映像使数据具有较高的物理独立性。它定义了数据库全局逻辑结构与存储结构之间的对应关系。该映像定义通常包含在模式描述中。当数据库的存储结束了，DBA 要对模式 &#x2F; 内模式映像做相应的改变，以使模式保持不变。模式不变，与模式没有直接联系的应用程序也不会改变。所以，模式 &#x2F; 内模式映像功能保证了数据与程序的物理独立性。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><img src="https://static.pil0txia.com/picgo/Pasted%20image%2020220228114441.png"></p><p><img src="https://static.pil0txia.com/picgo/QQ%E5%9B%BE%E7%89%8720220228114613.jpg"></p><p><img src="https://static.pil0txia.com/picgo/QQ%E5%9B%BE%E7%89%8720220228114648.jpg"></p><p><img src="https://static.pil0txia.com/picgo/QQ%E5%9B%BE%E7%89%8720220228114653.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科CS课程笔记 </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 数据库系统 </tag>
            
            <tag> DBMS </tag>
            
            <tag> 模式 </tag>
            
            <tag> 映像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C1科目三笔记</title>
      <link href="/post/2021-08-27_subject-3-notes/"/>
      <url>/post/2021-08-27_subject-3-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><ul><li>除直线行驶外，全程档位为三档或更小，速度控制在20到30码之间。</li><li>最高转速为2000转每分钟，1500转左右即可换挡。</li><li>减速踩刹车，停车踩离合和刹车。只要还在档位里，不踩离合减速会导致熄火。</li><li>停车后踩住离合和刹车，挂一档。</li><li>转向灯打满三秒后才可转向。</li><li>一号线、三号线起步需要向左变道，二号线考试时起步直行无需变道（练习时前方有车需要变道再变回来）。</li></ul><h2 id="夜间灯光"><a href="#夜间灯光" class="headerlink" title="夜间灯光"></a>夜间灯光</h2><p><img src="https://static.pil0txia.com/picgo/mmexport1631593032335.jpg"></p><h2 id="一号线"><a href="#一号线" class="headerlink" title="一号线"></a>一号线</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>踩离合刹车，挂一档，放手刹，打左转向灯，按喇叭，观察后方来车。</p><p>起步方式与半坡起步一样，车身开始抖动后，松刹车，保持离合器位置。行驶平稳后松离合踩油门。</p><h3 id="超车"><a href="#超车" class="headerlink" title="超车"></a>超车</h3><p>可以看到前方车打左转向灯后，提前打转向灯，并一直保留到路口左转结束。</p><h3 id="会车"><a href="#会车" class="headerlink" title="会车"></a>会车</h3><p>什么都不需要做。</p><h3 id="前方路口左转"><a href="#前方路口左转" class="headerlink" title="前方路口左转"></a>前方路口左转</h3><p>左转后先靠左侧车道行驶，随后自行打右转向灯，变道到右侧车道。</p><h3 id="前方路口掉头"><a href="#前方路口掉头" class="headerlink" title="前方路口掉头"></a>前方路口掉头</h3><p>在白线前停车，挂一档，方向盘打死。掉头后靠左侧车道行驶。</p><h3 id="变更车道"><a href="#变更车道" class="headerlink" title="变更车道"></a>变更车道</h3><p>可提前打右转向灯。变更车道后，保留右转向灯，及时进入右转向车道。</p><h3 id="前方路口右转"><a href="#前方路口右转" class="headerlink" title="前方路口右转"></a>前方路口右转</h3><p>过了斑马线后再打方向，靠右侧车道行驶。</p><h3 id="直线行驶"><a href="#直线行驶" class="headerlink" title="直线行驶"></a>直线行驶</h3><p>右转完成后，可提前打右转向灯。直行看到地上三道白线，加速到35码。过了三道白线后，挂四档，加速到40码保持。</p><h3 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h3><p>直线行驶完成后，（打右转向灯），踩离合刹车，停车（不用向路边靠，容易压线）。挂一档，用纸片和方向盘中间括住地上白线（不可压着离合对线，作45度小幅度调整），停车，关转向灯，挂空挡，拉手刹，松离合刹车，熄火，解开安全带，观察后方来车，下车，关门。</p><h2 id="二号线"><a href="#二号线" class="headerlink" title="二号线"></a>二号线</h2><h3 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h3><p>起步直行，无需变道，练习时前方有车需要变道再变回来。靠右侧行驶，若前方有掉头的教练车，考试时跟在后面一个个走，练习时向左变道，再立即及时变回来。</p><h3 id="前方路口右转-1"><a href="#前方路口右转-1" class="headerlink" title="前方路口右转"></a>前方路口右转</h3><p>打右转向灯。若前方有教练车，在白线前停车，等待对方完成右转后再右转，避免对方熄火使自己路口停车。右转后靠左侧车道行驶。</p><h3 id="会车-1"><a href="#会车-1" class="headerlink" title="会车"></a>会车</h3><p>注意下坡松油门避免超速。上坡加油门。</p><h3 id="超车-1"><a href="#超车-1" class="headerlink" title="超车"></a>超车</h3><p>只需开启左转向灯，无需变道。保留左转向灯到掉头完成。</p><h3 id="前方路口掉头-1"><a href="#前方路口掉头-1" class="headerlink" title="前方路口掉头"></a>前方路口掉头</h3><p>车头盖到白线停车。方向盘向左打90度，进入左转弯车道。再次打左转向灯，随后掉头，进入左侧车道。</p><h3 id="直线行驶-1"><a href="#直线行驶-1" class="headerlink" title="直线行驶"></a>直线行驶</h3><p>下坡上坡控制好车速。加速方式和标记与一号线一致。直线行驶完成后松开油门，等速度低于30码时挂三档，维持速度。</p><h3 id="前方路口左转-1"><a href="#前方路口左转-1" class="headerlink" title="前方路口左转"></a>前方路口左转</h3><p>直线行驶完成后，打左转向灯，左转后靠左侧车道行驶。注意观察对向车道无社会车辆。</p><h3 id="变更车道-1"><a href="#变更车道-1" class="headerlink" title="变更车道"></a>变更车道</h3><p>左转完成后，打右转向灯，靠右侧车道行驶。</p><h3 id="靠边停车-1"><a href="#靠边停车-1" class="headerlink" title="靠边停车"></a>靠边停车</h3><p>看到写着蓝色“靠边”字样的路灯杆时，在下一个路灯杆处停车。挂一档，对线，听到“请靠边停车”的语音播报后再停车（考试时报得会比练习时晚一点），接下来同一号线。</p><h2 id="三号线"><a href="#三号线" class="headerlink" title="三号线"></a>三号线</h2><h3 id="起步-2"><a href="#起步-2" class="headerlink" title="起步"></a>起步</h3><p>同一号线，在右侧第二车道行驶。过红绿灯靠右侧车道行驶，随后打左转向灯变道到中间车道（不可压错位虚线）。保留转向灯到路口左转完成。</p><h3 id="变更车道-2"><a href="#变更车道-2" class="headerlink" title="变更车道"></a>变更车道</h3><p>变更到最左侧车道。</p><h3 id="会车-2"><a href="#会车-2" class="headerlink" title="会车"></a>会车</h3><p>什么都不需要做。</p><h3 id="前方路口左转-2"><a href="#前方路口左转-2" class="headerlink" title="前方路口左转"></a>前方路口左转</h3><p>进入左转弯车道，左转后靠左侧车道行驶。随后打左转向灯准备掉头。</p><h3 id="前方路口掉头-2"><a href="#前方路口掉头-2" class="headerlink" title="前方路口掉头"></a>前方路口掉头</h3><p>同一号线。掉头后靠右侧车道行驶。</p><h3 id="前方路口右转-2"><a href="#前方路口右转-2" class="headerlink" title="前方路口右转"></a>前方路口右转</h3><p>打右转向灯，进入右转向车道，右转后靠右侧车道行驶。</p><h3 id="超车-2"><a href="#超车-2" class="headerlink" title="超车"></a>超车</h3><p>打左转向灯，变道到中间车道。</p><h3 id="直线行驶-2"><a href="#直线行驶-2" class="headerlink" title="直线行驶"></a>直线行驶</h3><p>同一号线。完成后松油门踩离合刹车退三档。</p><p>进入右侧第二直行车道，打右转向灯，过红绿灯靠右侧车道行驶。</p><h3 id="靠边停车-2"><a href="#靠边停车-2" class="headerlink" title="靠边停车"></a>靠边停车</h3><p>听到语音提示后再停车。同一号线。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驾照 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大艺团新媒体中心摄影部招新策划</title>
      <link href="/post/2021-08-23_Art-Ensemble-New-Media-Center-Recruitment-Plan/"/>
      <url>/post/2021-08-23_Art-Ensemble-New-Media-Center-Recruitment-Plan/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-8-23-大艺团新媒体中心摄影部招新策划"><a href="#2021-8-23-大艺团新媒体中心摄影部招新策划" class="headerlink" title="2021-8-23_大艺团新媒体中心摄影部招新策划"></a>2021-8-23_大艺团新媒体中心摄影部招新策划</h1><h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><p><strong>部门招新</strong>我认为<strong>至少能达到两个目的</strong>：一是给部门的<strong>一次集中宣传</strong>，二是为部门<strong>招到合适人才</strong>。还有一点就是对<strong>部门的二次认知</strong>。在部门招新时我们会常被人问及：你们部门究竟是干啥的？听到这个问题的时候可能我们自己都是懵逼的，但还是能给对方balabala介绍一大段。扪心自问，不管当时你是如何回答的，反问自己的内心真的是清楚的吗。在平常的部门工作中，我们常常容易忽略这样的问题，但是突然被问到时，大部分人可能都有过心头一愣的困惑和犹豫。这暴露出我们对自己加入了蛮久的部门的定位、宗旨、文化等并没有准确把握和理解。如果我们要做部门招新，那么这个问题，至少是首先需要考虑清楚的，不光是给新人找答案，也是给懵懂的自己找答案。</p><p>招新点子无非是以下几要素：一是<strong>部门自身优势</strong>，<strong>独特性</strong>；二是部门<strong>成就</strong>，<strong>荣誉</strong>感；三是管理方式，<strong>归属感</strong>；四是<strong>活动</strong>参与，成就感；五是<strong>锻炼机会</strong>，进步性；六是公益服务，社会<strong>责任感</strong>。</p><p>更多的部员不是目标，多了其实并不好安排，管不来。保证每次活动都参与进来，愿意为部门做事、有任务做才是最好的。更好的更适合部门的才是好的。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><strong>部门招新的一般流程也就是前期准备、招新宣传、笔试面试，最后办个新成员见面会</strong>。我们部门在招新之后还可以做一次招新总结，随后写出活动结案，目的自然是尽早梳理各环节工作进行总结、累积经验。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>包括策划案撰写、宣传单页以及海报条幅的设计制作、报名表和信息登记表设计打印、宣传软文编辑与配图等。</p><p><strong>部门成员通讯录和没课时间表统计和更新</strong>，这个主要是为了了解部门成员的空闲时间好方便分配给活动中的工作，尽量不与课程冲突。日常部门管理中也能参照这个表来敲定统一聚餐出游或者其他活动的时间，很有用，需要更新通讯录或者成员其他信息其实只要在某次开会时让大家填一张表后再整理就行了。</p><p>为了节省时间，推荐<code>超级社团</code>，<code>超级课程表</code>跟它是绑定登陆的，课表信息可以直接导入<code>超级社团</code>，自动生成一张没课时间表，并且可以随着每周课程的变动而相应调整。</p><h3 id="招新宣传"><a href="#招新宣传" class="headerlink" title="招新宣传"></a>招新宣传</h3><p>线上宣传：微博、微信、空间、QQ群、贴吧、论坛等。</p><p>线下宣传：传单、海报、彩喷、展板、横幅、扫楼、摆台等。</p><p>首先关于线上宣传，要<strong>根据自己学校的新媒体平台活跃度来选择比较有效的阵地宣传</strong>，各平台的宣传都应该有，只是集中宣传区域可能有不同。相对来说，QQ、校园贴吧的用户群还是最大的，那么线上宣传就可以集中在空间、QQ群还有校园贴吧，在贴吧能联系到吧主置顶当然是最好了。另外，各平台内容最好持续更新，尽量同步，因为事前你无法判断报名者从哪里看到了你们的宣传而产生了冲动。有些学校可能有<strong>官方机构账号能够帮忙推送部门活动信息</strong>，那么千万不要忽略这次增大曝光的机会，想方设法联系合作。</p><p>接着来说线下宣传，我稍稍提及下海报的张贴，这也是有技巧的。海报整体设计新颖自然容易夺人眼球，让人有驻足观看了解的欲望，<strong>在宣传橱窗张贴海报时，同时并排贴几张也能吸引人注意</strong>，制作的时候适当多做一些，两张海报贴的间隔不要太大，那样又会显得杂乱不整齐，没有并排贴美观有气势了。线下的摆台报名关键是做好与招新传单的配合发放，呆板的像发街边传单一样肯定是不行的，及时走动，<strong>主动一些，总结一下传单内容，一句话概括，说的有吸引力</strong>。有针对性地发，如果你一眼就看出对方是大三大四或者研究生，不是你的招新对象就不给。此为发传单的技巧。</p><p>（可选）在线下宣传中扫楼的效果应该是最显著的，能够避免有些人宅在寝室或者错过了部门的摆台路线，这也提示室外贴招新海报的时候尽量覆盖面广一些，能把大多数人的行走路线涵盖。当然<strong>前期调查主要招新对象住在哪一栋楼哪几层还有大致的课程安排</strong>也是很有必要的，不要信心满满的准备上楼去宣传却发现整层楼的人都去上课了。</p><h3 id="笔试面试"><a href="#笔试面试" class="headerlink" title="笔试面试"></a>笔试面试</h3><p>这个环节主要是选人的过程。现在大多数部门开始加入笔试环节，前面一般会有一个报名表的筛选，先筛掉小部分人。笔试面试的选择和具体方式根据部门用人所需选取。<strong>简历筛选看态度，笔试看文字表达，一面考察能力，二面敲定部门</strong>。笔试阶段除了设置一些对部门基础认知的问题外，还有一些职能部门问题的考查，这个主要是大致了解面试者对部门职能的认知，如果有较大的错误认知，那么起码在安排部门的时候需要慎重斟酌，同时对这些的了解也有利后面的面试提问。</p><p>这里我提醒<strong>一些工作细节设置，可以展现部门的专业程度，对树立部门的形象也是很有好处的</strong>。举几个栗子：给面试者制作号码牌（如果是小组面试最好有），每位面试官面前摆放一瓶矿泉水，有面试官用电脑在做记录和点评（一两个就行，做做样子也好），整个面试流程自然顺畅等。另外，<strong>在候场区建议有人控场</strong>，可以给前来面试的人再介绍一下部门，播放一些以前的活动视频或者解说一些精彩图片都挺好的，这样即使他们没被招进来，也可能转化成部门的粉丝。</p><h3 id="新成员见面会"><a href="#新成员见面会" class="headerlink" title="新成员见面会"></a>新成员见面会</h3><p>人才招进来了当然会有新成员见面会，除了自我介绍外，最好有一个“破冰”环节，让大家相互熟悉，新成员能够尽快融入。玩游戏的效果可能会好一些，或者准备简单的户外素质拓展。</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>①没事就去校级院级新生群翻翻，多在新生群水群，让大家眼熟你，最好是玩的不错的那种，在开始准备招新的时候在群里宣传宣传部门。如果有你们院的学弟学妹问问题，私聊他&#x2F;她耐心解答，他们自然会加你QQ，这样后期招新你在空间发招新文案的时候，他们就可以看到   当然你也可以问问他对大艺团新媒体中心有没有兴趣 ，如果有，你可以推荐你们部门，如果他更想去校青协那种，你可以把他介绍过去，卖个顺水人情，和校青协部长说，让她有合适的给你推荐一下，互利互惠。</p><p>②秘书部的基础工作不要说的太惨了，可以说我们部门能扩宽你的朋友圈，锻炼你的口才，怎么让别人来协助你完成工作，很多新生加入校级组织都是为了提升自己的能力。也可以说你组织办理的时候，能学习一下别人为什么这么会说话，重点更多人更期待认识更多自己院的别的院的朋友。当然，也可以说说自己部门有什么好玩的来吸引人。</p><p>③每个班都会有安排的班导，可以提前摸清楚，如果有认识的，可以开学过一阵军训左右，提前联系一下他们，问问能不能帮你在他的班级内宣传一下（记得请他们喝奶茶哟，别人帮你是情分，不帮是本分）。</p><h2 id="利他"><a href="#利他" class="headerlink" title="利他"></a>利他</h2><blockquote><p>利他，也就是凭什么他要加入？加入部门有什么好处？</p><p>有关我的工作计划：</p></blockquote><ul><li>公众号每期选用刊登优秀的校园摄影作品，让更多人看到你的作品。</li><li>每月固定主题，一同探讨与创作。提升你的摄影能力。</li><li>领略各团风采，面对面结交友谊，形成具有足量异性的人脉网</li><li>轮流有序开展话题导向的影视技术讨论，输出知识，带动萌新培养观念</li><li>引导部员进行自身宣传，校内接单打响名气</li><li>内部公开各团排练表与项目，助力自由创作</li><li>人人都可以是主机位，FS5手把手教学</li><li>作为内部成员体验先进的中心文件存储与快速资源共享机制</li><li>并行工作流，参与以达芬奇为主、Adobe为辅的工作组模式</li><li>体验并参与素材集中化的实时同步多人协作</li><li>享受非义务性、人情导向、有偿可选的器材自由租赁体系</li><li>一系列能产生成就感的福利</li></ul><h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><p>要给干事树立观念，部门里部长说的话发的东西，最好不要发给别人，特别是强调过的关于工作的。</p><p>对他们好一点，玩归玩，闹归闹，工作归工作。校级组织需要有让她&#x2F;他想要留下来的想法，毕竟只有热爱，才会愿意和我们一起搭伙建设部门。我们是合作伙伴，并不是那么严格的上下级关系，要建立那种班上没有的集体的感觉。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 学生组织 </tag>
            
            <tag> 大学生艺术团 </tag>
            
            <tag> 新媒体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阳光16法则</title>
      <link href="/post/2021-08-15_sunshine-16-rules/"/>
      <url>/post/2021-08-15_sunshine-16-rules/</url>
      
        <content type="html"><![CDATA[<h2 id="阳光16法则"><a href="#阳光16法则" class="headerlink" title="阳光16法则"></a>阳光16法则</h2><p>阳光16的基本法则如下：在室外阳光下，如果光圈是 f&#x2F;16，则快门速度应是所用<a href="https://zh.wikipedia.org/wiki/%E8%83%B6%E7%89%87">胶片</a>的国际感光度指数的倒数[<a href="https://zh.wikipedia.org/wiki/%E9%98%B3%E5%85%8916%E6%B3%95%E5%88%99#cite_note-1">1]</a>。例如，在室外阳光下，如用光圈是 f&#x2F;16，而所用胶片的感光度为iso100，则快门应为 1&#x2F;100秒。</p><p>艳阳十六阴天八</p><p>多云十一日暮四</p><p>阴云压顶五点六</p><p>雨天落雪同日暮</p><h2 id="光圈快门整级档位"><a href="#光圈快门整级档位" class="headerlink" title="光圈快门整级档位"></a>光圈快门整级档位</h2><p>镜头的光圈从大到小的整级光圈：<br>1.0、1.4、2.0、2.8、4、5.6、8、11、16、22、32</p><p>照相机的快门从大到小的整级快门：<br>B门、1分、30、15、8、4、2、1、1&#x2F;2、1&#x2F;4、1&#x2F;8、1&#x2F;15、1&#x2F;30、1&#x2F;60、1&#x2F;125、1&#x2F;250、1&#x2F;500、1&#x2F;1000、1&#x2F;2000、1&#x2F;4000、1&#x2F;8000</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 胶片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大艺团新媒体中心摄影部工作计划</title>
      <link href="/post/2021-08-09_Art-Ensemble-New-Media-Center-Work-Plan/"/>
      <url>/post/2021-08-09_Art-Ensemble-New-Media-Center-Work-Plan/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-8-9-大艺团新媒体中心摄影部工作计划"><a href="#2021-8-9-大艺团新媒体中心摄影部工作计划" class="headerlink" title="2021-8-9_大艺团新媒体中心摄影部工作计划"></a>2021-8-9_大艺团新媒体中心摄影部工作计划</h1><blockquote><p>在大艺团宣传部里待了快一年，这些都是我希望“<strong>摄影部</strong>”相比于“<strong>宣传部</strong>”能更专业的地方。相信很多新生在这里都是为了寻求<strong>技术与审美上的成长</strong>而来的，我也不例外。</p><p>我觉得大艺团这样一个在校园里<strong>最具有艺术气息的环境</strong>是最适合<strong>个人自由创作</strong>的，现成的演员与模特，只需一个影棚几盏灯，就能为每一个人提供了创造出<strong>接近于商业作品</strong>的机会。而我想做的，正是让新成员们，在感受到到新媒体中心作为学生组织的“<strong>职能性</strong>”的同时，不忽略个人发展，将大艺团提供的<strong>平台与人脉</strong>，变为自身踏入新的领域的<strong>契机</strong>。</p><p>以下条目，没有按照“<strong>方面</strong>”来分类，而是按照“产出&#x2F;投入比”来排序的。它不是由易到难，也不是从大到小，而是更为现实的“<strong>收益</strong>”。这种收益，有组织的，也有个人的，更是日后大艺团所传承的。</p></blockquote><h2 id="建立基于-OneDrive-for-Business-世纪互联版-南信大-Office365-学生版的中心文件存储与快速资源共享机制"><a href="#建立基于-OneDrive-for-Business-世纪互联版-南信大-Office365-学生版的中心文件存储与快速资源共享机制" class="headerlink" title="建立基于 OneDrive for Business 世纪互联版 + 南信大 Office365 学生版的中心文件存储与快速资源共享机制"></a>建立基于 OneDrive for Business 世纪互联版 + 南信大 Office365 学生版的中心文件存储与快速资源共享机制</h2><h3 id="OneDrive与Win10系统高度集成"><a href="#OneDrive与Win10系统高度集成" class="headerlink" title="OneDrive与Win10系统高度集成"></a>OneDrive与Win10系统高度集成</h3><p><img src="https://static.pil0txia.com/picgo/20210810112322.png"></p><p><img src="https://static.pil0txia.com/picgo/20210811095535.png"></p><blockquote><p>无需第三方软件，与文件资源管理器高度集成，支持符号链接和硬链接，毋庸置疑是Windows上最好用的同步盘。</p></blockquote><h3 id="世纪互联版可以跑满带宽"><a href="#世纪互联版可以跑满带宽" class="headerlink" title="世纪互联版可以跑满带宽"></a>世纪互联版可以跑满带宽</h3><img src="https://static.pil0txia.com/picgo/IMG_20210811_094419.jpg" style="zoom: 67%;" /><blockquote><p>世纪互联版服务器由国内公司运营，图为校园网同步速度。</p></blockquote><h3 id="价廉物美-永久有效"><a href="#价廉物美-永久有效" class="headerlink" title="价廉物美 永久有效"></a>价廉物美 永久有效</h3><img src="https://static.pil0txia.com/picgo/IMG_20210811_094840.jpg" style="zoom: 33%;" /><blockquote><p>不限登录设备数量，账户永久有效，比百度网盘实惠的多，也更适合群组工作模式。</p></blockquote><h3 id="Web界面支持在线预览视频"><a href="#Web界面支持在线预览视频" class="headerlink" title="Web界面支持在线预览视频"></a>Web界面支持在线预览视频</h3><p><img src="https://static.pil0txia.com/picgo/20210811095836.png"></p><blockquote><p>无需缓冲，便于素材筛选与整理。分享链接可直接在Web界面查看。</p></blockquote><h3 id="南信大支持学生版-Office365-订阅"><a href="#南信大支持学生版-Office365-订阅" class="headerlink" title="南信大支持学生版 Office365 订阅"></a>南信大支持学生版 Office365 订阅</h3><blockquote><p>申请地址：<a href="https://nic.nuist.edu.cn/4050/list.htm">https://nic.nuist.edu.cn/4050/list.htm</a></p></blockquote><p>素材、工程文件等以项目和日期分类整理在 OneDrive 世纪互联内，便于成员快速接手项目。成员间第三方素材和加工过的半成品使用 OneDrive 学生版传递。可指定文件夹自动同步，当本地硬盘容量不足时可释放过期项目的空间，需要时再次下载。这不比百度网盘香？</p><h2 id="面对达芬奇17时代-迅速重导工作流-实现以达芬奇为主、Adobe为辅的工作组模式"><a href="#面对达芬奇17时代-迅速重导工作流-实现以达芬奇为主、Adobe为辅的工作组模式" class="headerlink" title="面对达芬奇17时代 迅速重导工作流 实现以达芬奇为主、Adobe为辅的工作组模式"></a>面对达芬奇17时代 迅速重导工作流 实现以达芬奇为主、Adobe为辅的工作组模式</h2><blockquote><p>达芬奇yyds！</p></blockquote><p>只要看过B站影视飓风的达芬奇系列教程，连常年使用 Pr + Ae 的Adobe体系的我都果断选择迁移使用习惯到达芬奇。其实非编软件的使用习惯大多相似，但达芬奇“媒体+快编+剪辑+调色+特效+混音+交付”的一体式工作流在各个环节都足够强大且更加简洁。</p><p>“达芬奇是越来越好用了，是不是要考虑换个剪辑调色的平台了呢？换吧。”</p><h2 id="利用校园网建立内网-PostgreSQL-服务器-实现素材集中化的实时同步多人协作"><a href="#利用校园网建立内网-PostgreSQL-服务器-实现素材集中化的实时同步多人协作" class="headerlink" title="利用校园网建立内网 PostgreSQL 服务器 实现素材集中化的实时同步多人协作"></a>利用校园网建立内网 PostgreSQL 服务器 实现素材集中化的实时同步多人协作</h2><p><img src="https://static.pil0txia.com/picgo/20210811101754.png"></p><p><img src="https://static.pil0txia.com/picgo/image-20210811101917562.png" alt="image-20210811101917562"></p><p><img src="https://static.pil0txia.com/picgo/image-20210811101949441.png" alt="image-20210811101949441"></p><p>传统的后期制作有一个线性工作流程，每个成员完成手头的任务后都交给下一个成员。达芬奇的多用户协作允许每个用户同时登录并在同一时间共同处理完全相同的项目。多个助手可以准备和整理素材，剪辑师可以剪切，视觉效果特效师可以处理镜头，调色师可以开始调色，而剪辑师仍在时间线中进行编辑。音频工程师甚至可以混合一个场景，而图片编辑器剪切另一个场景，无需花费数小时重新调整时间线即可查看彼此的更改。</p><blockquote><p>特性描述：DaVinci Resolve 17 – Collaboration | Blackmagic Design<br><a href="https://www.blackmagicdesign.com/products/davinciresolve/collaboration">https://www.blackmagicdesign.com/products/davinciresolve/collaboration</a></p></blockquote><h2 id="倡导非义务性、人情导向、有偿可选的器材自由租赁体系"><a href="#倡导非义务性、人情导向、有偿可选的器材自由租赁体系" class="headerlink" title="倡导非义务性、人情导向、有偿可选的器材自由租赁体系"></a>倡导非义务性、人情导向、有偿可选的器材自由租赁体系</h2><ul><li><p>不占领道德高地，没有强制要求。</p></li><li><p>有偿与否由双方共同决定。通常以人情的形式长期维系。</p></li><li><p>可利用现有活动室中转器材。</p></li></ul><h2 id="组织所有成员轮流有序开展话题导向的影视技术讨论"><a href="#组织所有成员轮流有序开展话题导向的影视技术讨论" class="headerlink" title="组织所有成员轮流有序开展话题导向的影视技术讨论"></a>组织所有成员轮流有序开展话题导向的影视技术讨论</h2><ul><li>两人或多人一组，每周在群内整理并发布摄影摄像相关的最新知识。可以是新发布的器材&#x2F;软件更新，也可以是对某位UP主（如影视飓风、午饭饭、千叶结锤、极速拍档、ALF等）的视频镜头分析，还可以是经典电影片段赏析。</li><li>群内讨论，往往是“所谓的大佬不输出知识，真正的萌新一言不发”。以这种话题的方式，由“大佬”发表看法与评价，进而输出知识，带动萌新培养观念。</li></ul><h2 id="带领部员领略各团风采-面对面结交友谊-形成具有足量异性的人脉网"><a href="#带领部员领略各团风采-面对面结交友谊-形成具有足量异性的人脉网" class="headerlink" title="带领部员领略各团风采 面对面结交友谊 形成具有足量异性的人脉网"></a>带领部员领略各团风采 面对面结交友谊 形成具有足量异性的人脉网</h2><ul><li>标题讲得很清楚。其实对于很大一部分人来说，寻找美的事物&#x2F;人记录下来，并从中获得摄影的愉悦感、从他人口中获得优越感才是不断去钻研新技术的源动力。</li><li>为什么是异性？女孩子喜欢拍女孩子没毛病，男生跟男生互拍，男性人像作品的门槛也要比妹子的糖水更高一些。</li></ul><h2 id="内部公开各团排练表与项目-助力自由创作"><a href="#内部公开各团排练表与项目-助力自由创作" class="headerlink" title="内部公开各团排练表与项目 助力自由创作"></a>内部公开各团排练表与项目 助力自由创作</h2><ul><li>“没有带相机”往往会打消一个人按下快门的动力</li><li>所以说，哪怕人在附近刚办完事，没有带器材，也欢迎去观摩排练，成为自己中意的团的“随团摄影师”。</li></ul><h2 id="更高效、更人性化的管理结构改革"><a href="#更高效、更人性化的管理结构改革" class="headerlink" title="更高效、更人性化的管理结构改革"></a>更高效、更人性化的管理结构改革</h2><ul><li><p>部长协助老师接收、处理上级任务</p></li><li><p>部长团收到老师的项目内容，制定项目计划</p></li><li><p>部长团与核心部员进行讨论，确定分工</p></li><li><p>核心部员带领部员团体完成任务</p></li><li><p>部员团体遇到困难进行内部协助</p></li><li><p>这种模式比“老师-部长-部员”的扁平结构更为立体，职能有效得到均摊，“管理、技术支持、基础工作”的分类更加清晰，缓解了“能者多劳，旁人看戏”的局面。</p></li></ul><h2 id="人人都可以是主机位-FS5手把手教学"><a href="#人人都可以是主机位-FS5手把手教学" class="headerlink" title="人人都可以是主机位 FS5手把手教学"></a>人人都可以是主机位 FS5手把手教学</h2><ul><li>引导接触更高端的设备，满足虚荣心与好奇心。阐明单反&#x2F;微单与摄像机等设备之间的差异性，有助于部员对自己手上的设备更为物尽其用。</li></ul><h2 id="引导部员进行自身宣传-校内接单打响名气"><a href="#引导部员进行自身宣传-校内接单打响名气" class="headerlink" title="引导部员进行自身宣传 校内接单打响名气"></a>引导部员进行自身宣传 校内接单打响名气</h2><ul><li>同样的，激励兴趣与动力。</li></ul><h2 id="争取校内各级各类文艺活动拍摄录制报道权-提升知名度"><a href="#争取校内各级各类文艺活动拍摄录制报道权-提升知名度" class="headerlink" title="争取校内各级各类文艺活动拍摄录制报道权 提升知名度"></a>争取校内各级各类文艺活动拍摄录制报道权 提升知名度</h2><ul><li>这个要在职能范围内进行，且更多的重心应该放在团队建设上，而不是一眛揽活儿增加负担。</li></ul><h2 id="专题讲座上座率低-集体实操讲解"><a href="#专题讲座上座率低-集体实操讲解" class="headerlink" title="专题讲座上座率低 集体实操讲解"></a>专题讲座上座率低 集体实操讲解</h2><ul><li>达芬奇的教学那次应该是去的人最多的，但去听的人似乎也没有学会将达芬奇用好的技巧。</li><li>剪辑软件提供的工具，怎么用工具在于人。拍摄和调色都是看重审美的环节，非花时间即时讲解不可。</li><li>虽然讲座也办不了几次就是了（bushi</li></ul><h2 id="远程办公化会议"><a href="#远程办公化会议" class="headerlink" title="远程办公化会议"></a>远程办公化会议</h2><ul><li>线上会议讲事，轮流进行会议记录，便于项目内容回顾，也可以给未参加会议的成员阅读。</li><li>线下会议干活，面对面操作传授。</li></ul><h2 id="修整102"><a href="#修整102" class="headerlink" title="修整102"></a>修整102</h2><ul><li>整个架子放设备，桌子放电脑，沙发椅子坐人，打扫打扫，又是新的一年了。</li></ul><blockquote><p>好怀念哦…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 学生组织 </tag>
            
            <tag> 大学生艺术团 </tag>
            
            <tag> 新媒体 </tag>
            
            <tag> Onedrive </tag>
            
            <tag> 达芬奇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说Java中只有值传递</title>
      <link href="/post/2021-08-05_java-only-pass-by-value/"/>
      <url>/post/2021-08-05_java-only-pass-by-value/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么说Java中只有值传递"><a href="#为什么说Java中只有值传递" class="headerlink" title="为什么说Java中只有值传递"></a>为什么说Java中只有值传递</h2><h3 id="Java的求值策略"><a href="#Java的求值策略" class="headerlink" title="Java的求值策略"></a><a href="#/basics/object-oriented/why-pass-by-reference?id=java%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">Java的求值策略</a></h3><p>前面我们介绍过了传值调用、传引用调用以及传值调用的特例传共享对象调用，那么，Java中是采用的哪种求值策略呢？</p><p>很多人说Java中的基本数据类型是值传递的，这个基本没有什么可以讨论的，普遍都是这样认为的。</p><p>但是，有很多人却误认为Java中的对象传递是引用传递。之所以会有这个误区，主要是因为Java中的变量和对象之间是有引用关系的。Java语言中是通过对象的引用来操纵对象的。所以，很多人会认为对象的传递是引用的传递。</p><p>而且很多人还可以举出以下的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Test</span> <span class="variable">pt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">User</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">  hollis.setName(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">  hollis.setGender(<span class="string">&quot;Male&quot;</span>);</span><br><span class="line">  pt.pass(hollis);</span><br><span class="line">  System.out.println(<span class="string">&quot;print in main , user is &quot;</span> + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pass</span><span class="params">(User user)</span> &#123;</span><br><span class="line">  user.setName(<span class="string">&quot;hollischuang&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;print in pass , user is &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=<span class="string">&#x27;hollischuang&#x27;</span>, gender=<span class="string">&#x27;Male&#x27;</span>&#125;</span><br><span class="line">print in main , user is User&#123;name=<span class="string">&#x27;hollischuang&#x27;</span>, gender=<span class="string">&#x27;Male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对象类型在被传递到pass方法后，在方法内改变了其内容，最终调用方main方法中的对象也变了。</p><p>所以，很多人说，这和引用传递的现象是一样的，就是在方法内改变参数的值，会影响到调用方。</p><p>但是，其实这是走进了一个误区。</p><h3 id="Java中的对象传递"><a href="#Java中的对象传递" class="headerlink" title="Java中的对象传递"></a><a href="#/basics/object-oriented/why-pass-by-reference?id=java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92">Java中的对象传递</a></h3><p>很多人通过代码示例的现象说明Java对象是引用传递，那么我们就从现象入手，先来反驳下这个观点。</p><p>我们前面说过，无论是值传递，还是引用传递，只不过是求值策略的一种，那求值策略还有很多，比如前面提到的共享对象传递的现象和引用传递也是一样的。那凭什么就说Java中的参数传递就一定是引用传递而不是共享对象传递呢？</p><p>那么，Java中的对象传递，到底是哪种形式呢？其实，还真的就是共享对象传递。</p><p>其实在 《The Java™ Tutorials》中，是有关于这部分内容的说明的。首先是关于基本类型描述如下：</p><blockquote><p>Primitive arguments, such as an int or a double, are passed into methods by value. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost.</p></blockquote><p><strong>即，原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。</strong></p><p>关于对象传递的描述如下：</p><blockquote><p>Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.</p></blockquote><p><strong>也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值。</strong></p><p>这一点官方文档已经很明确的指出了，Java就是值传递，只不过是把对象的引用当做值传递给方法。你细品，这不就是共享对象传递么？</p><p><strong>其实Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调函数的形式参数。</strong>只不过”传共享对象调用”这个词并不常用，所以Java社区的人通常说”Java是传值调用”，这么说也没错，因为传共享对象调用其实是传值调用的一个特例。</p><h3 id="值传递和共享对象传递的现象冲突吗？"><a href="#值传递和共享对象传递的现象冲突吗？" class="headerlink" title="值传递和共享对象传递的现象冲突吗？"></a><a href="#/basics/object-oriented/why-pass-by-reference?id=%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E7%9A%84%E7%8E%B0%E8%B1%A1%E5%86%B2%E7%AA%81%E5%90%97%EF%BC%9F">值传递和共享对象传递的现象冲突吗？</a></h3><p>看到这里很多人可能会有一个疑问，既然共享对象传递是值传递的一个特例，那么为什么他们的现象是完全不同的呢？</p><p>难道值传递过程中，如果在被调方法中改变了值，也有可能会对调用者有影响吗？那到底什么时候会影响什么时候不会影响呢？</p><p>其实是不冲突的，之所以会有这种疑惑，是因为大家对于到底是什么是”改变值”有误解。</p><p>我们先回到上面的例子中来，看一下调用过程中实际上发生了什么？</p><p><img src="https://static.pil0txia.com/picgo/f9c2caae4c8249ae86565e8fb88f7beb.png" alt="pass2"></p><p>在参数传递的过程中，实际参数的地址<code>0X1213456</code>被拷贝给了形参。这个过程其实就是值传递，只不过传递的值得内容是对象的应用。</p><p>那为什么我们改了user中的属性的值，却对原来的user产生了影响呢？</p><p>其实，这个过程就好像是：你复制了一把你家里的钥匙给到你的朋友，他拿到钥匙以后，并没有在这把钥匙上做任何改动，而是通过钥匙打开了你家里的房门，进到屋里，把你家的电视给砸了。</p><p>这个过程，对你手里的钥匙来说，是没有影响的，但是你的钥匙对应的房子里面的内容却是被人改动了。</p><p>也就是说，<strong>Java对象的传递，是通过复制的方式把引用关系传递了，如果我们没有改引用关系，而是找到引用的地址，把里面的内容改了，是会对调用方有影响的，因为大家指向的是同一个共享对象。</strong></p><p>那么，如果我们改动一下pass方法的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pass</span><span class="params">(User user)</span> &#123;</span><br><span class="line">  user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">  user.setName(<span class="string">&quot;hollischuang&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;print in pass , user is &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们在pass方法中，重新new了一个user对象，并改变了他的值，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=<span class="string">&#x27;hollischuang&#x27;</span>, gender=<span class="string">&#x27;Male&#x27;</span>&#125;</span><br><span class="line">print in main , user is User&#123;name=<span class="string">&#x27;Hollis&#x27;</span>, gender=<span class="string">&#x27;Male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>再看一下整个过程中发生了什么：</p><p><img src="https://static.pil0txia.com/picgo/d534a08b113546eb8660a92bdd2f94c4.png" alt="pass1"></p><p>这个过程，就好像你复制了一把钥匙给到你的朋友，你的朋友拿到你给他的钥匙之后，找个锁匠把他修改了一下，他手里的那把钥匙变成了开他家锁的钥匙。这时候，他打开自己家，就算是把房子点了，对你手里的钥匙，和你家的房子来说都是没有任何影响的。</p><p><strong>所以，Java中的对象传递，如果是修改引用，是不会对原来的对象有任何影响的，但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#/basics/object-oriented/why-pass-by-reference?id=%E6%80%BB%E7%BB%93">总结</a></h3><p>我们知道，编程语言中需要进行方法间的参数传递，这个传递的策略叫做求值策略。</p><p>在程序设计中，求值策略有很多种，比较常见的就是值传递和引用传递。还有一种值传递的特例——共享对象传递。</p><p>值传递和引用传递最大的区别是传递的过程中有没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。</p><p>在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用。</p><p><strong>我们可以总结说，Java中的求值策略是共享对象传递，这是完全正确的。</strong></p><p>但是，为了让大家都能理解你说的，<strong>我们说Java中只有值传递，只不过传递的内容是对象的引用。这也是没毛病的。</strong></p><p>但是，绝对不能认为Java中有引用传递。</p><p>OK，以上就是本文的全部内容，不知道本文是否帮助你解开了你心中一直以来的疑惑。欢迎留言说一下你的想法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#/basics/object-oriented/why-pass-by-reference?id=%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></h3><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html">The Java™ Tutorials</a></p><p><a href="https://en.wikipedia.org/wiki/Evaluation_strategy">Evaluation strategy</a></p><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">Is Java “pass-by-reference” or “pass-by-value”?</a></p><p><a href="https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/">Passing by Value vs. by Reference Visual Explanation</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 值传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迎接Obsidian数字花园——Joplin多平台用户该如何完美迁移？</title>
      <link href="/post/2021-08-05_joplin-2-obsidian/"/>
      <url>/post/2021-08-05_joplin-2-obsidian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>十个月后的再次更新。大一的学业、竞赛和大艺团的任务似乎并不需要拿出来赘述，遂与女朋友的生活点滴一起记在了日记里。暑假终于有了新的折腾。</p></blockquote><h2 id="Obsidian所能满足的需求"><a href="#Obsidian所能满足的需求" class="headerlink" title="Obsidian所能满足的需求"></a>Obsidian所能满足的需求</h2><p><code>Obsidian</code>是我逛少数派的时候看到的，目前仍处于开发阶段，但更新频率很高，在社区里有一定的热度。然后我注意到了它优于<code>Joplin</code>的地方，就一步步（指一个晚上）实现了<code>Obsidian</code>+<code>简悦</code>+<code>Hexo</code>+<code>Typora</code>+<code>Symlink符号链接</code>+<code>OneDrive</code>+<code>FolderSync</code>的Markdown<strong>编写&amp;摘录&amp;归纳&amp;同步&amp;发布</strong>体系。</p><p>倒腾了这么久，其实就是在建立升级自己的<code>数字花园</code>。</p><p>以前20年5月26日发布的<a href="https://pil0txia.com/post/2020-05-26_blog-writting/">基于Joplin的博客写作体系</a>只能实现一部分需求，缺失了最重要的<a href="#Symlink%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%20OneDrive%E5%A4%87%E4%BB%BD%20_posts%20%E6%96%87%E4%BB%B6%E5%A4%B9">博客文章同步修改</a>和<a href="#%E7%AE%80%E6%82%A6%E5%AF%B9%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8F%8F%E8%BF%B0">双向链接</a>功能。当通过反向链接将信息产生联系之后，就可以生成下面这种以信息为载体的图谱。知识图谱的建立可以将<strong>线性知识体系</strong>变为<strong>网状知识体系</strong>。</p><blockquote><p>Obsidian中我的笔记的关系图谱</p></blockquote><img src="https://static.pil0txia.com/picgo/20210805111953.png" style="zoom:67%;" /><blockquote><p>关系图谱中鼠标悬停处的线条将高亮显示</p></blockquote><img src="https://static.pil0txia.com/picgo/20210805112035.png" style="zoom: 67%;" /><p>这些笔记是从Joplin中迁移过来的，可以看到各个笔记之间的联系还没有那么紧密。在Obsidian中就可以更加便利地创造互相的联系。</p><p>致使我一直无法在基于Joplin的体系下定居的最主要原因还是它的<strong>笔记的存储方式</strong>。除了特性和功能上的差异之外，它们都是基于 Markdown 的知识管理系统的核心，但一个根本区别是 Joplin 使用<strong>唯一 ID</strong> 作为文件名并将用于 wiki 链接的注释名称存储在<strong>元数据</strong>中，而 Obsidian将<strong>文件名本身</strong>视为事实来源。</p><p>也就是说，Obsidian采用文件库的模式，将文件目录与文件以文件名的方式保存的硬盘上，修改操作与文件本身同步。而Joplin以唯一ID命名文件，虽然支持从文件目录导入，但不会将修改同步到文件上。于是<code>使用Typora编辑Hexo生成的文章</code>与<code>使用Joplin收纳博客文章</code>就无法统一，需要进行两次修改。</p><blockquote><p>Obsidian的编辑&amp;预览界面</p></blockquote><img src="https://static.pil0txia.com/picgo/20210805112140.png" style="zoom: 67%;" /><h2 id="Joplin-VS-Obsidian"><a href="#Joplin-VS-Obsidian" class="headerlink" title="Joplin VS Obsidian"></a>Joplin VS Obsidian</h2><ul><li>Joplin的最棒之处在于它是开源软件，不用担心Obsidian哪一天会开始割起韭菜。</li><li>Joplin可用于Windows、Mac、Linux、Android和iOS，而Obsidian的移动端版本近日才刚刚发布。</li><li>Joplin可以为数据提供端到端加密，而Obsidian官方的同步需要每月4美刀的费用，且端到端加密也是收费的。</li><li>Joplin可以让免费访问笔记版本历史记录。它默认保存最近90天的历史记录，最多可以更改为750天。Obsidian官方的云同步服务提供历史记录功能，本地免费提供快照功能，也可以借助网盘回溯历史记录。</li><li>Joplin官方提供了一个浏览器扩展来保存浏览器中的网页和屏幕截图。Obsidian还没有提供这种支持。但是我们可以使用第三方插件来让Web Clipper与Obsidian一起工作，也可以像我一样使用Markdown保存得更好的<a href="#%E7%AE%80%E6%82%A6">简悦</a>。</li><li>Obsidian支持插入模板，并自动添加日期与时间。新建笔记后再插入Hexo常用的<code>Front-matter</code>模板<code>post.md</code>，便可以抛弃命令行新建文件再重命名的工序了。</li></ul><h2 id="Symlink符号链接-OneDrive备份-posts文件夹"><a href="#Symlink符号链接-OneDrive备份-posts文件夹" class="headerlink" title="Symlink符号链接+OneDrive备份_posts文件夹"></a>Symlink符号链接+OneDrive备份<code>_posts</code>文件夹</h2><p><a href="https://sspai.com/post/66834">符号链接、硬链接及其在 Windows 上的应用举例</a></p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>符号链接像一个虫洞：当用户或应用要访问此虫洞时，就会被传送到符号链接所指向的地方，<strong>但他们是通过虫洞访问此目标的</strong>，所以其路径仍是虫洞自己的路径，这是它和快捷方式在效果上的区别所在。</p><p>更进一步说，符号链接的名称或者后缀丝毫不会影响到其目标。如果有一个图片 cats.jpg，我为它创建一个叫做 cats.docx 的符号链接，双击 cats.docx 时，仍然会出现一个图片。</p><p>符号链接具有下面的特性：</p><ul><li><strong>只需要一个路径。</strong>创建时，它的目标可以是本地的、远程的任何文件或目录，即使目标不存在。</li><li><strong>所做的一切更改都会反映在目标上</strong>。因为打开符号链接，就是打开了目标。复制符号链接，会复制目标的内容；移动符号链接，则会移动链接本身。</li><li>更改目标的名称，移动目标的位置，符号链接将会成为死链，因为它无法通过设定的路径找到目标；更改符号链接本身的名称和位置，目标不受影响。</li><li>当目标被删除时，符号链接继续存在，但会成为死链，无法打开。当符号链接被删除时，它指向的目标不受影响。</li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p><strong>硬链接可以看作是一个既有文件的别名。</strong></p><p>它具有下面的特性：</p><ul><li>创建时，它必须指向本地的同一个卷内存在的文件，在 C 盘创建硬链接只能指向 C 盘存在的文件。因为只有在同一个卷内，文件 ID 才是独一无二的，且没人能在这个卷内编辑另一个卷的数据。不存在的文件没有文件 ID。</li><li>打开硬链接，所做的一切更改都会反映在目标文件上。因为目标文件也链接着被更改的数据。</li><li>更改目标文件的名称、位置，硬链接不会受到影响。更改硬链接的名称、位置，目标文件不受影响，链接不会断开。因为改名，移动都不会改变文件 ID。</li><li>当目标被删除时，硬链接继续存在，且可以正常打开、编辑。因为他具备一个完整的文件结构。当硬链接被删除时，目标文件继续存在，不受影响。只有当一个文件 ID 对应的所有硬链接被删除时，数据才真正被标记为删除。</li></ul><h3 id="创建符号链接与硬链接的方式"><a href="#创建符号链接与硬链接的方式" class="headerlink" title="创建符号链接与硬链接的方式"></a>创建符号链接与硬链接的方式</h3><p>Powershell（管理员）：<code>New-Item [链接名称] -Itemtype SymbolicLink/HardLink -Target [目标绝对路径]</code></p><p><a href="https://schinagl.priv.at/nt/hardlinkshellext/hardlinkshellext.html">Link Shell Extension</a>：一个功能十分强大的符号链接、硬链接（以及没提到的目录链接）的新建和管理工具。使用 <code>choco install linkshellextension -y</code> 或者进入软件 <a href="https://schinagl.priv.at/nt/hardlinkshellext/hardlinkshellext.html">官网</a>，下载安装包并打开。安装完成后，我们便能够使用鼠标中键或者右键来简单地创建链接。</p><h3 id="使用OneDrive实现Obsidian的同步功能"><a href="#使用OneDrive实现Obsidian的同步功能" class="headerlink" title="使用OneDrive实现Obsidian的同步功能"></a>使用OneDrive实现Obsidian的同步功能</h3><blockquote><p>Windows 中有许多虽然关键但难以移动位置的文件夹，要想使用 OneDrive 等云盘保存他们，往往只能另外复制一份，但这又面临着源文件更新的问题。</p></blockquote><p>Hexo的<code>_posts</code>就是如此。OneDrive不是为了备份程序目录及大量小文件设计的，将Web目录放入OneDrive文件夹中只会加重“正在查找更改”时的负担与时长。而符号链接可以让<code>_posts</code>以任何名称出现在OneDrive中，OneDrive访问此链接时会被引导到Hexo的<code>_posts</code>文件夹内，其中的内容就会被全部上传。</p><p>Obsidian的开发者在2021年3月25日表示，将开始<a href="https://forum.obsidian.md/t/symlinks-are-unsupported-do-not-show-them-if-created-while-obs-is-running/417/9">支持符号链接</a>。在此之前的版本只能使用硬链接来链接每一个文件，现在就省心多啦。</p><h2 id="FolderSync-OneDrive弥补移动端文件同步缺陷"><a href="#FolderSync-OneDrive弥补移动端文件同步缺陷" class="headerlink" title="FolderSync+OneDrive弥补移动端文件同步缺陷"></a>FolderSync+OneDrive弥补移动端文件同步缺陷</h2><p>移动端文件同步的重要性不言而喻，这也正是Joplin占优势的一点。安卓移动端目前仅支持本地目录与官方的付费同步服务，OneDrive移动端应用又不支持同步文件夹，故需要<code>Foldersync</code>来实现同步功能。</p><blockquote><p>注意，Foldersync目前不支持添加OneDrive世纪互联版的账户。</p></blockquote><h3 id="Obsidian手机端菜单界面"><a href="#Obsidian手机端菜单界面" class="headerlink" title="Obsidian手机端菜单界面"></a>Obsidian手机端菜单界面</h3><blockquote><p>库文件夹可以放在任何一个Obsidian能访问到的地方</p></blockquote><img src="https://static.pil0txia.com/picgo/Screenshot_2021-08-05-15-19-51-325_md.obsidian.jpg" style="zoom: 50%;" /><h3 id="Obsidian配置文件"><a href="#Obsidian配置文件" class="headerlink" title="Obsidian配置文件"></a>Obsidian配置文件</h3><blockquote><p>重命名配置文件夹以避免与电脑端工作区冲突</p></blockquote><img src="https://static.pil0txia.com/picgo/Screenshot_2021-08-05-15-19-58-183_md.obsidian.jpg" style="zoom:50%;" /><h3 id="FolderSync主界面"><a href="#FolderSync主界面" class="headerlink" title="FolderSync主界面"></a>FolderSync主界面</h3><blockquote><p>默认不同步删除操作，双向同步时FolderSync将忽略本地删除操作，会把删除前的文件再次下载到本地。</p></blockquote><img src="https://static.pil0txia.com/picgo/Screenshot_2021-08-05-15-20-16-561_dk.tacit.andro.jpg" style="zoom:50%;" /><h3 id="使用FolderSync在手机上与OneDrive同步"><a href="#使用FolderSync在手机上与OneDrive同步" class="headerlink" title="使用FolderSync在手机上与OneDrive同步"></a>使用FolderSync在手机上与OneDrive同步</h3><blockquote><p>同步历史记录中可以检查具体修改的文件。</p></blockquote><img src="https://static.pil0txia.com/picgo/Screenshot_2021-08-05-15-20-22-090_dk.tacit.andro.jpg" style="zoom:50%;" /><h2 id="简悦也可以是网页剪藏器"><a href="#简悦也可以是网页剪藏器" class="headerlink" title="简悦也可以是网页剪藏器"></a>简悦也可以是网页剪藏器</h2><p>无论是<code>Joplin Web Clipper</code>还是<code>Obsidian Clipper</code>亦或者<code>MarkDownload</code>，一番比较下来，对引用和代码块支持最好的还是<code>简悦</code>。简悦本身的阅读模式和标注也很悦目，将<code>复制Markdown到剪贴板</code>放在常用动作里，便能很快转录到笔记中。</p><p>在简悦的导出选项里，<code>Way Back Machine</code>的导出既快速又直观，那些担心内容会随着时间而改变的页面统统存进Way Back Machine就很放心。</p><blockquote><p>但是标注功能存在一个向下翻页后工具条自动消失的Bug，而且复制一小段文字也会加上简悦的转码注释，没什么复杂符号的时候干脆就用Typora的HTML转MD更方便。</p></blockquote><h2 id="简悦对双向链接的描述"><a href="#简悦对双向链接的描述" class="headerlink" title="简悦对双向链接的描述"></a>简悦对双向链接的描述</h2><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="http://ksria.com/simpread/docs/#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5">ksria.com</a></p></blockquote><blockquote><p>文档中心 | 简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展</p></blockquote><blockquote><p>此功能最低要求 2.2.0 版本，如低于此版本，<a href="http://ksria.com/simpread/">请升级</a> 到最新版本。</p></blockquote><hr><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E6%8F%8F%E8%BF%B0">描述</a></h3><blockquote><p>又称为为 <strong>反向链接</strong>，此功能属于 <a href="#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80">简悦 · 稍后读</a> 的功能，与其它双链笔记一样，可以方便的将不同的稍后读或标注产生关联。</p></blockquote><p><img src="https://z3.ax1x.com/2021/05/16/ggeIzT.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E7%89%B9%E7%82%B9">特点</a></h3><blockquote><p>简悦的反向链接支持：<strong>稍后读</strong> 与 <strong>标注</strong> 的互相添加，并且可以是 <strong>多对多</strong> 形式。</p><p>从某种角度上，双向链接与简悦 · 合辑有些相似，但区别在于：</p></blockquote><ul><li>双向链接是动态的，即 A 加入上 B 后，B 上面也会有 A 这样也就形成了 A 和 B 的相互关联性（合辑只是一个复制过程，即 A 加上 B 后，会产生 C</li><li>合辑是线性的，即：一个合辑包含多个单一的标注。</li><li>双向链接是网状结构，即：<strong>多对多</strong> 形式。</li></ul><h3 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0">如何添加</a></h3><blockquote><p>在 <a href="https://z3.ax1x.com/2021/05/21/gHFYl9.png">基础布局</a> · <a href="https://z3.ax1x.com/2021/05/21/gHVdjH.png">Evergreen</a> · <a href="https://z3.ax1x.com/2021/05/21/gHFDYD.png">Workflowy</a> · <a href="https://z3.ax1x.com/2021/05/21/gHFRmt.png">Kanban</a> 中，看到如下标识，打开即可，打开后会出现如下的界面。</p></blockquote><p><a href="https://imgtu.com/i/gHkMjA"><img src="https://z3.ax1x.com/2021/05/21/gHkMjA.png"></a></p><ul><li><p>左侧</p><blockquote><p>已经添加的双向链接</p></blockquote></li><li><p>右侧</p><blockquote><p>搜索界面，支持 <a href="#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F">Panel 栏</a> 一致的检索方案。</p></blockquote></li></ul><h4 id="操作视频"><a href="#操作视频" class="headerlink" title="操作视频"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E6%93%8D%E4%BD%9C%E8%A7%86%E9%A2%91">操作视频</a></h4><p><a href="https://imgtu.com/i/gHEEWD"><img src="https://z3.ax1x.com/2021/05/21/gHEEWD.gif"></a></p><h3 id="支持导出"><a href="#支持导出" class="headerlink" title="支持导出"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E6%94%AF%E6%8C%81%E5%AF%BC%E5%87%BA">支持导出</a></h3><blockquote><p>简悦 2.2.0 对 <a href="#/%E6%9C%8D%E5%8A%A1?id=%E5%AF%BC%E5%87%BA">导出</a> 进行了重构，目前几乎支持全部的简悦使用场景，自然也包括双向链接，下图即为导出为 HTML 效果</p></blockquote><p><img src="https://z3.ax1x.com/2021/05/18/gfgqsA.png"></p><h3 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a><a href="#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E5%9B%BE%E8%B0%B1">图谱</a></h3><blockquote><p>当通过反向链接将信息产生联系之后，就可以生成下面这种以信息为载体的图谱。</p></blockquote><p><img src="https://z3.ax1x.com/2021/05/16/ggmmSf.gif"></p><p>看起来很酷炫，仅此而已？当然不至于此，知识图谱的建立可以将 <strong>线性知识体系</strong> 变为 <strong>网状知识体系</strong>，例如下图：（每个节点均可点击）</p><p><img src="https://z3.ax1x.com/2021/05/16/ggmTht.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
            <tag> Obsidian </tag>
            
            <tag> 简悦 </tag>
            
            <tag> 符号链接 </tag>
            
            <tag> OneDrive </tag>
            
            <tag> FolderSync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C1科目二笔记</title>
      <link href="/post/2021-07-22_subject-2-notes/"/>
      <url>/post/2021-07-22_subject-2-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="倒车入库（正库）"><a href="#倒车入库（正库）" class="headerlink" title="倒车入库（正库）"></a>倒车入库（正库）</h2><p>正库，后视镜在倒车路径半圆外侧，库白线直角方块（黑方块）也在半圆外侧。</p><p>入库倒档直行段时打方向的时机：调整座椅至膝盖可以顶到方向盘支座底部，脚后跟可以落地踩离合。坐姿端正，视线看向后视镜下缘，后视镜下缘即将没过白线下缘时，打死方向。</p><p>随后，头和身体外倾，在后视镜中看到库白线直角方块时，左手此时从三点钟方向回打270度到六点钟方向，继续倒车。</p><p>后视镜中车身与库线平行时回正。</p><p>横白线下缘与后视镜下缘相切时停车（与入库倒档直行段时打方向处差不多）。</p><p>出库时，视线向车窗后下方角看去，视线落点在库白横线中心线上时，开始打方向270度（左手在十二点钟方向），并持续到车身与入库线平行。</p><p>视线看到门把手与入库横线在一条线上时，再往前开一点点（或白线过肩），停车。</p><h2 id="倒车入库（反库）"><a href="#倒车入库（反库）" class="headerlink" title="倒车入库（反库）"></a>倒车入库（反库）</h2><p>反库，后视镜在倒车路径半圆内侧，库白线直角方块（黑方块）也在半圆外内侧。</p><p>车从车位中前进出来时，打方向的时机与正库一样，向左边打一圈半，直到车门把手视线延长线在横白线上。出来后的车头是斜的。</p><p>方向盘不动，挂倒档，车身与竖白线平行时，方向盘向左打死。随后眼睛看后视镜里的车屁股，当车屁股碰到距黑方块一脚位置处（黑线）时，方向盘回正。继续倒车，直到车轮压到黑方块与库竖白线的延长线上时，方向盘向左打死。调整车身平行，停车位置与正库一样。</p><h2 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h2><p>倒车，肩膀与路牙平行，向右打死方向。</p><p>后视镜看到库线内侧直角（小石块）时，回正。</p><p>轮胎在即将压到库线外缘时，向左打死方向。</p><p>车身调平，方向盘不动，打左转向灯，出库。直到挡风玻璃出风口上的纸片在出口竖库线的延长线上时，方向盘回正。当雨刮器上的白色方块接触到出口竖库线的延长线时，向右打死方向。</p><p>车身调平，停车。</p><h2 id="S弯-amp-直角转弯"><a href="#S弯-amp-直角转弯" class="headerlink" title="S弯&amp;直角转弯"></a>S弯&amp;直角转弯</h2><p>往左边靠，但不撞路牙。</p><p>车头盖住黑线或弯道外侧白线触到挡风玻璃右下角时，停车。方向盘向右打一圈。纸片对准右边黑色路牙时，方向盘回正。</p><p>后视镜左下缘与白线重合时向左一圈。保持后视镜左下缘与白线重合，以90度为单位修正。纸片对准黑色路牙时，方向盘回正。</p><p>雨刮器高处白色方块在白线延长线上时，方向盘向右打一圈。头伸出去看轮胎，控制轮胎与路边的距离。</p><p>进入直角拐弯，纸片与黑色路牙对齐，90度为单位修正。</p><p>开启右转向灯，当右侧门把手右下角即将碰到白线时，向右打死方向。转向进行到一半时关闭转向灯。</p><h2 id="场地绕行"><a href="#场地绕行" class="headerlink" title="场地绕行"></a>场地绕行</h2><p>侧方停车+S弯+直角转弯+正反倒车入库</p><p>纸片对齐黑线，开到侧方停车发车点。侧方停车。</p><p>打左转向灯驶出，靠左行驶，开始S弯。</p><p>肩膀与白线平齐时，方向盘向左打死，对准桥上的黑线，开到倒车入库发车点，进行正反倒车入库。</p><p>完成后驶出场地。</p><h2 id="半坡起步"><a href="#半坡起步" class="headerlink" title="半坡起步"></a>半坡起步</h2><p>纸片顺着黑线开上坡，肩膀与左侧黑线齐平时停车。前保险杠需在中间线范围内，轮胎需距右边不超过30厘米。</p><p>如果已经过了黑线，刹车要直接踩到底。如果刚刚到黑线中心线，刹车要稍慢线性的踩下去。</p><p>两脚踩到底，手刹一松一放。抬离合，再抬刹车，车子往前走之后就不再动离合。</p><h2 id="车管所标点"><a href="#车管所标点" class="headerlink" title="车管所标点"></a>车管所标点</h2><p>侧方 石块 轮胎到白点线与白线中间、过了白点线打方向</p><p>S弯 路牙白点与蓝点正中间 白点</p><p>直角转弯 路牙黄点</p><p>正库 对齐墙上黑粗线 黄点打方向</p><p>反库 地上黑线划得偏早 应看练习时白色库线边缘 或轮胎盖住黑线后再打方向</p><p>半坡 黄白线 地上黑底白线 有白点&#x2F;线的黑柱子</p><p>倒车镜 前门把手在倒车镜三分之一处 看后轮胎能不能看到</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驾照 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天气之子》4K HDR Madvr渲染壁纸</title>
      <link href="/post/2020-10-01_tenki-no-ko-4k-hdr-wallpaper/"/>
      <url>/post/2020-10-01_tenki-no-ko-4k-hdr-wallpaper/</url>
      
        <content type="html"><![CDATA[<p>刚刚四刷了新海诚的《天气之子》，并且把影片中绘画技巧与摄影艺术都较为出色的镜头和帧用Madvr渲染器以4K HDR标准输出了出来。共196张（比我看《你的名字。》时截的还要多出63张），可供风光摄影构图与后期参考。</p><blockquote><p>动漫也可为摄影提供借鉴之处?</p></blockquote><p>动漫电影也是电影，其分镜与作画同样要按照摄影标准来。与其说是摄影，不如说是普遍的审美要求。</p><blockquote><p>那么实际该怎么操作和鉴赏呢</p></blockquote><p>新海诚的电影素有“每一帧都可以做壁纸”的赞誉，我不过是将其最为精美之处截取出来。除了传统风光摄影角度的色彩、构图与光线，其作为绘画作品的内容构思和景物排布亦值得借鉴。最好能去直接观赏电影，导演的运镜是静态图片无法展示的。</p><p>有的镜头我截取了多帧，你可以思考一下同一个景物、不同的角度和不同的主体画面占比会产生怎样不同的观感。</p><blockquote><p>看到不少打了一天电玩的，很沉得下心蛤</p></blockquote><p>上一次截图是手机2K屏的实画面，左右滑动定位；这一次用Potplyer+Madvr做出了4K的原画面，还可以逐帧微调，看上去是方便了，实质上是助长了自己的完美主义倾向，工作量+++</p><hr><p>临时下载链接：<a href="https://cowtransfer.com/s/59f1960da80041">https://cowtransfer.com/s/59f1960da80041</a></p><p>后附所有图片，无压缩。可使用浏览器看图模式批量保存。</p><p>建议使用高亮度、高对比度的屏幕观赏，否则高光区域易丢失细节。</p><p><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_000136.136.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002512.602.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002535.454.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002546.295.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002556.754.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002559.219.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_002659.601.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003502.818.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003504.769.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003552.355.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003552.691.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003556.027.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003653.950.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003658.589.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003740.881.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003922.772.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003935.829.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003938.375.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003941.920.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003944.338.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003944.381.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003950.844.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003950.887.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003951.513.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_003957.351.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004031.177.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004104.872.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004106.211.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004134.783.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004134.992.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004719.543.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004722.922.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004724.257.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_004725.717.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005217.091.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005217.923.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005227.727.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005250.750.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005305.014.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005316.232.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005339.549.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005341.384.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005342.008.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005358.567.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005401.071.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005505.168.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005506.946.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005511.183.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005539.375.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005600.340.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005601.588.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005609.533.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005651.405.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005651.449.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005702.081.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005719.524.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_005806.945.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010143.782.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010306.101.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010445.071.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010451.678.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010515.450.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_010855.880.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011232.305.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011235.767.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011236.557.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011321.353.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011340.330.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011343.791.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011343.835.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011344.252.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011408.399.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011419.954.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011422.320.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011422.825.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011424.250.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011444.258.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011451.943.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011549.083.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011721.425.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011924.882.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011924.926.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011930.388.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_011957.708.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012204.625.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012411.462.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012411.625.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012412.045.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012643.946.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012704.260.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012707.888.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012807.488.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012807.572.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012812.077.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012834.348.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012845.067.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012845.111.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012856.078.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012931.194.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012933.198.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012933.242.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_012941.332.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013036.470.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013040.724.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013049.357.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013143.912.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013149.127.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013220.242.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013220.741.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013222.034.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013238.093.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013244.016.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013255.444.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013256.445.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013300.698.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013316.173.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013329.852.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013344.159.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013354.125.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013402.428.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013406.432.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013439.296.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013440.422.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013445.261.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013502.028.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013502.486.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013504.323.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013505.657.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013514.249.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013547.867.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013554.122.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013554.955.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013608.093.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013610.095.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013611.124.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013611.970.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013612.931.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013613.431.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013614.516.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013615.769.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013619.062.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013623.068.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013636.540.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013649.970.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013657.393.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013707.112.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013713.201.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013715.660.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013718.707.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013728.923.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013743.171.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013751.740.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013801.707.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013810.966.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013815.554.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013820.558.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_013946.644.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014013.922.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014023.348.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014023.391.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014024.559.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014103.431.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014154.732.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014203.698.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014314.019.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014407.949.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014413.204.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014427.905.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014428.636.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014432.097.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014442.565.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014456.162.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014457.832.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014501.528.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014506.089.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014506.175.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014506.257.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014506.464.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014507.965.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014508.341.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014508.510.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014509.260.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014511.929.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014515.890.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014523.816.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014528.154.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014537.954.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014626.629.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014628.130.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014659.120.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014701.301.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014704.333.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014711.506.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014718.722.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014730.652.jpg"><br><img src="https://static.pil0txia.com/gallery/tenki_no_ko/WEATHERING%20WITH%20YOU_014740.777.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸 </tag>
            
            <tag> 天气之子 </tag>
            
            <tag> 新海诚 </tag>
            
            <tag> 4K </tag>
            
            <tag> HDR </tag>
            
            <tag> Potplayer </tag>
            
            <tag> Madvr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angel Beats!观后感</title>
      <link href="/post/2020-09-02_Angel-Beats!/"/>
      <url>/post/2020-09-02_Angel-Beats!/</url>
      
        <content type="html"><![CDATA[<p>本来想补月色真美的</p><p>结果一不小心把AB补完了</p><p>（还算是短篇嘛）</p><p>前几集只是在拣高能进度条看</p><p>到中期，与其说是为了剧情的衔接，不如说在观察人物的细节刻画</p><p>一整集连ED都不带跳的</p><p>确实，每次ED都有着细微的区别</p><p>都是加人不错，不过人物的神态与动作都有着成长的痕迹</p><p>中途缺失的人儿，也能回来的</p><p>直到……</p><p>直到最后一集的ED</p><p>我回想起此前的弹幕</p><p>“请好好珍惜现在还在加人的ED吧”</p><p>当今补番被列为神作的AB，当初追番时却未有如此好评</p><p>虽说我已GET到它的点，也不至于泪奔</p><p>但是那最后逐个的消失</p><p>真是孤独啊</p><blockquote><p>知乎某匿名用户：</p><p>“angel beats到底说的是什么呢？</p><p>我想说的应该是牺牲与奉献，残忍和爱，命运和意志之间的故事吧。</p><p>可在结局我还是哭了，奏和音无的分离固然是让人落泪的，战友们和命运抗争的故事也让人感到辛酸，然而时隔很久之后，我再看到《angel beats》这两个字眼时，从心底涌上的悲伤和恐惧，全都将矛头指向了一个场景——</p><p><img src="https://static.pil0txia.com/picgo/1599036461622.jpeg"><img src="https://static.pil0txia.com/picgo/1599036464414.jpeg"><img src="https://static.pil0txia.com/picgo/1599036466919.jpeg"></p><p>即便知道这意味着永恒的分离，但却仍然真诚地说出了“挚友”这样的词。有人说：为什么明明之前把音无刻画得那么无私，最后却自私地要求奏留下来陪他？我想，麻枝准可能在写这段剧本的时候就感受到了那种令人绝望的孤独吧，曾经朝夕相处、拥有那么多共同记忆的朋友们一个又一个笑着安详地道别，笑着在眼前消失，怎么可能有人能受得了？</p><p>反正我哭了，我被孤独逼疯了。</p></blockquote><p>“My Soul, Your Beats!”</p><p>AB抒发的是一种终极的情怀</p><p>一个探求死后的人生意义的故事</p><p>一个厘清已死之人、曾经的生者与未知的未来之间纠连的讨论</p><p>音无结弦：“无论这些人生是怎样的，那也是我们所经历的人生。”</p><p>高坂桐乃：“这些东西都是我人生的一部分，少了它们中的任何一个，我都不是我了！”</p><p>妈：“你研究计算机的那些时间，你后悔吗？”</p><p>“我不后悔。这些人生，我没有白费。”</p><p>如果AB能有24话，想来是比肩CL的真神作吧</p><p>亦不负麻枝准的初心</p><p>いつもひとりで歩いてた<br>一直一个人前行<br>振り返るとみんなは远く<br>转身回望大家已经远去<br>それでもあたしは歩いた<br>即使如此我依然前行<br>それが强さだった<br>那正是我的坚强<br>もう何も恐くない<br>已经无所畏惧了<br>そう呟いてみせる<br>我这样自言自语着</p><hr><p>次要而言，精良的配乐也是AB的重要组成部分。</p><p>《theme of SSS》是我在网易云的第34首喜欢。《ロック风アレンジ》给予了它另一种诠释：</p><p>“所谓人类，就是连区区十分钟都等不了的啊！”</p><p>“这就是我的人生，是不能托付给别人，也不能被别人夺走的人生。”</p><p>“原来纯音乐也有让人声泪俱下的力量。”</p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次元 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费虚拟主机迁移 Discuz!</title>
      <link href="/post/2020-08-12_free-host-merge-to-Discuz!/"/>
      <url>/post/2020-08-12_free-host-merge-to-Discuz!/</url>
      
        <content type="html"><![CDATA[<h2 id="国外免费虚机"><a href="#国外免费虚机" class="headerlink" title="国外免费虚机"></a>国外免费虚机</h2><blockquote><p>国内免费虚机大多需要备案&#x2F;认证&#x2F;续期</p></blockquote><h3 id="http-www-xinnet-com-xinnews-virtualhost-29270-html"><a href="#http-www-xinnet-com-xinnews-virtualhost-29270-html" class="headerlink" title="http://www.xinnet.com/xinnews/virtualhost/29270.html"></a><a href="http://www.xinnet.com/xinnews/virtualhost/29270.html">http://www.xinnet.com/xinnews/virtualhost/29270.html</a></h3><ul><li><input checked="" disabled="" type="checkbox"> 000webhost 官网被墙，对sql有每小时5000次更新的限制，留用</li><li><input checked="" disabled="" type="checkbox"> FreeWebHostingArea ueuo.com被墙，留用</li><li><input checked="" disabled="" type="checkbox"> Zymic 官网无法访问</li><li><input checked="" disabled="" type="checkbox"> <del>UcoZ</del> 不支持PHP</li><li><input checked="" disabled="" type="checkbox"> <del>Six6</del> 不提供MySQL</li><li><input checked="" disabled="" type="checkbox"> SiteMix 500 Internal Privoxy Error</li></ul><h3 id="http-www-dns110-com-docs-11235-html"><a href="#http-www-dns110-com-docs-11235-html" class="headerlink" title="http://www.dns110.com/docs/11235.html"></a><a href="http://www.dns110.com/docs/11235.html">http://www.dns110.com/docs/11235.html</a></h3><ul><li><input checked="" disabled="" type="checkbox"> OpenShift 官网被墙，oc.zip未能下载</li><li><input checked="" disabled="" type="checkbox"> <del>2FreeHosting</del> 500 Internal Privoxy Error</li><li><input checked="" disabled="" type="checkbox"> <del>Tap</del> 没找到</li><li><input checked="" disabled="" type="checkbox"> <del>000webhost</del> 重复</li><li><input checked="" disabled="" type="checkbox"> ByetHost 官网被墙，网页版文件管理器解压失败，留用</li></ul><h3 id="https-blog-csdn-net-qimo601-article-details-84355494"><a href="#https-blog-csdn-net-qimo601-article-details-84355494" class="headerlink" title="https://blog.csdn.net/qimo601/article/details/84355494"></a><a href="https://blog.csdn.net/qimo601/article/details/84355494">https://blog.csdn.net/qimo601/article/details/84355494</a></h3><ul><li><input checked="" disabled="" type="checkbox"> <del>000webhost</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>Zymic</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>SiteMix</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>UcoZ</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>Six6</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>FreeWebHostingArea</del> 重复</li><li><input checked="" disabled="" type="checkbox"> <del>Freehostia</del> 数据库容量10M过小</li><li><input checked="" disabled="" type="checkbox"> 0fees 官网被墙，和byethost一样的面板，留用</li><li><input checked="" disabled="" type="checkbox"> <del>ByetHost</del> 重复</li><li><input checked="" disabled="" type="checkbox"> MegaByet 官网被墙，指向byethost</li><li><input checked="" disabled="" type="checkbox"> 20x 官网无法正常工作</li></ul><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><ul><li><input checked="" disabled="" type="checkbox"> awardspace 国内体验不错，但是对sql有每小时12000次查询限制，留用且上线</li></ul><h2 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h2><ol><li>上传网站（upload.rar）并解压、原ucenter（UCenter）、discuz备份（&#x2F;data&#x2F;backup_XXXXXX）、ucenter备份（&#x2F;UCenter&#x2F;data&#x2F;backup）、模板（template）、附件（&#x2F;data&#x2F;attachment）、根目录favicon.ico</li><li>访问http:&#x2F;&#x2F;域名&#x2F;install，安装时注意正确填写数据库信息</li><li>后台-站长-数据库-恢复-restore.php（如果虚拟主机有每小时查询量的限制，就在备份时分更多卷，用phpmyadmin依次上传）</li><li>后台-站长-UCenter设置 将uc_server改为UCenter</li><li><a href="https://my.oschina.net/u/3776619/blog/2222897">修改Discuz!的数据库密码</a>，要注意<a href="https://blog.csdn.net/forest_fire/article/details/50944457">修改数据库表名</a>。如果discuz与UCenter通信失败，参考<a href="https://www.discuz.net/thread-2982464-1-1.html">https://www.discuz.net/thread-2982464-1-1.html</a></li><li>后台-UCenter-数据备份-数据恢复</li><li>后台-站长-数据库-校验</li></ol><h2 id="GBK转换UTF-8"><a href="#GBK转换UTF-8" class="headerlink" title="GBK转换UTF-8"></a>GBK转换UTF-8</h2><p>国外虚拟主机的php.ini大多默认为utf-8，而我们安装论坛时大多使用GBK，若不能修改php.ini，就要将discuz转码。</p><p>总体思路：<a href="https://www.jianshu.com/p/a8ab1c264fc4">Discuz论坛程序简单转码：从GBK到UTF-8的编码转换</a></p><p>如果一开始安装的是GBK的discuz，那么在转码到UTF-8时，UCenter的config.inc.php中的字符集应该保持GBK，不应修改为UTF-8，否则会通信失败。</p><p>如果mysql报1146错误，缺失common开头的表，就使用<code>Discuz_X3.2_SC_UTF8\upload\install\data\install.sql</code>中的语句重新创建。其中，旧版的TYPE命令需要替换为新版的ENGINE命令。默认是latin1字符集，需要修改为utf8，参考<a href="https://www.cnblogs.com/liucx/p/11970427.html%E5%92%8Chttps://www.cnblogs.com/enjong/articles/8537531.html">https://www.cnblogs.com/liucx/p/11970427.html和https://www.cnblogs.com/enjong/articles/8537531.html</a></p><p>如果没有下载UTF-8的模板，就要接入新版应用中心下载：<a href="https://www.dismall.com/thread-957-1-1.html">新版Discuz!应用中心接入教程</a></p><p>原模板已下架，要用<code>GB2UTF8文件编码转换1.3.exe</code>将GBK转换为UTF-8再上传。</p><p>如果模板显示错误，要检查模板文件是否完整，然后用网页文件管理器上传。（我就是吃了这个亏，FTP并不完全可靠）</p><h2 id="离线版发布致辞"><a href="#离线版发布致辞" class="headerlink" title="离线版发布致辞"></a>离线版发布致辞</h2><p>前言：</p><p>　　语文高考江苏卷不再了，南京一中2020届考生毕业了，我们的语文论坛也完成了它的历史使命。这上线短短五个月的小站，却承载着高中的我们对文字的磨砺与徜徉。“在线会员”的最高纪录，是2019年5月26日的127人。我想，这一份论坛的离线副本，将是我们语文学习经历的一份精致缩影。</p><p>　　从未有过，百人，一站，人人皆可浏览他人风神；从未有过，百人，一师，人人皆得他人悉心点评。作为站长，亦从未见过，在互联网上如此纯粹专注的学习论坛。故，纵使不再运营，也应有遗迹留存于世。</p><p>　　毕业后的我们，再次打开昔日的论坛，笑一笑同学的个性头像，悟一悟老师曾经的教诲，嗅一嗅各类文笔的气息，想必感怀万千。</p><p>使用方法：</p><p>　　运行此目录下的“南京一中2020届语文论坛《及高考革改 何以作文章》”快捷方式，即可在浏览器中打开论坛。</p><p>　　若页面显示不正常，请检查浏览地址栏右侧的图标是否为“兼容模式”，若是，请点击它并切换为“极速模式”。</p><h2 id="长期在线版发布致辞"><a href="#长期在线版发布致辞" class="headerlink" title="长期在线版发布致辞"></a>长期在线版发布致辞</h2><p>南京一中2020届《及高考革改 何以作文章》语文论坛镜像站点上线致辞：</p><p>　　语文高考江苏卷不再了，南京一中2020届考生毕业了，我们的语文论坛也完成了它的历史使命。这上线短短五个月的小站，却承载着高中的我们对文字的磨砺与徜徉。“在线会员”的最高纪录，是2019年5月26日的127人。我想，这一份论坛的镜像副本，将是我们语文学习经历的一份精致缩影。</p><p>　　从未有过，百人，一站，人人皆可浏览他人风神；从未有过，千文，一师，人人皆得他人悉心点评。作为站长，亦从未见过，在互联网上如此纯粹专注的学习论坛。故，纵使不再运营，也应有遗迹留存于世。</p><p>　　毕业后的我们，再次打开昔日的论坛，笑一笑同学的个性头像，悟一悟老师曾经的教诲，嗅一嗅各类文笔的气息，想必感怀万千。</p><p>　　论坛地址：Write Art Online <a href="http://njyzbbs.myartsonline.com/">http://njyzbbs.myartsonline.com/</a></p><p>PS：镜像站点托管在国外，无需登录。不排除未来被墙可能性。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费虚机 </tag>
            
            <tag> 迁移 </tag>
            
            <tag> Discuz! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re：搭建家庭NAS服务器有什么好方案？</title>
      <link href="/post/2020-08-04_re-nas/"/>
      <url>/post/2020-08-04_re-nas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此系对知乎某回答的回复：<a href="https://www.zhihu.com/question/21359049/answer/803948874">https://www.zhihu.com/question/21359049/answer/803948874</a></p></blockquote><p>要是每个人动手能力都那么强，成品NAS也不至于有这么溢价。<br>土豪盲狙那是花钱买时间，小白从头一步步学起那是花时间省钱，还有很大一部分人是有计算机基础的，他们三下五除二又省钱又省时间——XAMPP+可道云的部署时长也真只要那么两三分钟时间就能上线。<br>这些掌握技术的人群，往往不止能在这一个地方省钱，需要预算的计划几乎都能省钱。不是说我们预算少才去了解这个产业，你预算再高也总有产品价格比你的预算高。更重要的是，如果你不知道自己的需求是什么，不知道产品什么样的特性才能满足你的需求，你花高价买回的产品的使用体验也不一定使你欣喜。<br>大佬都是从小白走来的，他们拥有的最重要的能力不是掌握的有限的知识，而是学习新知识的能力，此即学习力。这是一种优质的优势。<br>我们评论，是因为我们愿意分享自己的知识，愿意看到更多人受惠，愿意在小白花大钱买成品时为他提供一个新的视角，而不是所谓“极其自私”。望知悉！</p><blockquote><p>林大路 (作者) 回复<br>你手把手教？手把手免费教？小白也不一定有时间学。我们现在经验的基础上是告诉小白们，有哪些成熟可靠的方案，成熟到什么程度，能实现什么，这些功能做什么的。ABC几种预算投入的选择。有合资车，有国产车有进口车，消费者或者普通老百姓有买车的想法。也有一定的预算。比如10万，你突然来一句，来，用电焊咱们可以自己造一台，成本就1万。但是你不告诉人家需要300个工作日？</p></blockquote><p>内燃机车是闭源的，只有汽车大亨们才有工厂、机床和实现的技术；各大论坛发布的分步骤图文教程和使用的软件都是开源的，是想学就能学到的知识。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
            <tag> NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么推荐你选择ITX加轻薄本</title>
      <link href="/post/2020-08-03_why-prefer-itx/"/>
      <url>/post/2020-08-03_why-prefer-itx/</url>
      
        <content type="html"><![CDATA[<h2 id="言简意赅版"><a href="#言简意赅版" class="headerlink" title="言简意赅版"></a>言简意赅版</h2><blockquote><p>此部分首发于自己的知乎：<a href="https://zhuanlan.zhihu.com/p/158499473">https://zhuanlan.zhihu.com/p/158499473</a></p></blockquote><p>（使用需求低的人群应选择办公本，甚至不必配电脑）</p><p>众所周知，对游戏本而言，配置是下限，散热是上限。本身就限了功耗（性能），还那么容易过热，一过热风扇就直升机起飞，那么大的噪声依旧无法改变降频、掉帧的命运。其次屏幕小、键盘小、键盘发热、键盘手感不好，是为了便携作出妥协的产物。</p><p>可是，你真的需要这份鸡肋的便携吗？大学四年，需要移动电脑的情况只有：1.自己去找的兼职 2.毕业设计答辩 3.回家。学校不会要求学生带笔记本上课，上课带游戏本去记笔记什么的，不存在的，不如一个平板或轻薄本实在，而轻薄本比平板更适合作品展示。于是，在四年里的绝大多数时间里，游戏本都窝在宿舍里充当游戏机的角色，这和一台不能动的台式机又有什么差别呢？</p><p>相比游戏本，ATX台式机完全站在了它的对立面，出色的视觉体验和流畅的游玩之余，台式机优越的性价比比同配置的游戏本省下了整整一个轻薄本的钱。可是，不能带它回家度过两个月的暑假是我否定它的唯一理由。</p><p>这也正是ITX拥有如今人气的原因。我们说，ITX是所有硬件玩家的归宿，因为它精致的外观在紧凑的空间里实现了极致的性能，还保有相当的可升级拓展性。光追甜品卡2060S之后，能实现战地4K60帧不加价的新甜品卡发布了，不把2060S出了换一张吗？传统ATX机箱里总是有太多的富余空间，ITX不过是有着更高的空间利用率，其结构与性能都与ATX无异，却可以塞进旅行箱或是提在手里带它回家，实现性能与便携、性能与价格的双重统一。</p><p>另外，大一是用不到笔记本的，轻薄本可以安排在主机之后入手。如果使用轻薄本时需要跑什么大型程序，可以远程桌面到ITX操作运行。</p><h2 id="透彻说理版"><a href="#透彻说理版" class="headerlink" title="透彻说理版"></a>透彻说理版</h2><blockquote><p>此系对知乎某回答的回复：<a href="https://www.zhihu.com/question/336011147/answer/762330122">https://www.zhihu.com/question/336011147/answer/762330122</a></p></blockquote><h3 id="破"><a href="#破" class="headerlink" title="破"></a>破</h3><p>XPS是人傻钱多戴脍炙人口的旗舰商务机，稍微能压得住的都是万元级别，就这个钱，买到的性能也就千把块钱的台式机的样子，不推荐学生购买。</p><p>外置的设备的性能永远都达不到内置的性能，还很贵。大学宿舍哪来地方给你摆NAS机柜，一台群晖威联通的整机都至少2k，还没算上铺设高速线路和高性能路由的钱。更不要提远程储存的使用并没有本地的方便，太折腾。</p><p>他说，内存要大，硬盘要大，显卡不能差，这些配件肯定都是笔记本要贵于台式机的。而且笔记本的电源功耗有限、散热效能有限，这些硬件都无法发挥全部性能，还烫手。</p><p>他还说，这些笔记本，都是几年一换几年一换的，只要保证这几年里稳定就可以了。试问大学学生党、刚走上社会的职工，在没有他人资助的情况下，怎么可能做到几年一换？父母能资助一次，父母能每次都资助吗？笔记本本身就是高度集成、高度压缩空间的，它是牺牲了拓展性和性能才换来了这可怜的便携性。笔记本想要升级配置，就必须重新买一台，新的钱不说，旧的笔记本成色一般，贬值就很厉害——而台式机要更换&#x2F;升级配件都只要一拔一插，换下来的配件不用损失多少钱就可以转手给需要的人，生命周期远比笔记本长，何乐而不为？</p><p>他还要外接显示屏，还要外接机械键盘，现在的笔记本大多是14寸屏幕，台式机显示屏起步都是24寸，买了笔记本还要买块显示屏，那笔记本引以为豪的便携性去哪了？这不还是在把笔记本当主机用吗？</p><p>最后，他从业20余年，那他至少从上世纪90年代末期就在接触计算机行业。那一代人至少是在成人后才逐渐去接受个人电脑和信息化的使用习惯的，而我们这一代是完全在计算机和互联网中长大的，他们已经完全是我们这一代人的上上辈，对性能和性价比的要求自然没有那么苛刻。他一直在说他自己怎么样，不能替代下一代人的使用体验。</p><h3 id="立"><a href="#立" class="headerlink" title="立"></a>立</h3><p>我不选择台式机，因为它暑假带不回家；我也不选择笔记本，因为它的性能不够我用、便携性我用不到、性价比令我无法安心。所以我选择介于两者之间的ITX，实现性能与价格、性能与便携的双重统一，更重要的是，我心里踏实。</p><p>ITX是妥协，笔记本是妥协中的妥协，既然我不用那么妥协，为什么要强迫自己妥协？就我现在的配置，惠普游戏本要11k，ITX只要7k2，要是真的有什么会议&#x2F;小组讨论&#x2F;PPT展示，买一台性能足够放映&#x2F;远程桌面的廉价轻薄本即可，1k2的东芝Z30刚好满足我的需求，而且全金属机身、背光键盘、IPS触摸屏、6小时续航、1.2kg的重量都是非常令我满意欣喜的加分项。请试想，一台三公斤重的游戏本，带出去得要有多痛苦？游戏本那惊人的功耗，没有插电的地方只能运行多长时间？就算是有插座，游戏本的性能怎么可能赶超台式机？而ITX+轻薄本方案却比一台游戏本便宜得多。</p><p>游戏本，那是要性能没性能，要便携没便携，是大批学生党的选择；ITX+轻薄本，要性能有性能，要便携有便携，是拥有动手能力的玩家中饱受赞誉的选择。</p><p>总而言之，自组ITX+廉价轻薄本的方案，比出高价买游戏本的方案，更优越。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ITX </tag>
            
            <tag> 轻薄本 </tag>
            
            <tag> 游戏本 </tag>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们为什么会说「你不会百度吗」</title>
      <link href="/post/2020-07-20_the-reason-we-recommend-search-first/"/>
      <url>/post/2020-07-20_the-reason-we-recommend-search-first/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在互联网，你99%的问题都已经有人遇到过了。</p></li><li><p>百度、知乎、谷歌都解决不了的问题，你问我也解决不了。<a href="www.zhihu.com/answer/1337286205">^1</a></p></li><li><p>我们反感的大多是不经思考、理直气壮的伸手行为，这种问题不仅笼统巨大难以回答，而且让人解释起来很心累。<a href="www.zhihu.com/answer/1340066363">^2</a></p></li><li><p>不懂应该先学，学不会再问。出于情面的考虑，大多数情况下，我都会说：“你可以去百度一下，有什么不懂的地方再来问我”。</p></li></ul><blockquote><p>但凡我抛出问题有个人告诉我，你不会百度啊？我都不知道多高兴，我还会得寸进尺的问对方关键词要搜索什么？末了还要为自己能够直接抄答案回一句：“谢谢啊！要是看不懂再来麻烦你。”<a href="www.zhihu.com/answer/1336888306">^3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学入学和军训有必要买的物件&amp;注意事项</title>
      <link href="/post/2020-07-19_freshman-military-training-notes/"/>
      <url>/post/2020-07-19_freshman-military-training-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘抄自<a href="https://www.zhihu.com/question/333443411/answer/772703241">高中生进入大学，有哪些必须知道的常识和经验？</a>和<a href="https://www.zhihu.com/question/32149083/answer/774715895">军训有哪些必备物品和注意事项?</a></p><p>可进一步参考<a href="https://www.zhihu.com/question/48207349/answer/723554373">准大一学生上大学需要准备什么，购置什么东西？</a></p></blockquote><p><strong>如果你时间比较紧，一些内容可以不看，但一和十要认真看完，特别是第十点，一定要认真看完。</strong></p><h2 id="一、知道这些知识，你就是班里的吴彦祖（刘亦菲）"><a href="#一、知道这些知识，你就是班里的吴彦祖（刘亦菲）" class="headerlink" title="一、知道这些知识，你就是班里的吴彦祖（刘亦菲）"></a>一、知道这些知识，你就是班里的吴彦祖（刘亦菲）</h2><ul><li>第二，暑假一定要先准备一个<strong>自我介绍</strong>，因为上了大学要用上几十遍（军训、班级、社团介绍等等），把内容写好，<strong>谦虚的风格</strong>但能<strong>体现你的优秀</strong>为最佳，每天练习3-5遍。到时候开学，别人结结巴巴自我介绍的时候，你上去<strong>淡定从容</strong>，<strong>语气沉稳</strong>自我介绍，第一印象就已经赢了，后面想要交朋友或者泡朋友，都事半功倍。</li><li>2、在大学的班主任神出鬼没，一年可能也见不到几次。所以，开学一定要先把<strong>班主任的电话号码</strong>记下来，以后有大用。</li><li>4、平常图书馆人不多，但期末图书馆一定会爆满，要<strong>抢位子</strong>一定要早，一下子就会没的。</li><li>5、出门记得带一包<strong>纸巾</strong>，可以多出许多惊喜，也能解决很多问题。</li></ul><h2 id="三、男女感情"><a href="#三、男女感情" class="headerlink" title="三、男女感情"></a>三、男女感情</h2><ul><li>5、有<strong>上进心</strong>的男生吸引女生，有气质的女生吸引男生，外在只能迷一时，内在能迷人一辈子。</li></ul><h2 id="四、学习"><a href="#四、学习" class="headerlink" title="四、学习"></a>四、学习</h2><ul><li>1、大学很多老师都不会管人的，所以你要学会自己管自己。上课尽可能地往前面坐，最好是第一二排。<strong>前排很容易专注</strong>，后排非常容易被分散注意力去玩手机。</li><li>3、考证<strong>能尽早就别拖延</strong>，特别是四六级，早过早安心，千万别拖。</li><li>4、<strong>想学习就去适合学习的环境</strong>，既要舒服窝宿舍，又想高效学习，可能性是很低的。</li><li>5、千万<strong>别挂科</strong>。挂科后奖学金、保研、考评奖励什么的都跟你无缘了。</li></ul><h2 id="五、宿舍与人际"><a href="#五、宿舍与人际" class="headerlink" title="五、宿舍与人际"></a>五、宿舍与人际</h2><ul><li>1、室友不等于朋友。 -&gt;9</li><li>2、不要抱怨，也尽量远离那些爱抱怨的人。</li><li>7、周末的时候，不要在大早上定闹钟。</li><li>9、在宿舍不要说太多私人的事情。</li><li>11、忘掉合群这两个字，千万不要浪费时间参加没有意义的集体活动。不要为了显得合群久随大流。你的时间很宝贵，少做一些没有意义的事情。 -&gt;12</li><li>12、要学会适当拒绝他人，这也是一种成长。</li></ul><h2 id="六、生活"><a href="#六、生活" class="headerlink" title="六、生活"></a>六、生活</h2><ul><li>2、桶和盆可以不用带，占位置，学校超市有。</li><li>3、和宿管阿姨打好关系，你往后四年的生活会方便很多。</li><li>5、越早考驾照越好。</li></ul><h2 id="七、目标规划"><a href="#七、目标规划" class="headerlink" title="七、目标规划"></a>七、目标规划</h2><ul><li>1、<strong>实习</strong>越早准备越好，最好从大一开始。</li><li>2、远离那些能让你<strong>短时间内获得快感</strong>和满足的东西。如：撸、赌、小视频、脑残小说电视剧、垃圾游戏。养成<strong>习惯性自律</strong>会让你受益终身。</li><li>3、珍惜时间，更要学会<strong>管理时间</strong>。黛西非常建议同学们建立自己的时间管理系统，当形成习惯后，你会发现自己的每分每秒都过得充实无比。</li><li>5、<strong>别人的话参考</strong>意见就好，最后自己做决定。</li><li>7、学习不要局限于课堂，如何<strong>规划课余时间</strong>更重要。把课余时间规划好，是你拉开和其他同学差距的核心。</li></ul><h2 id="十、坚持与努力的信念"><a href="#十、坚持与努力的信念" class="headerlink" title="十、坚持与努力的信念"></a>十、坚持与努力的信念</h2><ul><li>但是如果你<strong>一直跑下去</strong>，双手拥抱终点回头看的时候，你会发现：“有的人在往回跑，有的人坐在了地上，有的人像老人一样散步着往前。“</li><li>选择哪一种，你可以<strong>一锤定音</strong>，而你的每一次选择，都是在为你想要的世界而投的票。 王小波说：“我从童年继承下来的东西只有一件，就是<strong>对平庸生活的狂怒</strong>，一种<strong>不甘没落的决心</strong>。”</li></ul><hr><h2 id="Round1-军训神器"><a href="#Round1-军训神器" class="headerlink" title="Round1 军训神器"></a>Round1 军训神器</h2><ul><li>1.鞋垫（卫生巾）</li><li>2.清凉喷雾&#x2F;冰凉贴</li><li>4.驱蚊水</li><li>5.湿巾</li><li>9.皮带</li><li>10.叠被器</li></ul><h2 id="Round2-注意事项及血泪经验"><a href="#Round2-注意事项及血泪经验" class="headerlink" title="Round2 注意事项及血泪经验"></a>Round2 注意事项及血泪经验</h2><ul><li><strong>防晒霜+卸妆水+洗面奶+补水面膜</strong>（<em><strong>少即是多，少折腾军训脆弱的脸</strong></em>）</li><li><em>面膜</em>:<em>台版的森田药妆玻尿酸保湿面膜</em></li><li>两个小时休息一次，休息的时候要补涂防晒（<em>补防晒之前觉得脸油难受可以买无香无酒精的湿巾擦脸</em>）</li><li>不要吃感光食物。常见的感光食物有：柠檬、胡萝卜、木瓜、芹菜、莴苣、土豆、香菜、苋菜、油菜、橘子、紫菜、田螺、菠菜、无花果，九层塔、韭菜、红豆。一般想皮肤变得白皙，应少吃感光食物，也可晚餐食用少许，食用后不宜在强光下活动，防止皮肤变黑</li></ul><h2 id="Round3-防晒"><a href="#Round3-防晒" class="headerlink" title="Round3 防晒"></a>Round3 防晒</h2><blockquote><p>**SFP50 PA++++**，防水防汗，油性皮肤，性价比</p></blockquote><h3 id="面部防晒"><a href="#面部防晒" class="headerlink" title="面部防晒"></a>面部防晒</h3><ul><li>安热沙金瓶</li><li>苏菲娜透美颜美白日间倍护防护乳（蓝蕾丝）</li></ul><h3 id="身体防晒"><a href="#身体防晒" class="headerlink" title="身体防晒"></a>身体防晒</h3><ul><li>近江兄弟 SPF50 PA++++</li><li>曼秀雷敦新碧双重水感防晒霜 spf50 PA++++</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 军训 </tag>
            
            <tag> 购物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存诊断循环运行、无法停止的解决办法</title>
      <link href="/post/2020-07-19_memory-diagnostics-tool-loop-cant-stop/"/>
      <url>/post/2020-07-19_memory-diagnostics-tool-loop-cant-stop/</url>
      
        <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><ul><li><p>运行“Windows内存诊断”，重启后进入pre-OS诊断。</p></li><li><p>但是在进度条跑满后没有重启进入系统，而是再次从0开始了诊断。F1、F10、Tab等界面上提到的按键和选项都无法使内存诊断恢复正常。</p></li><li><p>正常情况下，使用ESC键可以直接退出诊断。但是此时只会让诊断重新开始，就像是“刷新了一下屏幕”一样。</p></li></ul><h2 id="问题搜索"><a href="#问题搜索" class="headerlink" title="问题搜索"></a>问题搜索</h2><ul><li>百度无法快速找到相关信息</li><li>使用谷歌得到以下两个链接：</li></ul><p><a href="https://answers.microsoft.com/en-us/windows/forum/all/windows-memory-diagnostic-tool-loop/d2776240-684f-4ac9-857f-d0652ebaa711">Windows memory diagnostic tool loop</a></p><p><a href="https://www.sevenforums.com/performance-maintenance/244863-windows-memory-diagnostics-stuck-loop-cant-stop.html">Windows 7: Windows Memory Diagnostics stuck in loop and cant stop it!</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>Good explanation here: Artur’s tech support blog: Windows memory diagnostic stuck in the loop</p><p>Try booting your Install DVD, take the Repair path then Command Prompt. See if</p><p>bcdedit &#x2F;bootsequence {memdiag} &#x2F;remove</p><p>as described in the above article will work from there.</p></blockquote><p>使用安装光盘还是PE都是一样的，只要在另一个系统里有命令提示符可以用就行了</p><p>BCDTICE没有找到这条启动信息</p><p>但是亲测有效</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> windows </tag>
            
            <tag> 内存诊断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020江苏高校综合评价面试笔记</title>
      <link href="/post/2020-07-18_jiangsu-comprehensive-evaluation-interview/"/>
      <url>/post/2020-07-18_jiangsu-comprehensive-evaluation-interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先要说明的是，2020届是江苏传统高考的最后一届。虽说综评不是三门总分，但是本博文依旧不能保证其完全的时效性。还请继续关注哔哩哔哩&#x2F;知乎等平台的经验分享。</p></blockquote><h2 id="分享-7分钟搞定复旦综评面试-这些雷点你踩了吗？【宇航员同学】"><a href="#分享-7分钟搞定复旦综评面试-这些雷点你踩了吗？【宇航员同学】" class="headerlink" title="分享|7分钟搞定复旦综评面试 这些雷点你踩了吗？【宇航员同学】"></a>分享|7分钟搞定复旦综评面试 这些雷点你踩了吗？【宇航员同学】</h2><ul><li>自我介绍，英语版</li><li>会被打断，正常</li><li>问题有关填报的专业，<strong>要知道一些别人不知道的</strong>；问题有关老师自己的专业；对综评论文进行提问，<strong>为什么</strong>要做这个项目、<strong>获得什么体验</strong>、担当什么工作</li><li><strong>惯有的问题库</strong>抽问题，如三个字概括高中生活、展望大学生活</li></ul><h2 id="综合评价笔面试如何准备？看这一期就够了！"><a href="#综合评价笔面试如何准备？看这一期就够了！" class="headerlink" title="综合评价笔面试如何准备？看这一期就够了！"></a>综合评价笔面试如何准备？看这一期就够了！</h2><ul><li>学科相关创新题</li><li>开放性、讨论性话题</li><li>选择大学影响最大的人或因素</li><li>对时事的关注，能否形成<strong>个人的观点</strong>，能否对观点<strong>清晰的表达</strong>，沟通和倾听的能力</li><li><strong>各个角度去分析</strong>，有逻辑性，往熟悉的方向引</li><li>不能面面俱到的话，选简洁明确的观点</li><li>开头观点、综上所述</li><li>新冠，线上教育</li><li>（扯到<strong>具体</strong>概念）</li><li><strong>5G，云，大数据</strong></li><li><strong>提前思考争议性话题</strong>，如何对待某个产业，产业态势</li><li>思考题目<strong>可能的考查意图</strong>，<strong>把自己放在情境里</strong></li><li><strong>时事相关、观点表达、学科知识、生活感悟</strong></li><li>不用担心正误，<strong>要有一个观点出来</strong></li></ul><h2 id="江苏综合评价南京信息工程大学面试经验分享"><a href="#江苏综合评价南京信息工程大学面试经验分享" class="headerlink" title="江苏综合评价南京信息工程大学面试经验分享"></a>江苏综合评价南京信息工程大学面试经验分享</h2><ul><li><strong>思辩</strong>，<strong>深入题目内部</strong>，<strong>细化</strong></li><li><strong>两个题六分钟</strong>，把握时间</li><li>时长长，可以带<strong>纸质材料</strong></li><li>细节，<strong>校训，师资力量</strong></li><li>逻辑思维、表达能力，<strong>分点</strong>，辩证</li><li><strong>生活常识，日常物理知识积累</strong>（螺母六个角）</li><li><strong>王牌专业气象</strong>（全球气候变暖、海平面上升）</li><li><strong>现代科技、现实生活的辩证认知</strong>（无人驾驶，舆论，道德冲击）</li><li><strong>随机抽查</strong>问题，<strong>达到六分钟回答</strong>的考生可能会被抽到</li></ul><h2 id="面试官希望你怎么样做自我介绍？面试官示范给你看"><a href="#面试官希望你怎么样做自我介绍？面试官示范给你看" class="headerlink" title="面试官希望你怎么样做自我介绍？面试官示范给你看"></a>面试官希望你怎么样做自我介绍？面试官示范给你看</h2><ul><li><p>与应聘岗位相关的经历有哪些</p></li><li><p>为什么能够胜任这个岗位的工作</p></li><li><p>为什么要应聘这个岗位（求职动机）</p></li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li><p><del>仅仅只介绍学校和专业</del> 满足岗位要求的三个优势和亮点。如果没有直接的，要突出满足岗位要求的潜力在哪</p></li><li><p>对岗位的理解和自己清晰的职业规划，表示自己愿意长期从事这个工作</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote><p>面试官好，我叫李建华，来自武汉大学计算机学院。华为公司是我们一直非常尊敬的公司，这一次呢我应聘的是网络研发的工作。从事网络相关的工作呢，是我一直的梦想。为此呢在研究生阶段呢，我很早就结合岗位的要求进行了准备，包括对各种协议的熟悉、常用算法的实践等。在两年的时间里面呢，我也重点选择了网络相关的课题进行了研究。希望能够加入公司从事网络相关的这个工作，谢谢。</p></blockquote><h3 id="个人稿"><a href="#个人稿" class="headerlink" title="个人稿"></a>个人稿</h3><blockquote><p>面试官好，南信大是我一直非常尊敬的大学，这次我报考的是网络安全的专业。从事网安是我自高中以来的梦想，为此我早在高一就结合技能要求进行了准备，包括KaliLinux内工具的使用、定期关注Freebuf和i春秋CTF等。三年的时间里，我也多次在局域网进行了实战，指引学校信息中心规避了永恒之蓝等风险。希望能够加入南信大继续网安的学习，谢谢。</p></blockquote><h2 id="南信大面试日程"><a href="#南信大面试日程" class="headerlink" title="南信大面试日程"></a>南信大面试日程</h2><h3 id="7月11日报到安排"><a href="#7月11日报到安排" class="headerlink" title="7月11日报到安排"></a>7月11日报到安排</h3><ul><li><p>准考证尾号为双号：7月11日12：30-16：00</p></li><li><p>佩戴口罩，出示“苏康码”和准考证，并接受体温检测</p></li><li><p>报名材料原件（报名表原件和报名条件对应的证明材料原件）、个人健康承诺书、准考证、身份证</p></li><li><p>入校校门：东苑东门、东苑南门、东苑北门；报到地点：东苑体育馆。可自行熟悉校园环境</p></li></ul><h3 id="7月12日考核安排"><a href="#7月12日考核安排" class="headerlink" title="7月12日考核安排"></a>7月12日考核安排</h3><ul><li><p>入校时间：下午场 12：00-13：00；检录时间：下午场 13：00-13：40；<br>考生持本人身份证、准考证（加盖审核通过章）按时到准考证上指定教室检录</p></li><li><p>考试时间：下午场14:00-18:30；考核地点：中苑明德楼N109&#x2F;候考区3，由东苑东门、东苑南门、东苑北门进入测试区域</p></li><li><p>考核方式：综合面试，主要考查考生的基础知识、创新潜质、综合运用知识分析和解决问题的能力以及语言表达能力等</p></li><li><p>考核流程：检录入场→系统抽签→候考区（看题）→面试→结束离场（按规定线路）</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>不得携带手机</li><li>离开休息区时个人物品只能放于候考区</li><li>严禁提到个人信息</li><li>关注自己的抽签批次</li><li>经考务人员同意后，方可到指定的卫生间</li><li>13:40后学生禁止入场</li><li>考核时间最长可能需要5个多小时</li></ul><h2 id="面试后续"><a href="#面试后续" class="headerlink" title="面试后续"></a>面试后续</h2><p>虽说本人从初三起就在折腾物竞，但是最终仍然只是拿了一个省三（捂脸哭）。所以综评能选报的学校也只是南信大级别的。</p><p>用聊天记录来叙述面试的过程</p><p>面试题分两题，第一题有关城市内涝和排水系统，第二题有关人工智能和人类智慧。</p><p><img src="https://static.pil0txia.com/picgo/22a82f5386b7bb33.png"></p><p><img src="https://static.pil0txia.com/picgo/63886b39acc758be.png"></p><p>还好，今天出了分，95.2。下午场以89.8为录取线。怎么说，这算是有一所保底的学校了是吧？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 江苏 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欲望随感</title>
      <link href="/post/2020-06-28_desire-essay/"/>
      <url>/post/2020-06-28_desire-essay/</url>
      
        <content type="html"><![CDATA[<p>可我觉得欲望是个好东西，只要它能给予生活充盈的幸福感和不竭的奋斗源泉。</p><p>比如说，我在购物时的欲望可以用一个长句表示为：“没有一个严格的预算，有一个大致的心理价位区间，在寻找各品牌各型号的最佳性价比产品的过程中，如果该产品的价格略高于自己的心理价位，只要我觉得它很值，我也会在一个更加严格的比较中接受它；更多情况下，满足性能需求的产品价格可以落在心理价位区间的中下层，令人喜出望外”</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欲望 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to be a Better Liar</title>
      <link href="/post/2020-06-20_How-to-be-a-Better-Liar/"/>
      <url>/post/2020-06-20_How-to-be-a-Better-Liar/</url>
      
        <content type="html"><![CDATA[<h2 id="你可以说谎，但你不能把我当傻子"><a href="#你可以说谎，但你不能把我当傻子" class="headerlink" title="你可以说谎，但你不能把我当傻子"></a><a href="%5B%E5%9B%BE%E7%89%87%5Dhttps://zhuanlan.zhihu.com/p/23609374">你可以说谎，但你不能把我当傻子</a></h2><h3 id="越是说的信誓旦旦，越要留个心眼"><a href="#越是说的信誓旦旦，越要留个心眼" class="headerlink" title="越是说的信誓旦旦，越要留个心眼"></a>越是说的信誓旦旦，越要留个心眼</h3><h3 id="撒谎的人表情动作都可以演得真，但是眼神做不了假"><a href="#撒谎的人表情动作都可以演得真，但是眼神做不了假" class="headerlink" title="撒谎的人表情动作都可以演得真，但是眼神做不了假"></a>撒谎的人表情动作都可以演得真，但是眼神做不了假</h3><p>看对方眼睛里的表情和脸上摆出来的表情是不是一致。<br>比如，你看对方对你微笑，寒暄，传达真诚，但是他的眼睛没有在笑。怎么看眼睛有没有笑？真诚的笑，会有鱼尾纹。</p><h3 id="真实的情绪会从一而终，而撒谎的人会变换立场来掩盖真相"><a href="#真实的情绪会从一而终，而撒谎的人会变换立场来掩盖真相" class="headerlink" title="真实的情绪会从一而终，而撒谎的人会变换立场来掩盖真相"></a>真实的情绪会从一而终，而撒谎的人会变换立场来掩盖真相</h3><p>骗子不会有这么强烈直观，贯穿始终的情绪，他所有的情绪会根据环境的不同而变化，目的就是为了掩盖自己的谎言。<br>所以除了“我没有撒谎”这一立场之外，骗子没有其他坚定的立场。<br>耿直真诚的人会更容易嫉恶如仇，立场鲜明。那些和稀泥的，大都是伪君子。</p><h3 id="骗子会严格按照时间顺序来编造谎言，会在一些不着边际的细节编造更多的信息"><a href="#骗子会严格按照时间顺序来编造谎言，会在一些不着边际的细节编造更多的信息" class="headerlink" title="骗子会严格按照时间顺序来编造谎言，会在一些不着边际的细节编造更多的信息"></a>骗子会严格按照时间顺序来编造谎言，会在一些不着边际的细节编造更多的信息</h3><p>骗子为了让人相信他，很在意时间逻辑上的连贯性，而且会特意编造一些细节来掩盖事实，有所准备。而没撒谎的不会是这样。</p><h3 id="最后一个杀手锏，教你识别最危险的一个表情，避免伤害，这个表情叫：轻蔑"><a href="#最后一个杀手锏，教你识别最危险的一个表情，避免伤害，这个表情叫：轻蔑" class="headerlink" title="最后一个杀手锏，教你识别最危险的一个表情，避免伤害，这个表情叫：轻蔑"></a>最后一个杀手锏，教你识别最危险的一个表情，避免伤害，这个表情叫：轻蔑</h3><p>其标识就是，一边的嘴角向上并往里收起。<br>这是人类脸上唯一一个不对称的表情，只要看到对方轻蔑的表情，不管你们之前谈得多热络，你都得拉响警报，反向思考。无论是谁，在什么场合，赶紧开启警觉模式。</p><hr><h2 id="如何说谎"><a href="#如何说谎" class="headerlink" title="如何说谎"></a><a href="https://zhuanlan.zhihu.com/p/68807613">如何说谎</a></h2><p>你要说谎，就要先想象一个真实的人，然后把自己代入这个人，你才能保证你的慌是没有破绽的。<br>这种说谎方法的本质是，找到一个真实的东西，然后把其中一两个要素替换了，只圆这一两个要素的谎，其他部分，全部用真实的逻辑来对照。这样自相矛盾的机会就会低很多，因为真实的东西的逻辑破绽比人脑的破绽少得多。</p><h2 id="如何完美地撒谎？"><a href="#如何完美地撒谎？" class="headerlink" title="如何完美地撒谎？"></a><a href="https://www.zhihu.com/question/44649695">如何完美地撒谎？</a></h2><p>完美撒谎的重要一点就是少撒谎甚至不撒谎，尽量做到诚实，这是我读了《鹿鼎记》学到的。<br>但是在诚实的表达的过程中，要有意无意的隐瞒或者替换掉一些重要项，让事情看起来完全不同。<br>我们首先要明白，我们撒谎的目的是什么。<br>我记得我高中的时候，有个女孩子写的一篇关于向日葵文章，她说的意思是：为了保护背部柔软的部分，向日葵总是把正面面对着太阳。<br>这个说法让我一下子明白了撒谎的真谛：撒谎的目的不是为了让对方相信我说的是真的，而是为了隐藏真相不让他知道，故意让他误解。</p><h3 id="第一个：矛盾转移。"><a href="#第一个：矛盾转移。" class="headerlink" title="第一个：矛盾转移。"></a>第一个：矛盾转移。</h3><p>小孩子撒谎很拙劣，总是一句“我作业忘带了”，并且总是要再三的辩解让老师相信自己真的忘记带了，结果碰到牛逼的老师“我相信你忘带了，但是没带也要惩罚，你先补写一份，明天再把忘带的带过来。”搬起石头砸自己的脚。<br>换做是我，我会随便拿出一个以前的练习或者作业，拿出来滥竽充数，自然会被抓出来，但是这个矛盾就变成：我没记清楚作业是什么，写错作业了，而不是不是我没写作业。当然，被要求补写作业是少不了的，但是不会因为没写而挨罚。</p><h3 id="第二个：揣摩对方的心思，以退为进。"><a href="#第二个：揣摩对方的心思，以退为进。" class="headerlink" title="第二个：揣摩对方的心思，以退为进。"></a>第二个：揣摩对方的心思，以退为进。</h3><p>举个简单的例子，我有一次在火车上，看到一个父亲在和两三岁的姑娘闹着玩，结果姑娘不小心，给老父的脸色挖了两道血印，就像两口子打架被抓破了脸一样。<br>我当时就想，如果他上班后他的同事问他的脸怎么了，他如实回答是被女儿抓破的，别人多半不信，会认为他和媳妇打架让挖破了脸。如果他直接笑着说：还不是和家里的母老虎打架，一个不小心让抓了一把，好在也没吃大亏。他这么说的时候，别人会多半不相信他和媳妇打架了，考虑到他有小孩子，又会猜测他多半是吹牛，肯定是和女儿闹着玩被抓了。<br>我觉得人性总是恶的，总会带着恶意去揣摩别人，当然，你要是就顺着他想的说，他又多半不会相信你说的。人性里更多疑。</p><h3 id="第三个：明显撒谎，留下小破绽，让对方发现。"><a href="#第三个：明显撒谎，留下小破绽，让对方发现。" class="headerlink" title="第三个：明显撒谎，留下小破绽，让对方发现。"></a>第三个：明显撒谎，留下小破绽，让对方发现。</h3><p>我想去苏州参加周天前女友的婚礼，但是媳妇肯定会不高兴，最简单的办法就是借着出差的名义去，可是公司从来没有过周末需要出差的先例，怎么办。<br>我买了周六到上海（平时出差常去）的高铁票，告诉媳妇，我周末要去趟上海，车票都买好了。媳妇当时就问，怎么周末还要去出差。我回复说，才不呢，我要去参加前女友的婚礼。媳妇愣了一下就笑了，你前任不是在苏州么，你跑上海去参加婚礼？我回复：你咋知道她没嫁到上海或者我不会到上海了再坐车去苏州啊。媳妇的回复是：去吧去吧，最好去了别回来。<br>我说的全是实话，但是媳妇不相信我，她自己聪明的认为我是去上海出差了，就算以后东窗事发，也不是我撒谎。<br>撒谎是个技术活，说实话更是个技术活。不管是撒谎还是说实话，我们的目的都是为了让对方相信一些事或者不相信一些事。人都是固执的，一般不会直接相信别人告诉的答案，而更倾向于相信自己推导出的结果，我在撒谎的时候要做的，就是用事实引导他去推导出一个错误的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 说谎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客存在的意义</title>
      <link href="/post/2020-05-31_how-to-manage-your-personal-website/"/>
      <url>/post/2020-05-31_how-to-manage-your-personal-website/</url>
      
        <content type="html"><![CDATA[<p>个人网站这个以前很时髦的名词正随着时间慢慢被人忘记，互联网的门槛越来越低，个人网站显然不再成为一个重要的入口。甚至连电脑都已经不是首选的上网平台了。</p><p>那么现在还有必要为自己搭建个人网站吗？</p><h2 id="不是人人都有料"><a href="#不是人人都有料" class="headerlink" title="不是人人都有料"></a>不是人人都有料</h2><p>不可否认的是，个人网站由于其具有一定的专业性，所以搭建它是要付出一定的成本的，不论是金钱上的还是时间上的。有成本付出就会有回报的期望。每个坚持写博的人背后肯定有它的动力在支撑，但是我看到的是越来越多的个人博主荒废了它当初付出成本来打理的网站。</p><p>为什么？因为没有人看，一个人写有啥意思，如果只是写写笔记放到本地也可以，速度还更快。你既然选择了放到网上，那么心里肯定还是期望有读者的。但是理想是美好的，现实是残酷的，你写的那些东西就是没人看。</p><h3 id="你不是大明星"><a href="#你不是大明星" class="headerlink" title="你不是大明星"></a>你不是大明星</h3><p>为啥人家徐静蕾一篇文章写几个字“今天好困啊”之类的，就有好几万的评论。你辛辛苦苦码了好几千字，又是配图又是又是写诗，唯一的访问者却只有搜索引擎的爬虫。</p><p>因为你不是 Big Boy ，而网上的访问者具有匿名性，他们基本上跟你生活毫无交集，他们也不关心你去了哪些地方，吃了啥东西。这些事情不能成为谈资，所以如果你希望在个人网站分享这类内容，我建议还是朋友圈，QQ 空间之类的地方比较好。起码还可以得到几个赞。</p><h3 id="专家不是这么好当的"><a href="#专家不是这么好当的" class="headerlink" title="专家不是这么好当的"></a>专家不是这么好当的</h3><p>除了看看明星八卦，大多数网上的意见领袖都是各方面的专家，他们往往可以一呼百应。</p><p>但我始终坚持认为，就算是伪专家也是有他的过人之处的，更不要说真正的大牛了。很多人喜欢写技术文章，但首先你个人是一个默默无闻的路人，即使突然脑袋开窍撸了一篇可称大神级的文章出来，也会被埋没在信息的海洋里。更何况这种情况出现的概率基本为零，大多数情况下一般人写出来的文章就是没啥料的，不具备可读性。</p><p>而且现在还有各种各样的阅读平台，分享网站，以及垃圾站。你网站上的文章还没被爬到，就被他们抓走了，有点良心的还贴个来源链接，无良的直接连作者名都给你改了。</p><h2 id="个人网站如何经营"><a href="#个人网站如何经营" class="headerlink" title="个人网站如何经营"></a>个人网站如何经营</h2><p>这个标题一写出来，网上类似的文章一大把。但我不是从技术角度来讲，我首先要劝一些人放弃，<strong>如果你没有啥好写的东西，那还是放弃这个打算把。</strong>你把精力投入到微博，微信上可能效果还好些。</p><h3 id="你一定要有一些别人没有的东西"><a href="#你一定要有一些别人没有的东西" class="headerlink" title="你一定要有一些别人没有的东西"></a>你一定要有一些别人没有的东西</h3><p>如果你不是在某一方面浸淫多年特别擅长，那么要不然你帅的惊动 D 中央，要不然你特别有钱是个土豪。如果你说，我又没啥特长，长的也一般，也没啥钱，总之就是一个普通的路人，还有希望吗？</p><p>我知道你肯定希望我说出“有”这个字来给你信心，但是真没有。因为大部分人都是这样，别人凭啥去看你？所以经营网站的第一步是经营自己，让自己能够出类拔萃。</p><h3 id="精心准备你的内容"><a href="#精心准备你的内容" class="headerlink" title="精心准备你的内容"></a>精心准备你的内容</h3><p>当然如果你是大明星可以忽略这一点，脑残粉们根本不会在乎您发了什么。。。</p><p>内容是你制胜的关键，可以说在信息化同质严重的今天，内容的重要性不是降低而是升高了。有品位的内容往往能为你吸引来有价值的用户。在这个过程中你也可以获得不少成就感。</p><p>内容的选材也很重要，你需要去了解读者喜欢什么样的内容，既然是公开发表的内容，你就应该照顾别人的想法，这并不是要你埋没个性，相反在内容的组织上展示你的个性才是体现出你闪光点的好办法。</p><p>为什么你看到很多业界大神，总是喜欢写一些普及性的文章。但往往这类文章的点击率是最高的，因为大多数人需要这类文章，而怎么把这类文章写好也是需要挑战性的。深入浅出是一门技术活，很多人写着写着越来越晦涩难懂，不知道怎么样用浅显的道理表达出来。</p><h3 id="快速分享"><a href="#快速分享" class="headerlink" title="快速分享"></a>快速分享</h3><p>这一步反而是大多数人做的最好的，各种分享按钮，微博，朋友圈分发。这样非常好，可以为你带来固定的读者群，但对拓宽读者群体没有多大帮助，我个人觉得可以借助一些业内比较有影响力的分享渠道，当然前提是你的文章真的质量过硬，也要给别人带来好处。比如</p><ul><li><a href="http://v2ex.com/">http://v2ex.com</a></li><li><a href="http://segmentfault.com/">http://segmentfault.com</a></li></ul><p>值得注意的是，你不能把他们当成单纯的发广告的地方，这样会很快透支掉你的口碑。你需要用心经营你自己的品牌，多多形成双赢的局面，为别人网站也能带来干货</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我本人并不是擅长此道的专家，但是因为对这一个圈子接触比较多所以有这些感受。我见过太多怀揣着梦想进入个人网站这个圈子的好少年了，但大多数因为没有认清现实而浪费了很多资源。我这片文章的目的并不可能让大家马上牛逼起来，但如果能让大家稍稍认清点现实，也不枉费我这么多口舌了。</p><blockquote><p>转载自<a href="https://joyqi.com/develop/how-to-manage-your-personal-website.html">https://joyqi.com/develop/how-to-manage-your-personal-website.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 新人的一步到位配置</title>
      <link href="/post/2020-05-29_my-vscode/"/>
      <url>/post/2020-05-29_my-vscode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一步到位是不存在的，日后的磨合和推进必然带来改变。这里的一步到位是对新人而言的——如何让新人觉得自己没有错过什么强大而又唾手可得的好功能，进而将vscode全方位地投入学习与生产。</p></blockquote><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>vscode的一大特色就是拓展。一方面，它的拓展多；另一方面，它的拓展与主程序的沟通不影响全局性能。拓展是看不完的，想要了解热门的拓展有哪些，看这三篇文章就够了：</p><p><a href="https://www.jianshu.com/p/fd945e8e099d">这样配置，让你的VS Code好用到飞起！</a></p><p><a href="https://zhuanlan.zhihu.com/p/62913725">第一次使用VS Code时你应该知道的一切配置</a></p><p><a href="https://zhuanlan.zhihu.com/p/111004160">10款VS Code插件神器，第7款超级实用！</a></p><p>三篇文章互有重合互有补充，挑觉得日后用得到的拓展安装即可。而且要结合<a href="https://zhuanlan.zhihu.com/p/125773296">那些你应该考虑卸载的 VSCode 扩展</a>这篇文章阅读、安装。</p><p>还可以再加上“indent-rainbow”突出显示缩进、“ESLint”代码提示、“prettier”代码格式化、“Path Autocomplete”路径补全、“Power Mode”打字特效、“polacode”将代码生成图片、“IntelliCode”intellisense的AI升级版……</p><p>以上插件初步配置后上传到Github Gist，建议上手使用后继续完善配置</p><h3 id="真正的使用技巧"><a href="#真正的使用技巧" class="headerlink" title="真正的使用技巧"></a>真正的使用技巧</h3><p>当然，真正的使用技巧还是要看的：</p><p><a href="https://zhuanlan.zhihu.com/p/120360684">使用 VSCode 打造一站式全平台开发体验</a></p><p><a href="https://zhuanlan.zhihu.com/p/112431369">Python 编程的最好搭档—VSCode 详细指南</a></p><h3 id="vscode相关"><a href="#vscode相关" class="headerlink" title="vscode相关"></a>vscode相关</h3><p>这是一篇偏技术的多角度分析文章：</p><p><a href="https://blog.csdn.net/sinat_33224091/article/details/102549648">VS Code 为什么能这么牛？</a></p><p>以下是我在寻找vscode文章时发现的<em>不</em>相关阅读：</p><p><a href="https://blog.csdn.net/huaxiangchen/article/details/106050664">全栈工程师为什么越混越困难，看这篇就够了</a></p><p><a href="https://www.zhihu.com/question/280279208/answer/510354868">大家都是如何刷 LeetCode 的？</a></p><p><a href="https://blog.csdn.net/haimianjie2012/article/details/77899728">刷了两遍LeetCode之后，我拿了9个offer</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客写作</title>
      <link href="/post/2020-05-26_blog-writting/"/>
      <url>/post/2020-05-26_blog-writting/</url>
      
        <content type="html"><![CDATA[<h2 id="博客方案"><a href="#博客方案" class="headerlink" title="博客方案"></a>博客方案</h2><p>最为快速入门的博客莫过于<code>WordPress</code>，WP甚至可以是一款CMS。不出意外的话，我的VPS将在充当梯子的同时展示博客。然而，23号提到的<code>v2ray</code>方案目前会占用443端口，影响建站。</p><p>九艺群表示可以使用<code>hexo+github pages</code>发布静态页面</p><p>（当然知道这个法子，一开始我是抗拒的）</p><p>（但是恰逢<code>Notion</code>这么好用的笔记软件的免费和<code>Typora</code>这么好用的Markdown编辑器，似乎hexo也可以接受了）</p><p>（但是的但是，Notion在国内因为我们喜闻乐见的缘故无法打开……）</p><h2 id="写作流程"><a href="#写作流程" class="headerlink" title="写作流程"></a>写作流程</h2><p>PC端<code>Typora</code>写作+<code>PicGo</code>上传图片到<code>七牛云</code>&amp;<code>路过图床</code>+<code>Typora</code>输出md导入hexo生成页面+<code>Github Pages</code>部署页面+<code>Netlifly</code>自动发布，移动端可通过<code>Joplin</code>进行md写作，并使用<code>坚果云</code>与PC端同步笔记。</p><p>值得一提的是，Joplin支持使用第三方外置编辑器如Typora、VIM来编辑笔记。<a href="https://www.iplaysoft.com/typora.html">异次元</a>有上述软件的详细介绍</p><p>七牛云OSS用来储存不在本地留存备份的图片或私密图片，如截图和聊天记录；路过图床用来储存在本地存有备份或者体积偏大的图片，如画集和相机拍下的照片<br>现在好像真的是一直在用<code>你的日记</code>写博客啊orz，好多技术文档（笑），考完就要着手将具有参考和查阅价值的文章用markdown发布，这个日记迟迟没有tag和搜索简直磨人</p><p>markdown适合面向自己的个人写作，博客适合面向游客的内容展示，而面向工作组演示的成型文章则需要<code>幕布</code>（支持md的大纲笔记，支持生成为思维导图，免费版对样式和条目数量有限制）或<code>XMind</code>（各种各样的思维导图）</p><h2 id="部署-amp-配置"><a href="#部署-amp-配置" class="headerlink" title="部署&amp;配置"></a>部署&amp;配置</h2><h3 id="hexo和github配置："><a href="#hexo和github配置：" class="headerlink" title="hexo和github配置："></a>hexo和github配置：</h3><p><a href="https://blog.csdn.net/qq_27754983/article/details/76143478">Windows下，Hexo+GitHub搭建博客</a></p><p><a href="https://www.cnblogs.com/wenbinjiang/p/11062959.html">npm install卡顿问题记录</a></p><h3 id="netlifly配置："><a href="#netlifly配置：" class="headerlink" title="netlifly配置："></a>netlifly配置：</h3><p><a href="https://www.cnblogs.com/37Y37/p/12551839.html">Github Pages访问太慢？通过Netlify免费加速</a></p><h3 id="typora教程："><a href="#typora教程：" class="headerlink" title="typora教程："></a>typora教程：</h3><p><a href="https://sspai.com/post/54912">Typora 完全使用详解</a></p><p><a href="https://blog.csdn.net/weixin_42648261/article/details/105219971">Typora+markdown 最常用语法教程（by 程序员宝藏）</a></p><p><a href="https://www.jianshu.com/p/a6a6a22e9393">Typora极简教程</a></p><h3 id="hexo文章URL优化："><a href="#hexo文章URL优化：" class="headerlink" title="hexo文章URL优化："></a>hexo文章URL优化：</h3><h4 id="法一：自定义urlname字段"><a href="#法一：自定义urlname字段" class="headerlink" title="法一：自定义urlname字段"></a>法一：自定义urlname字段</h4><p>文章标题肯定会包含中文，本地文件名为了其它应用搜索与查阅的方便也会是日期+中文，转义后会对SEO产生影响，而且默认的“&#x2F;”路径层级太多，同样不利于SEO，所以需要另设URL。</p><p><a href="https://blog.csdn.net/jingbin_/article/details/80617210">hexo permalink设置技巧</a></p><p><a href="https://hexo.io/zh-cn/docs/permalinks.html">永久链接(Permalinks) | Hexo</a></p><p>所以，将<code>_config.yml</code>中的<code>permalink</code>设为<code>post/:year-:month-:day_:urlname/</code>或<code>post/:year-:month-:day-:urlname/</code>，然后在<code>scaffolds/post.md</code>模板文件中添加<code>urlname:</code>（<code>categories:</code>和<code>tags:</code>当然也要添加），写文章时<code>urlname</code>可以写为<code>set-hexo-permalink</code>这样的形式，得到的URL就是<a href="http://xxx.com/post/2020-5-29_set-hexo-permalink/">http://xxx.com/post/2020-5-29_set-hexo-permalink/</a></p><h4 id="法二：使用插件"><a href="#法二：使用插件" class="headerlink" title="法二：使用插件"></a>法二：使用插件</h4><p><a href="https://hexo.io/zh-cn/docs/front-matter">hexo官方文档《Front-matter》</a>也表示permalink是可以覆盖文章网址的，但是是全路径，不方便</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>没准备上一个极简的主题，毕竟一开始是做了WP的准备的</p><p>Butterfly （最平衡）</p><p>Nexmoe （生成老婆列表可还行hhh）</p><p>Diaspora （2020-5-31第一次部署正在使用，内容排布可能比较宽松）</p><p>Ayer （同样有全屏欢迎页）</p><p>Yun （点击特效很入眼）</p><hr><h2 id="2020-6-1更新："><a href="#2020-6-1更新：" class="headerlink" title="2020-6-1更新："></a>2020-6-1更新：</h2><p>网易云音乐上嗅探出来的音乐链接会过期，堆爱外链不可用。本来准备传进七牛的，但是七牛的HTTPS流量不计入免费额度；又拍云又需要额外的链接和LOGO；<code>BackBlaze B2</code>要使用免费流量就需要用Cloudflare，CF在国内的速度……<br>SM.MS的图片加载速度能接受，有5G空间限制<br>路过图床的10M&#x2F;单张、不限空间很赞，但是图片加载速度一般，而且存在跨域问题<br><code>postimage</code>速度杠杠的，国内别被墙就好<br><code>Github+jsDelivr+PicGo</code>方案就稳得多，就是上传速度略慢</p><p>参考：<br><a href="https://sspai.com/post/55032">无需注册、打开即用，这 8 个免费好用的图床工具值得一试</a><br><a href="https://blog.csdn.net/qq_36759224/article/details/98058240">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a><br><a href="https://www.v2ex.com/t/671482">将一些正在自用的资源加速服务开放出来（Jsdelivr、gFonts、Unsplash、Pexels）</a><br><a href="https://www.v2ex.com/t/498919">大厂都有哪些技术博客？</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
            <tag> Joplin </tag>
            
            <tag> Github </tag>
            
            <tag> Netlify </tag>
            
            <tag> v2ray </tag>
            
            <tag> 七牛云 </tag>
            
            <tag> 图床 </tag>
            
            <tag> Notion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali Linux 从物理磁盘向虚拟机部署</title>
      <link href="/post/2020-05-25_kali-linux-clone-from-hdd-to-vm/"/>
      <url>/post/2020-05-25_kali-linux-clone-from-hdd-to-vm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一开始尝试kali时，因为手上没有闲置的硬盘，也不想为了win和linux在一块硬盘上共存而迎接大量不可知的维护问题，故以硬盘安装方式安装进了一块32G的U盘。</p><p>livecd方式无法保留更改，被我当做急救盘使用；persistence模式下曾遇到一些看上去很离奇的问题，虽说都已一一解决，但是出现问题的原因和解决方案都需要大量的翻阅查询，远远超过了应有的学习成本。</p></blockquote><h3 id="第三方备份系统：Clonezilla（推荐）"><a href="#第三方备份系统：Clonezilla（推荐）" class="headerlink" title="第三方备份系统：Clonezilla（推荐）"></a>第三方备份系统：Clonezilla（推荐）</h3><p>先在已有的物理磁盘里完成一切软件&#x2F;系统升级工作，并用clonezilla创建备份文件。然后可以直接使用已有的clonezilla-live-2.6.6-15-amd64.iso创建新虚拟机，并添加含有备份文件的客户机硬盘，进行还原。</p><hr><p>2020-8-15更新：</p><p>还原kali时，也可以创建虚拟机时选择空硬盘，然后配置虚拟机从CD-ROM启动clonezilla镜像</p><p>添加本机分区&#x2F;移动硬盘分区失败（设备被占用），插入U盘并向VM挂载失败（clonezilla报错，无分区）</p><p>将U盘插在另一台PC上，使用SSH远程连接方式，可用。</p><p>如果克隆后无法启动，需要在livecd终端输入<code>blkid</code>或<code>ls -l /dev/disk/by-uuid</code>（通常后者比较有效），并将新的UUID写入<code>/etc/fstab和/boot/grub/grub.conf</code></p><h3 id="在系统运行时创建镜像"><a href="#在系统运行时创建镜像" class="headerlink" title="在系统运行时创建镜像"></a>在系统运行时创建镜像</h3><p>目前而言，也可以使用systemback或respin封装成ISO。</p><p>respin不支持生成大于4G的ISO，本轮出局。</p><p>systemback生成大于4G的ISO可以通过<a href="https://www.moewah.com/archives/2756.html">使用 SystemBack 为 Debian &#x2F; Ubuntu 创建系统备份</a>下的<a href="https://community.bwbot.org/topic/194/%E8%A7%A3%E5%86%B3systemback-%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E8%B6%85%E8%BF%874g%E7%9A%84iso%E7%9A%84%E9%97%AE%E9%A2%98">解决systemback 无法生成超过4G的iso的问题</a>一文解决。</p><p>ISO文件日后还能用rufus烧录成livecd</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kalilinux </tag>
            
            <tag> 运维 </tag>
            
            <tag> 物理磁盘 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web端那些很二次元的二次元游戏</title>
      <link href="/post/2020-05-22_web-ACG-games/"/>
      <url>/post/2020-05-22_web-ACG-games/</url>
      
        <content type="html"><![CDATA[<p>MikuTap</p><p><a href="https://aidn.jp/mikutap/">https://aidn.jp/mikutap/</a></p><p>Wowa<br><a href="https://aidn.jp/wowa">https://aidn.jp/wowa</a></p><p>AI Gahaku<br><a href="https://ai-art.tokyo/en/#/">https://ai-art.tokyo/en/#/</a></p><p>PixelMe<br><a href="https://pixel-me.tokyo/en/">https://pixel-me.tokyo/en/</a></p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 二次元 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件服务器进化——个人工作站文件管理</title>
      <link href="/post/2020-05-16_file-server-upgrade/"/>
      <url>/post/2020-05-16_file-server-upgrade/</url>
      
        <content type="html"><![CDATA[<h2 id="进化路线"><a href="#进化路线" class="headerlink" title="进化路线"></a>进化路线</h2><ul><li><code>FTP/SFTP/FTPS</code>→<code>Webdav</code></li><li>Webdav采用HTTP连接，性能更好，也可以代替FTP，少装一个Serv-U</li></ul><h2 id="可选功能"><a href="#可选功能" class="headerlink" title="可选功能"></a>可选功能</h2><ul><li>P2P内网穿透：<code>ZeroTier</code>（国内可能需要<code>Moon</code>中转流量）</li><li>私有云（替代Serv-U）：<code>NextCloud</code>（相比<code>Serv-U</code>，前端功能更多；相比<code>Seafile</code>的分布式文件储存，在文件编辑和本地管理上更有优势）</li><li>将网络硬盘（Webdav&#x2F;FTP等）映射至资源管理器：<code>RaiDrive</code>（Windows，<a href="https://www.v2ex.com/amp/t/656523">V2EX</a>内有最后一个免费版本，已存于百度网盘）；<code>ES文件浏览器</code>&#x2F;<code>Cx File Explorer</code>（Android）</li><li>轻量化临时http文件服务器：<code>Cute Http File Server</code></li><li>轻量化http文件服务器：<code>File Browser</code>&#x2F;<code>Caddy</code>（可被<code>NextCloud</code>代替）</li><li>轻量化Webdav文件服务器：<code>Parkomat</code>（<code>NextCloud</code>支持Webdav，这个也用不到）</li></ul><h2 id="初步部署方案"><a href="#初步部署方案" class="headerlink" title="初步部署方案"></a>初步部署方案</h2><p>鉴于物理机是Windows主力机，而且应用场景有点像是有个前端的FTP，是基于本机数据的文件服务，还要挂在后台不能占用大量资源，所以目前NextCloud有两个方案：一，<code>NextCloud VM 40G +挂载本机硬盘 +软链接</code>（不确定是否能挂，因为Hansson的2T版本是收费的）；二，<code>Vmware +Xubuntu LTS +NextCloud SNAP +挂载本机硬盘</code>（这个肯定能挂，而且Xubuntu功能完整也不占用大量资源，除了NextCloud还可以充当主力Linux机；SNAP安装方式更加快捷）<br>但是SNAP有一个问题：参考<a href="https://blog.csdn.net/ccahe/article/details/98055388">ubuntu 1810上snap安装nextcloud</a>，www软件和数据会被隔离开来，比如这样：<code>/var/snap/nextcloud/14827/nextcloud/config</code>，这就很dirty。也许基于LAMP手动安装会更好？<br>然而nextcloud不能直接实时显示本地物理目录，只能对上传的文件进行管理，要添加新增的本地文件需要使用<code>OCC</code>命令。而且<code>caddy</code>也是支持webdav的，<code>caddy2</code>的正式版也刚刚发布，<code>file_server</code>同样强大，还有<code>xcaddy</code>可以安装拓展。caddy走起</p><hr><h2 id="部署尝试"><a href="#部署尝试" class="headerlink" title="部署尝试"></a>部署尝试</h2><p>……caddy2失败了，webdav不说，连基础的fileserver都无法正常访问；caddy1的filemanager早已下线，光有一个webdav可不够用<br>chfs的HTTP实现了，但是webdav显示<code>no authorized</code><br>又发现了可道云和filerun，后者是直接对本地目录管理的，源自nextcloud；前者无需数据库、可以<code>mklink</code>管理本地目录（参考<a href="http://bbs.kodcloud.com/d/34">在Windows系统下将网盘目录进行不同的映射</a>），功能都很强大，可以继续前进</p><h2 id="部署成功"><a href="#部署成功" class="headerlink" title="部署成功"></a>部署成功</h2><p>昨日可道云成功配置上线，但是就算抛开无法良好管理本地文件的问题，一使用就发现了很多离奇的bug，比如桌面轻应用成群消失，特别是，更改默认储存时迁移数据报错，进而影响用户文件夹，添加的软链接也无法识别。不过他的在线图片浏览还是很不错的<br>今日FileRun成功上线，完成了初步配置，可以直接管理本地目录，webdav工作正常。但是语言文件因为编码的问题，上传后出现乱码，加之本身汉化的不太准确，新的文件暂时就不上传了，以后可以自己修正汉化。<br>今日临时添加的计划是为楼上604的500G硬盘建立FTP服务，并通过raidrive连接到本地资源管理器，分担250G SSD负担。小型即时使用体验良好，但是在迁移大量数据&#x2F;小文件时屡屡中断。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> webdav </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> 私有云 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌娘百科中的本子</title>
      <link href="/post/2020-05-07_moegirl-h/"/>
      <url>/post/2020-05-07_moegirl-h/</url>
      
        <content type="html"><![CDATA[<p>在萌娘百科<code>E-Hentai</code>词条的外部链接中发现了<a href="https://hoochanlon.github.io/fq-book/#/">这本书能让你连接互联网 Ⅱ</a>，很完整全面实用，其中又有《突破Dr.com校园网客户端对于热点和路由器的限制》，同样实用</p><p>当然，萌娘百科的这个词条是从<code>本子</code>链入的，同级的词条还有<code>哔咔哔咔</code>，其中有哔咔的镜像地址，可以下载客户端</p><hr><p>除昨天的哔咔哔咔之外</p><p>又发现了……<code>acghouse.com</code></p><p><code>Hiten Illustration Book Vol.2</code>的400M+版本是未拆本扫描版，中缝的存在致使它无法成为桌面。在这个站（币完全够用啊！）找到一个300M+版本，下下来看看还有没有缝了……</p><p>（次日，没有缝；次次日，发现同样超一流画师<code>Anmi</code>；周末，壁纸出炉）</p><hr><p>又又发现了<code>aecy.cc</code></p><p>又又又找到了<code>zuiacg.moe</code>、<code>moetu.club</code>、<code>bbsmcx.com</code></p><p>在大量作品的冲击下……果然，本子看剧情，漫画看肉吗……</p><p>又有：里番看剧情，表番看肉</p>]]></content>
      
      
      <categories>
          
          <category> ACG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次元 </tag>
            
            <tag> 本子 </tag>
            
            <tag> 萌娘百科 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赏心悦目的系统主题也是生产力</title>
      <link href="/post/2020-04-30_sys-theme/"/>
      <url>/post/2020-04-30_sys-theme/</url>
      
        <content type="html"><![CDATA[<p>很久以前就认识了<code>致美化</code>这个专注系统美化的网站，不过那时它的主题大多要币，而且在系统更新后有闪屏风险，我就只是挑选了些动态壁纸。这两天逛<code>423down</code>时看见<code>StartIsBack</code>，效果出人意料地不错，透明居中任务栏进一步配上致美化的<code>渐变流浪者</code>壁纸，确实少女气息满满——</p><p><img src="https://static.pil0txia.com/picgo/bandicam%202020-05-01%2018-17-26-057.jpg"></p><p>不过这只是桌面的效果，资源管理器还是老样子。又看到它的主题大多开始只支持新版本（1903至目前未正式发布的2004），看上去稳定性有所提升，加之自己目前的PC因为C盘容量太小一直无法进行大版本更新（仍为1803），而且吾爱破解论坛也有很多公开的会员主题，遂创建系统还原点大胆一试。效果出奇的好——</p><p><img src="https://static.pil0txia.com/picgo/bandicam%202020-05-01%2021-13-48-743.jpg"></p><p><img src="https://static.pil0txia.com/picgo/bandicam%202020-05-01%2021-22-34-075.jpg"></p><p><img src="https://static.pil0txia.com/picgo/bandicam%202020-05-01%2021-24-13-129.jpg"></p><p><img src="https://static.pil0txia.com/picgo/bandicam%202020-05-01%2021-30-20-892.jpg"><br>（陶瓷灰 Porcelain UP3）</p><hr><p>这里记下一些个人认为比较协调搭配的主题：（截至今日，标注版本号的都是最新版本）</p><h3 id="少女感"><a href="#少女感" class="headerlink" title="少女感"></a>少女感</h3><p>彩艺（开始菜单很好看，图标和资源管理器的白色很协调，已有UP2、图标）<br>水果色（任务栏图标不合并，能同时显示的任务会更少，或许我会推荐给他人）<br>甜美（任务栏很有特色，已有UP2.5）</p><h3 id="白色调"><a href="#白色调" class="headerlink" title="白色调"></a>白色调</h3><p>陶瓷灰（这个白色很有陶瓷色泽，已有UP3、图标）<br>灰白（质量和陶瓷灰一样高，色彩更趋于统一的奶白色，已有UP3）<br>素白</p><h3 id="温馨色调"><a href="#温馨色调" class="headerlink" title="温馨色调"></a>温馨色调</h3><p>蓝调（蓝色有点深，但是很热门？已有UP6）<br>简欧粉橘（这个可以长期用诶，和不同风格的壁纸都很搭，比如二次元）</p><h3 id="科技感"><a href="#科技感" class="headerlink" title="科技感"></a>科技感</h3><p>Jarvis（……装那啥才用的吧，已有UP6）</p><h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p>月光沙丘（已有）<br>渐变流浪者（已有）</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell脚本弹窗的方法汇总</title>
      <link href="/post/2020-01-07_powershell-popup/"/>
      <url>/post/2020-01-07_powershell-popup/</url>
      
        <content type="html"><![CDATA[<h2 id="Powershell弹出窗口"><a href="#Powershell弹出窗口" class="headerlink" title="Powershell弹出窗口"></a>Powershell弹出窗口</h2><h3 id="2020-1-7"><a href="#2020-1-7" class="headerlink" title="2020-1-7"></a>2020-1-7</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一:"></a>法一:</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ws</span> = <span class="built_in">New-Object</span> <span class="literal">-ComObject</span> WScript.Shell</span><br><span class="line"><span class="variable">$wsr</span> = <span class="variable">$ws</span>.popup(<span class="string">&quot;你好吗？&quot;</span>,<span class="number">5</span>,<span class="string">&quot;我的窗口&quot;</span>,<span class="number">1</span> + <span class="number">64</span>)</span><br></pre></td></tr></table></figure><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read-MessageBoxDialog</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$PopUpWin</span> = <span class="built_in">new-object</span> <span class="literal">-comobject</span> wscript.shell</span><br><span class="line"><span class="variable">$PopUpWin</span>.popup(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Read-MessageBoxDialog</span></span><br></pre></td></tr></table></figure><h4 id="法三：Form"><a href="#法三：Form" class="headerlink" title="法三：Form"></a>法三：Form</h4><h4 id="法四：VB"><a href="#法四：VB" class="headerlink" title="法四：VB"></a>法四：VB</h4><h3 id="个人整理："><a href="#个人整理：" class="headerlink" title="个人整理："></a>个人整理：</h3><h4 id="雷电模拟器内存耗尽："><a href="#雷电模拟器内存耗尽：" class="headerlink" title="雷电模拟器内存耗尽："></a>雷电模拟器内存耗尽：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read-MessageBoxDialog</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$wsPopUp</span> = <span class="built_in">new-object</span> <span class="literal">-comobject</span> wscript.shell</span><br><span class="line"><span class="variable">$wsPopUp</span>.popup(<span class="string">&quot;雷电模拟器可用内存即将耗尽，程序正在退出。ERROR_CODE=0000007E&quot;</span>,<span class="number">5</span>,<span class="string">&quot;LdBoxSVC&quot;</span>,<span class="number">1</span> + <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Read-MessageBoxDialog</span></span><br></pre></td></tr></table></figure><h4 id="系统内存耗尽："><a href="#系统内存耗尽：" class="headerlink" title="系统内存耗尽："></a>系统内存耗尽：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read-MessageBoxDialog</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$wsPopUp</span> = <span class="built_in">new-object</span> <span class="literal">-comobject</span> wscript.shell</span><br><span class="line"><span class="variable">$wsPopUp</span>.popup(<span class="string">&quot;计算机的内存不足。若要还原足够的内存以便程序正常工作，请保存文件，然后关闭或重新启动所有打开的程序。&quot;</span>,<span class="number">0</span>,<span class="string">&quot;Microsoft Windows&quot;</span>,<span class="number">0</span> + <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Read-MessageBoxDialog</span></span><br></pre></td></tr></table></figure><h4 id="系统内存错误："><a href="#系统内存错误：" class="headerlink" title="系统内存错误："></a>系统内存错误：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read-MessageBoxDialog</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$wsPopUp</span> = <span class="built_in">new-object</span> <span class="literal">-comobject</span> wscript.shell</span><br><span class="line"><span class="variable">$wsPopUp</span>.popup(<span class="string">&quot;&#x27;&#x27;0x0454A2B3&#x27;&#x27;指令引用了&#x27;&#x27;0x00000062&#x27;&#x27;内存，该内存不能为&#x27;&#x27;read&#x27;&#x27;。&quot;</span>,<span class="number">0</span>,<span class="string">&quot;Windows&quot;</span>,<span class="number">2</span> + <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Read-MessageBoxDialog</span></span><br></pre></td></tr></table></figure><h3 id="2020-1-9"><a href="#2020-1-9" class="headerlink" title="2020-1-9"></a>2020-1-9</h3><p>若要不显示ps窗体，可以加入”-WindowStyle Hidden”参数，但是弹窗也会被一并隐藏。我们可以使用bat调用vbs或js的wscript实现此功能。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mshta vbscript:CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>).popup(<span class="string">&quot;Hello,lxmxn&quot;</span>,<span class="number">7</span>,<span class="string">&quot;batch script&quot;</span>,<span class="number">64</span>)(window.close)</span><br><span class="line">mshta <span class="string">&quot;javascript:new ActiveXObject(&#x27;WScript.Shell&#x27;).popup(&#x27;Hello,lxmxn&#x27;,7,&#x27;batch script&#x27;,64);window.close();&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
            <tag> 弹窗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Soul的看法摘抄</title>
      <link href="/post/2020-01-06_soul-excerpt/"/>
      <url>/post/2020-01-06_soul-excerpt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘抄自<a href="https://www.zhihu.com/question/285158911/answer/570722809">在soul认识的女孩，网恋靠谱不？ - 呵呵呵的回答 - 知乎</a></p></blockquote><p>妄想通过这个APP找到灵魂伴侣的人还是死了这条心吧，现实中的感情都处理不好，网络又能奈何呢?你不知道网络对面的是人是鬼。首页上的确有很多恋爱了的，奔现了的，结婚了的，但是请注意，假设有2000万人在使用这个APP，有50对甚至100对成了难道很难吗?即便这样算下来概率也是极低的，而且我还不敢确定有没有这个数，工作人员自己编辑的文案和照片也说不定，我主专业学传媒的我了解这个套路，但也不能怪他们，作为运营方他们做的还是很成功了。</p><p>千万千万别因为渴望爱情而去脱单，爱情是很美好，但也伴随着同样比例的痛苦。你和身边的男生身处一样的环境，有着同样的身份，价值观都有可能截然不同，网络世界这么复杂，身份更是千奇百怪，何况上面底层屌丝不在少数，内心不坦荡思想肮脏龌龊的人更是不知多少，其实，你现在想靠这个软件脱单，和十年前你嘲笑的在QQ上被骗爱情的大妈行为其实是差不多的。</p><p>要因为真的喜欢，真的被吸引，再投入一段感情，感情太可贵了，好好享受好好珍惜，青春就那么几年，男生一旦开始工作少年大多会消失，过了25岁，想法行为就都变了，到时你就要考虑，你有没有那个资本去和他们在感情市场博弈，就没人会呵护一无所有只有一颗赤子之心的你了。</p><p>当然你也可以选择从现在起变强，攒够足够的资本，从外貌学历见识工作能力为人处世等方面全面晋升自己，这条路很难也很辛苦，但是走通了你也就豁达了。</p><p>然后你就步入另一个市场，婚姻。那时就和你优不优秀美不美丽关系越来越少了，进入另一个修罗场，需要掌握更多筹码了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Soul </tag>
            
            <tag> 恋爱 </tag>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语词典搭配&amp;作文万金油</title>
      <link href="/post/2019-12-11_e-dictionary-composition/"/>
      <url>/post/2019-12-11_e-dictionary-composition/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吴骁楠总是有很多闲钱</p><p>这回他整了个电子词典外形的古董安卓机玩</p><p>不过居然莫名的好用</p><p>低廉的价格（150）仍能实现的丰富功能是其一亮点，而且可以轻易地出入于学校的各个场合，甚至还拥有骁龙处理器和一颗570万像素的摄像头</p><p>就是这词典软件需要倒腾，已经在pdawiki挣扎了三天了</p><p>毕竟是唯一可以扩充MDX词库的词典了</p><p>（安卓1.6加成）</p></blockquote><h2 id="目前的个人词典搭配："><a href="#目前的个人词典搭配：" class="headerlink" title="目前的个人词典搭配："></a>目前的个人词典搭配：</h2><p><a href="https://www.pdawiki.com/forum/thread-31375-1-1.html">遗忘的好词典-superfan89的Oxford Learner’s Thesaurus-实用-改版-挖坟</a></p><ol><li><p>牛津高阶</p></li><li><p>柯林斯COBUILD双解</p></li><li><p>牛津英语搭配</p></li><li><p>牛津同义词辨析</p></li><li><p>wordsmyth同反义词</p></li><li><p>chambers衍生词</p></li><li><p>韦氏大学</p></li><li><p>英汉大汉英大</p></li><li><p>牛津高阶反查</p></li></ol><h2 id="顺手记下近来整理的英语作文万金油："><a href="#顺手记下近来整理的英语作文万金油：" class="headerlink" title="顺手记下近来整理的英语作文万金油："></a>顺手记下近来整理的英语作文万金油：</h2><h3 id="12-11"><a href="#12-11" class="headerlink" title="12-11"></a>12-11</h3><p>it behoves sb.to do （用于建议）</p><p>massive</p><p>surge ＝ boom</p><p>dispel the notion that</p><p>do our utmost to resolve the issue</p><p>in default of</p><p>in the light of</p><p>shoulder the liability of</p><p>which deserves credit</p><p>simply put</p><p>in the light of the above mentioned merits&#x2F;superiorities of</p><p>of vital significance</p><p>a top priority&#x2F;concern</p><p>have an edge over</p><p>by no means can sth. be taken for granted</p><p>only with joint efforts can we finally eliminate sth.</p><p>spark a heated debate</p><p>in wrestling with</p><p>bridge the gap between</p><p>pave the way for</p><p>appeal to sb. to tackle this tricky problem is really a feasible scheme</p><h3 id="12-13"><a href="#12-13" class="headerlink" title="12-13"></a>12-13</h3><p>opinions on this issue vary from person to person</p><p>people harbour different opinions</p><p>Blur the line between … and …</p><p>Fall victim to</p><p>Have profound impact on</p><p>Legislation can be enforced&#x2F;implemented&#x2F;imposed&#x2F;rolled out&#x2F;put into effect&#x2F;put in place to ensure&#x2F;guarantee the …</p><p>Given the complicated causes and severe consequences of sth. ,sth. have been done by sb. ,pressing sb. to come up with sth.</p><p>The government and school authorities concerned are expected to join forces to do …</p><h3 id="3-24"><a href="#3-24" class="headerlink" title="3-24"></a>3-24</h3><p>follow in the footsteps 效仿</p><p>self-evident 不言而喻的</p><h3 id="4-9"><a href="#4-9" class="headerlink" title="4-9"></a>4-9</h3><p>subsequently ＝ secondly</p><p>From where I stand, sth. will constitute an integral part of our future life and is an inevitable trend of social development.</p><h3 id="5-4"><a href="#5-4" class="headerlink" title="5-4"></a>5-4</h3><p>solidarity 团结</p><h3 id="5-30"><a href="#5-30" class="headerlink" title="5-30"></a>5-30</h3><p>Lying behind such a phenomenon are a host of factors in which the mixture of elderly’s loneliness and the youngster’s financial risks plays an indispensable role.</p><hr><h2 id="IS01补图："><a href="#IS01补图：" class="headerlink" title="IS01补图："></a>IS01补图：</h2><p><img src="https://static.pil0txia.com/picgo/P91216-120350.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120436.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120446.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120519.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120540.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120600.jpg"><br><img src="https://static.pil0txia.com/picgo/P91216-120619.jpg"></p><hr><h2 id="2020-1-7更新："><a href="#2020-1-7更新：" class="headerlink" title="2020-1-7更新："></a>2020-1-7更新：</h2><p>夏普IS01玩机进入最后阶段——SSH+PowerShell&amp;ROOT！——“Where there is a Shell,there is a way.”<br>作为一台功能完整而操作蹩脚的终端，连接班级Win10原生支持的OpenSSH服务端执行简单的任务毫不费劲，看着小伙伴们准备上网、打着字一抬头发现浏览器不见了的惊愕表情，连输入下一行代码的手速都变快了。但是BTEP想达到Termux般的强大与自定义化还有很长距离，不值得付出精力折腾<br>而ROOT是可以做一次尝试的，毕竟安卓1.6怎会无法ROOT？然而初代安卓的那个年代刷新了我的认识，<br>不仅低于所有ROOT APP的版本限制，一台连“adb reboot bootloader”命令都无法执行的机器又怎会有机会使用完整的adb工具包？<br>遍历全网折腾一晚，除非有厂家技术支持，这活计近期算是不用麻烦了</p><h2 id="2020-1-9更新："><a href="#2020-1-9更新：" class="headerlink" title="2020-1-9更新："></a>2020-1-9更新：</h2><p>此前无论是SSH还是FTP的“quote site exec”执行命令都无法远程在前台显示图形化窗口，毕竟不是RDP而是命令行。今天总算是将唯一可能的解决方案“计划任务schtasks”调试完成，结合李浩诚的搞怪程序，实施效果应该会非常可观。<br>代码原文：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tmpTime</span> = <span class="built_in">Invoke-Command</span> <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">get-date</span> <span class="literal">-format</span> <span class="string">&#x27;HH:mm&#x27;</span> &#125;</span><br><span class="line"><span class="variable">$tmpTimeName</span> = <span class="built_in">Invoke-Command</span> <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">get-date</span> <span class="literal">-format</span> <span class="string">&#x27;YYMMDDHHmm&#x27;</span> &#125;</span><br><span class="line"><span class="variable">$Hour</span>=[<span class="built_in">int</span>](<span class="variable">$tmpTime</span>.SubString(<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"><span class="variable">$Minute</span>=[<span class="built_in">int</span>](<span class="variable">$tmpTime</span>.SubString(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="variable">$Minute</span>=<span class="variable">$Minute</span>+<span class="number">1</span></span><br><span class="line"><span class="variable">$StartTime</span> = <span class="string">&quot;&#123;0:d2&#125;:&#123;1:d2&#125;&quot;</span>  <span class="operator">-f</span>  <span class="variable">$Hour</span>,<span class="variable">$Minute</span></span><br><span class="line"><span class="variable">$Cmd</span>=<span class="string">&quot;C:\Users\Administrator.class402\scripts\schtasks/1.bat&quot;</span></span><br><span class="line"><span class="built_in">invoke-command</span> <span class="literal">-scriptblock</span> &#123;schtasks /create /tn <span class="string">&quot;schtasks&quot;</span> /tr <span class="variable">$Cmd</span> /<span class="built_in">sc</span> once /st <span class="variable">$StartTime</span> /f&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> 词典 </tag>
            
            <tag> 电子词典 </tag>
            
            <tag> 作文 </tag>
            
            <tag> 好词好句 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
